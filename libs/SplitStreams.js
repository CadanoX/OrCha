(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require('d3'));
  else if (typeof define === 'function' && define.amd) define(['d3'], factory);
  else if (typeof exports === 'object')
    exports['SplitStreams'] = factory(require('d3'));
  else root['SplitStreams'] = factory(root['d3']);
})(window, function(__WEBPACK_EXTERNAL_MODULE_d3__) {
  return /******/ (function(modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {}; // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports;
        /******/
      } // Create a new module (and put it into the cache)
      /******/ /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {}
        /******/
      }); // Execute the module function
      /******/
      /******/ /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      ); // Flag the module as loaded
      /******/
      /******/ /******/ module.l = true; // Return the exports of the module
      /******/
      /******/ /******/ return module.exports;
      /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules; // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter
        });
        /******/
      }
      /******/
    }; // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function(exports) {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
      value,
      mode
    ) {
      /******/ if (mode & 1) value = __webpack_require__(value);
      /******/ if (mode & 8) return value;
      /******/ if (
        mode & 4 &&
        typeof value === 'object' &&
        value &&
        value.__esModule
      )
        return value;
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ Object.defineProperty(ns, 'default', {
        enumerable: true,
        value: value
      });
      /******/ if (mode & 2 && typeof value != 'string')
        for (var key in value)
          __webpack_require__.d(
            ns,
            key,
            function(key) {
              return value[key];
            }.bind(null, key)
          );
      /******/ return ns;
      /******/
    }; // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function(module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module['default'];
            }
          : /******/ function getModuleExports() {
              return module;
            };
      /******/ __webpack_require__.d(getter, 'a', getter);
      /******/ return getter;
      /******/
    }; // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }; // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = ''; // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__(
      (__webpack_require__.s = './src/lib.js')
    );
    /******/
  })(
    /************************************************************************/
    /******/ {
      /***/ './css/SplitStream.css':
        /*!*****************************!*\
  !*** ./css/SplitStream.css ***!
  \*****************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./SplitStream.css */ "./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css");\n\nif (typeof content === \'string\') {\n  content = [[module.i, content, \'\']];\n}\n\nvar options = {}\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9jc3MvU3BsaXRTdHJlYW0uY3NzPzA3ZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDhIQUE0RDs7QUFFbEY7QUFDQSxjQUFjLFFBQVM7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsbUpBQXdFOztBQUU3RjtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9jc3MvU3BsaXRTdHJlYW0uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL1NwbGl0U3RyZWFtLmNzc1wiKTtcblxuaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG59XG5cbnZhciBvcHRpb25zID0ge31cblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/SplitStream.css\n'
          );

          /***/
        },

      /***/ './libs/d3svgfilters/src/d3-svg-filters.js':
        /*!*************************************************!*\
  !*** ./libs/d3svgfilters/src/d3-svg-filters.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "const d3 =  true ? __webpack_require__(/*! d3 */ \"d3\") : undefined;\r\n\r\nclass SVGFilter {\r\n  constructor(spec) {}\r\n\r\n  set id(id) {\r\n    this._id = id;\r\n  }\r\n  get id() {\r\n    return this._id;\r\n  }\r\n}\r\n\r\nclass SVGFilterManagerLibrary {\r\n  constructor() {\r\n    this._library = {}; // name : { generate: (defs) => (args) => {  appends filter to defs }, signature: (args) => key}\r\n  }\r\n\r\n  static GenerateID() {\r\n    if (!this.__ID) this.__ID = 0;\r\n\r\n    return ++this.__ID;\r\n  }\r\n\r\n  addFilter(name, fns) {\r\n    this._library[name] = fns;\r\n  }\r\n\r\n  signature(filterName, args) {\r\n    return this._library[filterName]\r\n      .signature(args)\r\n      .replace(/\\:|\\,|\\.|\\;/g, '_')\r\n      .replace(/ /g, '')\r\n      .replace(/\\#/g, 'h')\r\n      .replace(/\\(/g, 'l')\r\n      .replace(/\\)/g, 'r');\r\n  }\r\n\r\n  generate(defs, filterName, args) {\r\n    const signature = this.signature(filterName, args);\r\n    const ctx = { signature, defs };\r\n    const theFilter = this._library[filterName].generate.call(ctx, {\r\n      ...args,\r\n      id: SVGFilterManagerLibrary.GenerateID()\r\n    });\r\n\r\n    defs.node().__filters__.push({ signature, filter: theFilter });\r\n  }\r\n\r\n  static Suffix() {\r\n    if (!this._suffix) this._suffix = 0;\r\n    return this._suffix++;\r\n  }\r\n\r\n  makeUnique(filterText) {\r\n    const varNames = /result=(.+?)/g.test(filterText);\r\n  }\r\n}\r\n\r\nconst GenSVGFilters = (...filters) => {};\r\n\r\nconst Lib = new SVGFilterManagerLibrary();\r\nLib.addFilter('drop-shadow', {\r\n  generate: function({ color, dx, dy, blur }) {\r\n    const key = this.signature;\r\n    const existing = this.defs.select(`#${key}`);\r\n\r\n    if (!existing.empty()) return existing;\r\n\r\n    const theDropShadow = this.defs.html(\r\n      this.defs.html() +\r\n        `\r\n            <feDropShadow\r\n                id='${key}'\r\n                dx='${dx}'\r\n                dy='${dy}'\r\n                stdDeviation='${blur}'\r\n                flood-color=${color} />\r\n        `\r\n    );\r\n\r\n    return theDropShadow;\r\n  },\r\n  signature: ({ color, dx, dy, blur }) => `ds_${color}_${blur}_${dx}_${dy}`\r\n});\r\n\r\nLib.addFilter('blur', {\r\n  generate: function({ blur }) {\r\n    const key = this.signature;\r\n    const existing = this.defs.select(`#${key}`);\r\n\r\n    if (!existing.empty()) return existing;\r\n\r\n    const theBlur = this.defs\r\n      .append('feGaussianBlur')\r\n      .attr('stdDeviation', blur);\r\n\r\n    return theBlur;\r\n  },\r\n  signature: ({ blur }) => `gbl_${blur}`\r\n});\r\n\r\nLib.addFilter('inner-shadow', {\r\n  generate: function({ id, color, dx, dy, blur }) {\r\n    const key = this.signature;\r\n    const existing = this.defs.select(`#${key}`);\r\n\r\n    if (!existing.empty()) return existing;\r\n\r\n    this.defs.html(\r\n      this.defs.html() +\r\n        `\r\n            <feGaussianBlur\r\n                in='SourceAlpha'\r\n                stdDeviation='${blur}'\r\n                result='blur${id}' />\r\n\r\n            <feOffset dx=${dx} dy=${dy} />\r\n\r\n            <feComposite\r\n                in2='SourceAlpha'\r\n                operator='arithmetic'\r\n                k2=-1\r\n                k3=1\r\n                result='shadowDiff${id}' />\r\n\r\n            <feFlood flood-color=${color} />\r\n\r\n            <feComposite\r\n                in2='shadowDiff${id}'\r\n                operator='in' />\r\n\r\n            <feComposite\r\n                in2='SourceGraphic'\r\n                operator='over'\r\n                result='firstFilter${id}' />\r\n\r\n            <feComposite\r\n                in2='shadowDiff${id}'\r\n                operator='in' />\r\n\r\n            <feComposite\r\n                in2='firstFilter${id}'\r\n                operator='over' />\r\n        `\r\n    );\r\n  },\r\n  signature: ({ color, dx, dy, blur }) => `ids_${color}_${blur}_${dx}_${dy}`\r\n});\r\n\r\nLib.addFilter('double-inner-shadow', {\r\n  generate: function({ id, color, dx, dy, blur }) {\r\n    const key = this.signature;\r\n    const existing = this.defs.select(`#${key}`);\r\n\r\n    if (!existing.empty()) return existing;\r\n\r\n    this.defs.html(\r\n      this.defs.html() +\r\n        `\r\n            <feComponentTransfer in=SourceAlpha result=\"invert${id}\">\r\n                <feFuncA type=\"table\" tableValues=\"1 0\" />\r\n            </feComponentTransfer>\r\n            <feGaussianBlur in=\"invert${id}\" stdDeviation=\"${blur}\" result=\"blur${id}\"/>\r\n            <feOffset in=\"blur${id}\" dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur1${id}\"/>\r\n            <feOffset in=\"blur${id}\" dy=\"${-dy}\" result=\"offsetblur2${id}\"/>\r\n            <feFlood flood-color=\"${color}\"/> \r\n            <feComposite in2=\"offsetblur1${id}\" operator=\"in\" result=\"offsetblur1cut${id}\"/>\r\n            <feFlood flood-color=\"${color}\"/> \r\n            <feComposite in2=\"offsetblur2${id}\" operator=\"in\" result=\"offsetblur2cut${id}\"/>\r\n            <feMerge>\r\n                <feMergeNode in=\"SourceGraphic\" />\r\n                <feMergeNode in=\"offsetblur1${id}\" />\r\n                <feMergeNode in=\"offsetblur2${id}\" />\r\n            </feMerge>\r\n            <feComposite in2=\"SourceAlpha\" operator=\"in\" />\r\n        `\r\n    );\r\n  },\r\n  signature: ({ color, dx, dy, blur }) => `dids_${color}_${blur}_${dx}_${dy}`\r\n});\r\n\r\nclass SVGFilterManager {\r\n  constructor(defs) {\r\n    this._filters = {\r\n      boxShadow: {}\r\n    }; // Type : filterKey : id\r\n\r\n    this._defs = defs;\r\n    this._ids = {};\r\n\r\n    this._bindings = {}; // id : [DOMNode]\r\n  }\r\n\r\n  _bind(selection, id) {\r\n    const bindings = this._bindings[id];\r\n\r\n    selection.each(function(d, i) {\r\n      bindings.push(this);\r\n    });\r\n  }\r\n\r\n  _unbind(selection, id) {\r\n    const bindings = this._bindings[id];\r\n\r\n    const toRemove = [];\r\n    selection.each(function(d, i) {\r\n      toRemove.push(this);\r\n    });\r\n\r\n    bindings[id] = bindings.filter(node => !toRemove.includes(node));\r\n\r\n    if (bindings[id].length === 0) this._deleteFilter(id);\r\n  }\r\n\r\n  _deleteFilter(id) {\r\n    let toDelete;\r\n    Object.entries(this._ids).forEach(([signature, theID]) => {\r\n      if (theID === id) {\r\n        toDelete = signature;\r\n        return false;\r\n      }\r\n    });\r\n\r\n    delete this._ids[toDelete];\r\n    delete this._bindings[id];\r\n    this._defs.select('#' + id).remove();\r\n  }\r\n\r\n  hasFilter(signature) {\r\n    return !!this._ids[signature];\r\n    // return !this._defs.select('#' + signature).empty();\r\n  }\r\n\r\n  signature(...args) {\r\n    // ['name', arg, 'name2', arg]\r\n    // ['', ]\r\n    return (\r\n      'F_' +\r\n      args\r\n        .map((arg, i) => (i % 2 === 0 ? '' : Lib.signature(args[i - 1], arg)))\r\n        .filter(v => v !== '')\r\n        .join('_')\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates a filter from the list of filters in the format\r\n   * (filter-name-1, args1, filter-name-2, args2, ... , filter-name-N, argsN)\r\n   *\r\n   * @param {*} args\r\n   * @memberof SVGFilterManager\r\n   */\r\n  createFilter(...args) {\r\n    // 1. Compute signature and see if it already exists\r\n    const signature = this.signature(...args);\r\n\r\n    if (this.hasFilter(signature)) return this.getFilterID(signature);\r\n\r\n    const theID = (this._ids[signature] = SVGFilterManager._genID());\r\n    this._bindings[theID] = [];\r\n\r\n    const filterEntry = this._defs\r\n      .append('filter')\r\n      .attr('id', theID)\r\n      .attr('height', '300%')\r\n      .attr('width', '300%')\r\n      .attr('x', '-100%')\r\n      .attr('y', '-100%');\r\n\r\n    filterEntry.node().__filters__ = [];\r\n\r\n    args.forEach((arg, i) => {\r\n      if (i % 2 === 0) return Lib.generate(filterEntry, arg, args[i + 1]);\r\n    });\r\n\r\n    return theID;\r\n  }\r\n\r\n  static _genID() {\r\n    if (!this.__idc__) this.__idc__ = 0;\r\n    return `FILTER_${this.__idc__++}`;\r\n  }\r\n\r\n  // _genID() {\r\n  // }\r\n\r\n  getFilterID(signature) {\r\n    return this._ids[signature];\r\n  }\r\n}\r\n\r\nd3.selection.prototype.svgFilter = function(...filters) {\r\n  // name, args, name1, args1, ... ,nameN, argsN\r\n  // If no defs entry, generate one at the root and set it @ the svg filter manager\r\n  // create a new svg filter manager for that svg\r\n\r\n  // 1. Find topmost SVG\r\n  // let svg = d3.select(this.node().farthestViewportElement || this.node().closest('svg'));\r\n\r\n  // // 2. Ensure the defs entry exists\r\n  // let defs = svg.select(':scope>defs.svg-custom-filters');\r\n  // if (defs.empty()) {\r\n  //     defs = svg.append('defs').attr('class', 'svg-custom-filters');\r\n  //     defs.node()._svgFilterManager = new SVGFilterManager(defs);\r\n  // }\r\n\r\n  const defs = this.svgFilterDefs();\r\n\r\n  const filterManager = defs.node()._svgFilterManager;\r\n  const filterID = filterManager.createFilter(...filters);\r\n\r\n  this.each(function(d) {\r\n    const sel = d3.select(this);\r\n    if (filterID === sel.getFilterID()) return;\r\n    sel.clearFilter();\r\n\r\n    sel.attr('filter', `url(#${filterID})`);\r\n    filterManager._bind(sel, filterID);\r\n  });\r\n\r\n  // 3. Generate a filter manager if not existing\r\n\r\n  // TheFilterManager._defs;\r\n  // const ids = GenSVGFilters(filters);\r\n};\r\n\r\nd3.selection.prototype.svgFilterDefs = function() {\r\n  // 1. Find topmost SVG\r\n  let svg = d3.select(\r\n    this.node().farthestViewportElement || this.node().closest('svg')\r\n  );\r\n\r\n  // 2. Ensure the defs entry exists\r\n  let defs = svg.select(':scope>defs.svg-custom-filters');\r\n  if (defs.empty()) {\r\n    defs = svg.append('defs').attr('class', 'svg-custom-filters');\r\n    defs.node()._svgFilterManager = new SVGFilterManager(defs);\r\n  }\r\n\r\n  return defs;\r\n};\r\n\r\nd3.selection.prototype.getFilterID = function() {\r\n  const filterAttr = this.attr('filter');\r\n\r\n  let filterID;\r\n  if (!!filterAttr) filterID = /\\(\\#(.+)\\)/.exec(filterAttr)[1];\r\n\r\n  return filterID;\r\n};\r\n\r\nd3.selection.prototype.clearFilter = function() {\r\n  this.each(function(d, i) {\r\n    const sel = d3.select(this);\r\n    const filterID = sel.getFilterID();\r\n    if (!filterID) return;\r\n\r\n    const defs = sel.svgFilterDefs();\r\n    const filterManager = defs.node()._svgFilterManager;\r\n\r\n    sel.attr('filter', null);\r\n    filterManager._unbind(sel, filterID);\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\nd3.svgFilterLib = Lib;\r\n\r\n// const originalRemove = d3.selection.prototype.remove;\r\n// d3.selection.prototype.remove = function () { // Add in clear filter to remove fn!\r\n//     this.selectAll('*').clearFilter();\r\n//     originalRemove.call(this, ...arguments);\r\n// }\r\n\r\n// d3.svgFilter = (name, args) => lib.filter(name)(args);\r\n\r\n// Example usage\r\nconst selection = {};\r\n\r\n// selection\r\n//     .svgFilter(\r\n//         d3.svgFilterBoxShadow({\r\n//             dx: '5%',\r\n//             dy: '5%',\r\n//             blur: '25%'\r\n//         }),\r\n//         d3.svgFilterBoxShadowInset({\r\n//             dx: '5%',\r\n//             dy: '5%',\r\n//             blur: '25%'\r\n//         })\r\n//     );\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9saWJzL2Qzc3ZnZmlsdGVycy9zcmMvZDMtc3ZnLWZpbHRlcnMuanM/NDRkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLEtBQTZCLEdBQUcsbUJBQU8sQ0FBQyxjQUFJLElBQUksU0FBUzs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksZ0NBQWdDLDBCQUEwQjtBQUM3Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxrQ0FBa0MsK0JBQStCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUIsc0JBQXNCLEdBQUc7QUFDekIsc0JBQXNCLEdBQUc7QUFDekIsZ0NBQWdDLEtBQUs7QUFDckMsOEJBQThCLE1BQU07QUFDcEM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxlQUFlLHNCQUFzQixXQUFXLE1BQU0sR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDMUUsQ0FBQzs7QUFFRDtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxlQUFlLE9BQU8sWUFBWSxLQUFLO0FBQ3ZDLENBQUM7O0FBRUQ7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQyw4QkFBOEIsR0FBRzs7QUFFakMsMkJBQTJCLEdBQUcsTUFBTSxHQUFHOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUc7O0FBRXZDLG1DQUFtQyxNQUFNOztBQUV6QztBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHOztBQUV4QztBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDOztBQUVBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCLFlBQVksTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztBQUMzRSxDQUFDOztBQUVEO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBLDBDQUEwQyxJQUFJOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRztBQUNuRTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUcsa0JBQWtCLEtBQUssZ0JBQWdCLEdBQUc7QUFDckYsZ0NBQWdDLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyx1QkFBdUIsR0FBRztBQUNuRixnQ0FBZ0MsR0FBRyxRQUFRLElBQUksdUJBQXVCLEdBQUc7QUFDekUsb0NBQW9DLE1BQU07QUFDMUMsMkNBQTJDLEdBQUcsd0NBQXdDLEdBQUc7QUFDekYsb0NBQW9DLE1BQU07QUFDMUMsMkNBQTJDLEdBQUcsd0NBQXdDLEdBQUc7QUFDekY7QUFDQTtBQUNBLDhDQUE4QyxHQUFHO0FBQ2pELDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCLGFBQWEsTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztBQUM1RSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJmaWxlIjoiLi9saWJzL2Qzc3ZnZmlsdGVycy9zcmMvZDMtc3ZnLWZpbHRlcnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkMyA9IHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gcmVxdWlyZSgnZDMnKSA6IHdpbmRvdy5kMztcclxuXHJcbmNsYXNzIFNWR0ZpbHRlciB7XHJcbiAgY29uc3RydWN0b3Ioc3BlYykge31cclxuXHJcbiAgc2V0IGlkKGlkKSB7XHJcbiAgICB0aGlzLl9pZCA9IGlkO1xyXG4gIH1cclxuICBnZXQgaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBTVkdGaWx0ZXJNYW5hZ2VyTGlicmFyeSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLl9saWJyYXJ5ID0ge307IC8vIG5hbWUgOiB7IGdlbmVyYXRlOiAoZGVmcykgPT4gKGFyZ3MpID0+IHsgIGFwcGVuZHMgZmlsdGVyIHRvIGRlZnMgfSwgc2lnbmF0dXJlOiAoYXJncykgPT4ga2V5fVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIEdlbmVyYXRlSUQoKSB7XHJcbiAgICBpZiAoIXRoaXMuX19JRCkgdGhpcy5fX0lEID0gMDtcclxuXHJcbiAgICByZXR1cm4gKyt0aGlzLl9fSUQ7XHJcbiAgfVxyXG5cclxuICBhZGRGaWx0ZXIobmFtZSwgZm5zKSB7XHJcbiAgICB0aGlzLl9saWJyYXJ5W25hbWVdID0gZm5zO1xyXG4gIH1cclxuXHJcbiAgc2lnbmF0dXJlKGZpbHRlck5hbWUsIGFyZ3MpIHtcclxuICAgIHJldHVybiB0aGlzLl9saWJyYXJ5W2ZpbHRlck5hbWVdXHJcbiAgICAgIC5zaWduYXR1cmUoYXJncylcclxuICAgICAgLnJlcGxhY2UoL1xcOnxcXCx8XFwufFxcOy9nLCAnXycpXHJcbiAgICAgIC5yZXBsYWNlKC8gL2csICcnKVxyXG4gICAgICAucmVwbGFjZSgvXFwjL2csICdoJylcclxuICAgICAgLnJlcGxhY2UoL1xcKC9nLCAnbCcpXHJcbiAgICAgIC5yZXBsYWNlKC9cXCkvZywgJ3InKTtcclxuICB9XHJcblxyXG4gIGdlbmVyYXRlKGRlZnMsIGZpbHRlck5hbWUsIGFyZ3MpIHtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbmF0dXJlKGZpbHRlck5hbWUsIGFyZ3MpO1xyXG4gICAgY29uc3QgY3R4ID0geyBzaWduYXR1cmUsIGRlZnMgfTtcclxuICAgIGNvbnN0IHRoZUZpbHRlciA9IHRoaXMuX2xpYnJhcnlbZmlsdGVyTmFtZV0uZ2VuZXJhdGUuY2FsbChjdHgsIHtcclxuICAgICAgLi4uYXJncyxcclxuICAgICAgaWQ6IFNWR0ZpbHRlck1hbmFnZXJMaWJyYXJ5LkdlbmVyYXRlSUQoKVxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVmcy5ub2RlKCkuX19maWx0ZXJzX18ucHVzaCh7IHNpZ25hdHVyZSwgZmlsdGVyOiB0aGVGaWx0ZXIgfSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgU3VmZml4KCkge1xyXG4gICAgaWYgKCF0aGlzLl9zdWZmaXgpIHRoaXMuX3N1ZmZpeCA9IDA7XHJcbiAgICByZXR1cm4gdGhpcy5fc3VmZml4Kys7XHJcbiAgfVxyXG5cclxuICBtYWtlVW5pcXVlKGZpbHRlclRleHQpIHtcclxuICAgIGNvbnN0IHZhck5hbWVzID0gL3Jlc3VsdD0oLis/KS9nLnRlc3QoZmlsdGVyVGV4dCk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBHZW5TVkdGaWx0ZXJzID0gKC4uLmZpbHRlcnMpID0+IHt9O1xyXG5cclxuY29uc3QgTGliID0gbmV3IFNWR0ZpbHRlck1hbmFnZXJMaWJyYXJ5KCk7XHJcbkxpYi5hZGRGaWx0ZXIoJ2Ryb3Atc2hhZG93Jywge1xyXG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGNvbG9yLCBkeCwgZHksIGJsdXIgfSkge1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5zaWduYXR1cmU7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZGVmcy5zZWxlY3QoYCMke2tleX1gKTtcclxuXHJcbiAgICBpZiAoIWV4aXN0aW5nLmVtcHR5KCkpIHJldHVybiBleGlzdGluZztcclxuXHJcbiAgICBjb25zdCB0aGVEcm9wU2hhZG93ID0gdGhpcy5kZWZzLmh0bWwoXHJcbiAgICAgIHRoaXMuZGVmcy5odG1sKCkgK1xyXG4gICAgICAgIGBcclxuICAgICAgICAgICAgPGZlRHJvcFNoYWRvd1xyXG4gICAgICAgICAgICAgICAgaWQ9JyR7a2V5fSdcclxuICAgICAgICAgICAgICAgIGR4PScke2R4fSdcclxuICAgICAgICAgICAgICAgIGR5PScke2R5fSdcclxuICAgICAgICAgICAgICAgIHN0ZERldmlhdGlvbj0nJHtibHVyfSdcclxuICAgICAgICAgICAgICAgIGZsb29kLWNvbG9yPSR7Y29sb3J9IC8+XHJcbiAgICAgICAgYFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhlRHJvcFNoYWRvdztcclxuICB9LFxyXG4gIHNpZ25hdHVyZTogKHsgY29sb3IsIGR4LCBkeSwgYmx1ciB9KSA9PiBgZHNfJHtjb2xvcn1fJHtibHVyfV8ke2R4fV8ke2R5fWBcclxufSk7XHJcblxyXG5MaWIuYWRkRmlsdGVyKCdibHVyJywge1xyXG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGJsdXIgfSkge1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5zaWduYXR1cmU7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZGVmcy5zZWxlY3QoYCMke2tleX1gKTtcclxuXHJcbiAgICBpZiAoIWV4aXN0aW5nLmVtcHR5KCkpIHJldHVybiBleGlzdGluZztcclxuXHJcbiAgICBjb25zdCB0aGVCbHVyID0gdGhpcy5kZWZzXHJcbiAgICAgIC5hcHBlbmQoJ2ZlR2F1c3NpYW5CbHVyJylcclxuICAgICAgLmF0dHIoJ3N0ZERldmlhdGlvbicsIGJsdXIpO1xyXG5cclxuICAgIHJldHVybiB0aGVCbHVyO1xyXG4gIH0sXHJcbiAgc2lnbmF0dXJlOiAoeyBibHVyIH0pID0+IGBnYmxfJHtibHVyfWBcclxufSk7XHJcblxyXG5MaWIuYWRkRmlsdGVyKCdpbm5lci1zaGFkb3cnLCB7XHJcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHsgaWQsIGNvbG9yLCBkeCwgZHksIGJsdXIgfSkge1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5zaWduYXR1cmU7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZGVmcy5zZWxlY3QoYCMke2tleX1gKTtcclxuXHJcbiAgICBpZiAoIWV4aXN0aW5nLmVtcHR5KCkpIHJldHVybiBleGlzdGluZztcclxuXHJcbiAgICB0aGlzLmRlZnMuaHRtbChcclxuICAgICAgdGhpcy5kZWZzLmh0bWwoKSArXHJcbiAgICAgICAgYFxyXG4gICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXJcclxuICAgICAgICAgICAgICAgIGluPSdTb3VyY2VBbHBoYSdcclxuICAgICAgICAgICAgICAgIHN0ZERldmlhdGlvbj0nJHtibHVyfSdcclxuICAgICAgICAgICAgICAgIHJlc3VsdD0nYmx1ciR7aWR9JyAvPlxyXG5cclxuICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSR7ZHh9IGR5PSR7ZHl9IC8+XHJcblxyXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGVcclxuICAgICAgICAgICAgICAgIGluMj0nU291cmNlQWxwaGEnXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcj0nYXJpdGhtZXRpYydcclxuICAgICAgICAgICAgICAgIGsyPS0xXHJcbiAgICAgICAgICAgICAgICBrMz0xXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ9J3NoYWRvd0RpZmYke2lkfScgLz5cclxuXHJcbiAgICAgICAgICAgIDxmZUZsb29kIGZsb29kLWNvbG9yPSR7Y29sb3J9IC8+XHJcblxyXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGVcclxuICAgICAgICAgICAgICAgIGluMj0nc2hhZG93RGlmZiR7aWR9J1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I9J2luJyAvPlxyXG5cclxuICAgICAgICAgICAgPGZlQ29tcG9zaXRlXHJcbiAgICAgICAgICAgICAgICBpbjI9J1NvdXJjZUdyYXBoaWMnXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcj0nb3ZlcidcclxuICAgICAgICAgICAgICAgIHJlc3VsdD0nZmlyc3RGaWx0ZXIke2lkfScgLz5cclxuXHJcbiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZVxyXG4gICAgICAgICAgICAgICAgaW4yPSdzaGFkb3dEaWZmJHtpZH0nXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcj0naW4nIC8+XHJcblxyXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGVcclxuICAgICAgICAgICAgICAgIGluMj0nZmlyc3RGaWx0ZXIke2lkfSdcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yPSdvdmVyJyAvPlxyXG4gICAgICAgIGBcclxuICAgICk7XHJcbiAgfSxcclxuICBzaWduYXR1cmU6ICh7IGNvbG9yLCBkeCwgZHksIGJsdXIgfSkgPT4gYGlkc18ke2NvbG9yfV8ke2JsdXJ9XyR7ZHh9XyR7ZHl9YFxyXG59KTtcclxuXHJcbkxpYi5hZGRGaWx0ZXIoJ2RvdWJsZS1pbm5lci1zaGFkb3cnLCB7XHJcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHsgaWQsIGNvbG9yLCBkeCwgZHksIGJsdXIgfSkge1xyXG4gICAgY29uc3Qga2V5ID0gdGhpcy5zaWduYXR1cmU7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZGVmcy5zZWxlY3QoYCMke2tleX1gKTtcclxuXHJcbiAgICBpZiAoIWV4aXN0aW5nLmVtcHR5KCkpIHJldHVybiBleGlzdGluZztcclxuXHJcbiAgICB0aGlzLmRlZnMuaHRtbChcclxuICAgICAgdGhpcy5kZWZzLmh0bWwoKSArXHJcbiAgICAgICAgYFxyXG4gICAgICAgICAgICA8ZmVDb21wb25lbnRUcmFuc2ZlciBpbj1Tb3VyY2VBbHBoYSByZXN1bHQ9XCJpbnZlcnQke2lkfVwiPlxyXG4gICAgICAgICAgICAgICAgPGZlRnVuY0EgdHlwZT1cInRhYmxlXCIgdGFibGVWYWx1ZXM9XCIxIDBcIiAvPlxyXG4gICAgICAgICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+XHJcbiAgICAgICAgICAgIDxmZUdhdXNzaWFuQmx1ciBpbj1cImludmVydCR7aWR9XCIgc3RkRGV2aWF0aW9uPVwiJHtibHVyfVwiIHJlc3VsdD1cImJsdXIke2lkfVwiLz5cclxuICAgICAgICAgICAgPGZlT2Zmc2V0IGluPVwiYmx1ciR7aWR9XCIgZHg9XCIke2R4fVwiIGR5PVwiJHtkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyMSR7aWR9XCIvPlxyXG4gICAgICAgICAgICA8ZmVPZmZzZXQgaW49XCJibHVyJHtpZH1cIiBkeT1cIiR7LWR5fVwiIHJlc3VsdD1cIm9mZnNldGJsdXIyJHtpZH1cIi8+XHJcbiAgICAgICAgICAgIDxmZUZsb29kIGZsb29kLWNvbG9yPVwiJHtjb2xvcn1cIi8+IFxyXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1cjEke2lkfVwiIG9wZXJhdG9yPVwiaW5cIiByZXN1bHQ9XCJvZmZzZXRibHVyMWN1dCR7aWR9XCIvPlxyXG4gICAgICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiR7Y29sb3J9XCIvPiBcclxuICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cIm9mZnNldGJsdXIyJHtpZH1cIiBvcGVyYXRvcj1cImluXCIgcmVzdWx0PVwib2Zmc2V0Ymx1cjJjdXQke2lkfVwiLz5cclxuICAgICAgICAgICAgPGZlTWVyZ2U+XHJcbiAgICAgICAgICAgICAgICA8ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCIgLz5cclxuICAgICAgICAgICAgICAgIDxmZU1lcmdlTm9kZSBpbj1cIm9mZnNldGJsdXIxJHtpZH1cIiAvPlxyXG4gICAgICAgICAgICAgICAgPGZlTWVyZ2VOb2RlIGluPVwib2Zmc2V0Ymx1cjIke2lkfVwiIC8+XHJcbiAgICAgICAgICAgIDwvZmVNZXJnZT5cclxuICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cIlNvdXJjZUFscGhhXCIgb3BlcmF0b3I9XCJpblwiIC8+XHJcbiAgICAgICAgYFxyXG4gICAgKTtcclxuICB9LFxyXG4gIHNpZ25hdHVyZTogKHsgY29sb3IsIGR4LCBkeSwgYmx1ciB9KSA9PiBgZGlkc18ke2NvbG9yfV8ke2JsdXJ9XyR7ZHh9XyR7ZHl9YFxyXG59KTtcclxuXHJcbmNsYXNzIFNWR0ZpbHRlck1hbmFnZXIge1xyXG4gIGNvbnN0cnVjdG9yKGRlZnMpIHtcclxuICAgIHRoaXMuX2ZpbHRlcnMgPSB7XHJcbiAgICAgIGJveFNoYWRvdzoge31cclxuICAgIH07IC8vIFR5cGUgOiBmaWx0ZXJLZXkgOiBpZFxyXG5cclxuICAgIHRoaXMuX2RlZnMgPSBkZWZzO1xyXG4gICAgdGhpcy5faWRzID0ge307XHJcblxyXG4gICAgdGhpcy5fYmluZGluZ3MgPSB7fTsgLy8gaWQgOiBbRE9NTm9kZV1cclxuICB9XHJcblxyXG4gIF9iaW5kKHNlbGVjdGlvbiwgaWQpIHtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3NbaWRdO1xyXG5cclxuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgYmluZGluZ3MucHVzaCh0aGlzKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3VuYmluZChzZWxlY3Rpb24sIGlkKSB7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzW2lkXTtcclxuXHJcbiAgICBjb25zdCB0b1JlbW92ZSA9IFtdO1xyXG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG4gICAgICB0b1JlbW92ZS5wdXNoKHRoaXMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYmluZGluZ3NbaWRdID0gYmluZGluZ3MuZmlsdGVyKG5vZGUgPT4gIXRvUmVtb3ZlLmluY2x1ZGVzKG5vZGUpKTtcclxuXHJcbiAgICBpZiAoYmluZGluZ3NbaWRdLmxlbmd0aCA9PT0gMCkgdGhpcy5fZGVsZXRlRmlsdGVyKGlkKTtcclxuICB9XHJcblxyXG4gIF9kZWxldGVGaWx0ZXIoaWQpIHtcclxuICAgIGxldCB0b0RlbGV0ZTtcclxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX2lkcykuZm9yRWFjaCgoW3NpZ25hdHVyZSwgdGhlSURdKSA9PiB7XHJcbiAgICAgIGlmICh0aGVJRCA9PT0gaWQpIHtcclxuICAgICAgICB0b0RlbGV0ZSA9IHNpZ25hdHVyZTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLl9pZHNbdG9EZWxldGVdO1xyXG4gICAgZGVsZXRlIHRoaXMuX2JpbmRpbmdzW2lkXTtcclxuICAgIHRoaXMuX2RlZnMuc2VsZWN0KCcjJyArIGlkKS5yZW1vdmUoKTtcclxuICB9XHJcblxyXG4gIGhhc0ZpbHRlcihzaWduYXR1cmUpIHtcclxuICAgIHJldHVybiAhIXRoaXMuX2lkc1tzaWduYXR1cmVdO1xyXG4gICAgLy8gcmV0dXJuICF0aGlzLl9kZWZzLnNlbGVjdCgnIycgKyBzaWduYXR1cmUpLmVtcHR5KCk7XHJcbiAgfVxyXG5cclxuICBzaWduYXR1cmUoLi4uYXJncykge1xyXG4gICAgLy8gWyduYW1lJywgYXJnLCAnbmFtZTInLCBhcmddXHJcbiAgICAvLyBbJycsIF1cclxuICAgIHJldHVybiAoXHJcbiAgICAgICdGXycgK1xyXG4gICAgICBhcmdzXHJcbiAgICAgICAgLm1hcCgoYXJnLCBpKSA9PiAoaSAlIDIgPT09IDAgPyAnJyA6IExpYi5zaWduYXR1cmUoYXJnc1tpIC0gMV0sIGFyZykpKVxyXG4gICAgICAgIC5maWx0ZXIodiA9PiB2ICE9PSAnJylcclxuICAgICAgICAuam9pbignXycpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGZpbHRlciBmcm9tIHRoZSBsaXN0IG9mIGZpbHRlcnMgaW4gdGhlIGZvcm1hdFxyXG4gICAqIChmaWx0ZXItbmFtZS0xLCBhcmdzMSwgZmlsdGVyLW5hbWUtMiwgYXJnczIsIC4uLiAsIGZpbHRlci1uYW1lLU4sIGFyZ3NOKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBhcmdzXHJcbiAgICogQG1lbWJlcm9mIFNWR0ZpbHRlck1hbmFnZXJcclxuICAgKi9cclxuICBjcmVhdGVGaWx0ZXIoLi4uYXJncykge1xyXG4gICAgLy8gMS4gQ29tcHV0ZSBzaWduYXR1cmUgYW5kIHNlZSBpZiBpdCBhbHJlYWR5IGV4aXN0c1xyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5zaWduYXR1cmUoLi4uYXJncyk7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzRmlsdGVyKHNpZ25hdHVyZSkpIHJldHVybiB0aGlzLmdldEZpbHRlcklEKHNpZ25hdHVyZSk7XHJcblxyXG4gICAgY29uc3QgdGhlSUQgPSAodGhpcy5faWRzW3NpZ25hdHVyZV0gPSBTVkdGaWx0ZXJNYW5hZ2VyLl9nZW5JRCgpKTtcclxuICAgIHRoaXMuX2JpbmRpbmdzW3RoZUlEXSA9IFtdO1xyXG5cclxuICAgIGNvbnN0IGZpbHRlckVudHJ5ID0gdGhpcy5fZGVmc1xyXG4gICAgICAuYXBwZW5kKCdmaWx0ZXInKVxyXG4gICAgICAuYXR0cignaWQnLCB0aGVJRClcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsICczMDAlJylcclxuICAgICAgLmF0dHIoJ3dpZHRoJywgJzMwMCUnKVxyXG4gICAgICAuYXR0cigneCcsICctMTAwJScpXHJcbiAgICAgIC5hdHRyKCd5JywgJy0xMDAlJyk7XHJcblxyXG4gICAgZmlsdGVyRW50cnkubm9kZSgpLl9fZmlsdGVyc19fID0gW107XHJcblxyXG4gICAgYXJncy5mb3JFYWNoKChhcmcsIGkpID0+IHtcclxuICAgICAgaWYgKGkgJSAyID09PSAwKSByZXR1cm4gTGliLmdlbmVyYXRlKGZpbHRlckVudHJ5LCBhcmcsIGFyZ3NbaSArIDFdKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGVJRDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZ2VuSUQoKSB7XHJcbiAgICBpZiAoIXRoaXMuX19pZGNfXykgdGhpcy5fX2lkY19fID0gMDtcclxuICAgIHJldHVybiBgRklMVEVSXyR7dGhpcy5fX2lkY19fKyt9YDtcclxuICB9XHJcblxyXG4gIC8vIF9nZW5JRCgpIHtcclxuICAvLyB9XHJcblxyXG4gIGdldEZpbHRlcklEKHNpZ25hdHVyZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lkc1tzaWduYXR1cmVdO1xyXG4gIH1cclxufVxyXG5cclxuZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5zdmdGaWx0ZXIgPSBmdW5jdGlvbiguLi5maWx0ZXJzKSB7XHJcbiAgLy8gbmFtZSwgYXJncywgbmFtZTEsIGFyZ3MxLCAuLi4gLG5hbWVOLCBhcmdzTlxyXG4gIC8vIElmIG5vIGRlZnMgZW50cnksIGdlbmVyYXRlIG9uZSBhdCB0aGUgcm9vdCBhbmQgc2V0IGl0IEAgdGhlIHN2ZyBmaWx0ZXIgbWFuYWdlclxyXG4gIC8vIGNyZWF0ZSBhIG5ldyBzdmcgZmlsdGVyIG1hbmFnZXIgZm9yIHRoYXQgc3ZnXHJcblxyXG4gIC8vIDEuIEZpbmQgdG9wbW9zdCBTVkdcclxuICAvLyBsZXQgc3ZnID0gZDMuc2VsZWN0KHRoaXMubm9kZSgpLmZhcnRoZXN0Vmlld3BvcnRFbGVtZW50IHx8IHRoaXMubm9kZSgpLmNsb3Nlc3QoJ3N2ZycpKTtcclxuXHJcbiAgLy8gLy8gMi4gRW5zdXJlIHRoZSBkZWZzIGVudHJ5IGV4aXN0c1xyXG4gIC8vIGxldCBkZWZzID0gc3ZnLnNlbGVjdCgnOnNjb3BlPmRlZnMuc3ZnLWN1c3RvbS1maWx0ZXJzJyk7XHJcbiAgLy8gaWYgKGRlZnMuZW1wdHkoKSkge1xyXG4gIC8vICAgICBkZWZzID0gc3ZnLmFwcGVuZCgnZGVmcycpLmF0dHIoJ2NsYXNzJywgJ3N2Zy1jdXN0b20tZmlsdGVycycpO1xyXG4gIC8vICAgICBkZWZzLm5vZGUoKS5fc3ZnRmlsdGVyTWFuYWdlciA9IG5ldyBTVkdGaWx0ZXJNYW5hZ2VyKGRlZnMpO1xyXG4gIC8vIH1cclxuXHJcbiAgY29uc3QgZGVmcyA9IHRoaXMuc3ZnRmlsdGVyRGVmcygpO1xyXG5cclxuICBjb25zdCBmaWx0ZXJNYW5hZ2VyID0gZGVmcy5ub2RlKCkuX3N2Z0ZpbHRlck1hbmFnZXI7XHJcbiAgY29uc3QgZmlsdGVySUQgPSBmaWx0ZXJNYW5hZ2VyLmNyZWF0ZUZpbHRlciguLi5maWx0ZXJzKTtcclxuXHJcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuICAgIGNvbnN0IHNlbCA9IGQzLnNlbGVjdCh0aGlzKTtcclxuICAgIGlmIChmaWx0ZXJJRCA9PT0gc2VsLmdldEZpbHRlcklEKCkpIHJldHVybjtcclxuICAgIHNlbC5jbGVhckZpbHRlcigpO1xyXG5cclxuICAgIHNlbC5hdHRyKCdmaWx0ZXInLCBgdXJsKCMke2ZpbHRlcklEfSlgKTtcclxuICAgIGZpbHRlck1hbmFnZXIuX2JpbmQoc2VsLCBmaWx0ZXJJRCk7XHJcbiAgfSk7XHJcblxyXG4gIC8vIDMuIEdlbmVyYXRlIGEgZmlsdGVyIG1hbmFnZXIgaWYgbm90IGV4aXN0aW5nXHJcblxyXG4gIC8vIFRoZUZpbHRlck1hbmFnZXIuX2RlZnM7XHJcbiAgLy8gY29uc3QgaWRzID0gR2VuU1ZHRmlsdGVycyhmaWx0ZXJzKTtcclxufTtcclxuXHJcbmQzLnNlbGVjdGlvbi5wcm90b3R5cGUuc3ZnRmlsdGVyRGVmcyA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIDEuIEZpbmQgdG9wbW9zdCBTVkdcclxuICBsZXQgc3ZnID0gZDMuc2VsZWN0KFxyXG4gICAgdGhpcy5ub2RlKCkuZmFydGhlc3RWaWV3cG9ydEVsZW1lbnQgfHwgdGhpcy5ub2RlKCkuY2xvc2VzdCgnc3ZnJylcclxuICApO1xyXG5cclxuICAvLyAyLiBFbnN1cmUgdGhlIGRlZnMgZW50cnkgZXhpc3RzXHJcbiAgbGV0IGRlZnMgPSBzdmcuc2VsZWN0KCc6c2NvcGU+ZGVmcy5zdmctY3VzdG9tLWZpbHRlcnMnKTtcclxuICBpZiAoZGVmcy5lbXB0eSgpKSB7XHJcbiAgICBkZWZzID0gc3ZnLmFwcGVuZCgnZGVmcycpLmF0dHIoJ2NsYXNzJywgJ3N2Zy1jdXN0b20tZmlsdGVycycpO1xyXG4gICAgZGVmcy5ub2RlKCkuX3N2Z0ZpbHRlck1hbmFnZXIgPSBuZXcgU1ZHRmlsdGVyTWFuYWdlcihkZWZzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkZWZzO1xyXG59O1xyXG5cclxuZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5nZXRGaWx0ZXJJRCA9IGZ1bmN0aW9uKCkge1xyXG4gIGNvbnN0IGZpbHRlckF0dHIgPSB0aGlzLmF0dHIoJ2ZpbHRlcicpO1xyXG5cclxuICBsZXQgZmlsdGVySUQ7XHJcbiAgaWYgKCEhZmlsdGVyQXR0cikgZmlsdGVySUQgPSAvXFwoXFwjKC4rKVxcKS8uZXhlYyhmaWx0ZXJBdHRyKVsxXTtcclxuXHJcbiAgcmV0dXJuIGZpbHRlcklEO1xyXG59O1xyXG5cclxuZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5jbGVhckZpbHRlciA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcbiAgICBjb25zdCBzZWwgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICBjb25zdCBmaWx0ZXJJRCA9IHNlbC5nZXRGaWx0ZXJJRCgpO1xyXG4gICAgaWYgKCFmaWx0ZXJJRCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGRlZnMgPSBzZWwuc3ZnRmlsdGVyRGVmcygpO1xyXG4gICAgY29uc3QgZmlsdGVyTWFuYWdlciA9IGRlZnMubm9kZSgpLl9zdmdGaWx0ZXJNYW5hZ2VyO1xyXG5cclxuICAgIHNlbC5hdHRyKCdmaWx0ZXInLCBudWxsKTtcclxuICAgIGZpbHRlck1hbmFnZXIuX3VuYmluZChzZWwsIGZpbHRlcklEKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5kMy5zdmdGaWx0ZXJMaWIgPSBMaWI7XHJcblxyXG4vLyBjb25zdCBvcmlnaW5hbFJlbW92ZSA9IGQzLnNlbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlO1xyXG4vLyBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHsgLy8gQWRkIGluIGNsZWFyIGZpbHRlciB0byByZW1vdmUgZm4hXHJcbi8vICAgICB0aGlzLnNlbGVjdEFsbCgnKicpLmNsZWFyRmlsdGVyKCk7XHJcbi8vICAgICBvcmlnaW5hbFJlbW92ZS5jYWxsKHRoaXMsIC4uLmFyZ3VtZW50cyk7XHJcbi8vIH1cclxuXHJcbi8vIGQzLnN2Z0ZpbHRlciA9IChuYW1lLCBhcmdzKSA9PiBsaWIuZmlsdGVyKG5hbWUpKGFyZ3MpO1xyXG5cclxuLy8gRXhhbXBsZSB1c2FnZVxyXG5jb25zdCBzZWxlY3Rpb24gPSB7fTtcclxuXHJcbi8vIHNlbGVjdGlvblxyXG4vLyAgICAgLnN2Z0ZpbHRlcihcclxuLy8gICAgICAgICBkMy5zdmdGaWx0ZXJCb3hTaGFkb3coe1xyXG4vLyAgICAgICAgICAgICBkeDogJzUlJyxcclxuLy8gICAgICAgICAgICAgZHk6ICc1JScsXHJcbi8vICAgICAgICAgICAgIGJsdXI6ICcyNSUnXHJcbi8vICAgICAgICAgfSksXHJcbi8vICAgICAgICAgZDMuc3ZnRmlsdGVyQm94U2hhZG93SW5zZXQoe1xyXG4vLyAgICAgICAgICAgICBkeDogJzUlJyxcclxuLy8gICAgICAgICAgICAgZHk6ICc1JScsXHJcbi8vICAgICAgICAgICAgIGJsdXI6ICcyNSUnXHJcbi8vICAgICAgICAgfSlcclxuLy8gICAgICk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/d3svgfilters/src/d3-svg-filters.js\n"
          );

          /***/
        },

      /***/ './node_modules/css-loader/dist/cjs.js!./css/SplitStream.css':
        /*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css ***!
  \*******************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);\n// Module\nexports.push([module.i, "", ""]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9jc3MvU3BsaXRTdHJlYW0uY3NzPzUxYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMscUdBQWdEO0FBQ25GO0FBQ0EsY0FBYyxRQUFTIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9jc3MvU3BsaXRTdHJlYW0uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css\n'
          );

          /***/
        },

      /***/ './node_modules/css-loader/dist/runtime/api.js':
        /*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            '\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], "{").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwie1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW19pXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCIoXCIuY29uY2F0KGl0ZW1bMl0sIFwiKSBhbmQgKFwiKS5jb25jYXQobWVkaWFRdWVyeSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n'
          );

          /***/
        },

      /***/ './node_modules/flatted/esm/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/flatted/esm/index.js ***!
  \*******************************************/
        /*! exports provided: default, parse, stringify */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\nvar Flatted = (function (Primitive, primitive) {\n\n  /*!\n   * ISC License\n   *\n   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection\n   *\n   * Permission to use, copy, modify, and/or distribute this software for any\n   * purpose with or without fee is hereby granted, provided that the above\n   * copyright notice and this permission notice appear in all copies.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n   * PERFORMANCE OF THIS SOFTWARE.\n   */\n\n  var Flatted = {\n\n    parse: function parse(text, reviver) {\n      var input = JSON.parse(text, Primitives).map(primitives);\n      var value = input[0];\n      var $ = reviver || noop;\n      var tmp = typeof value === 'object' && value ?\n                  revive(input, new Set, value, $) :\n                  value;\n      return $.call({'': tmp}, '', tmp);\n    },\n\n    stringify: function stringify(value, replacer, space) {\n      for (var\n        firstRun,\n        known = new Map,\n        input = [],\n        output = [],\n        $ = replacer && typeof replacer === typeof input ?\n              function (k, v) {\n                if (k === '' || -1 < replacer.indexOf(k)) return v;\n              } :\n              (replacer || noop),\n        i = +set(known, input, $.call({'': value}, '', value)),\n        replace = function (key, value) {\n          if (firstRun) {\n            firstRun = !firstRun;\n            return value;\n            // this was invoking twice each root object\n            // return i < 1 ? value : $.call(this, key, value);\n          }\n          var after = $.call(this, key, value);\n          switch (typeof after) {\n            case 'object':\n              if (after === null) return after;\n            case primitive:\n              return known.get(after) || set(known, input, after);\n          }\n          return after;\n        };\n        i < input.length; i++\n      ) {\n        firstRun = true;\n        output[i] = JSON.stringify(input[i], replace, space);\n      }\n      return '[' + output.join(',') + ']';\n    }\n\n  };\n\n  return Flatted;\n\n  function noop(key, value) {\n    return value;\n  }\n\n  function revive(input, parsed, output, $) {\n    return Object.keys(output).reduce(\n      function (output, key) {\n        var value = output[key];\n        if (value instanceof Primitive) {\n          var tmp = input[value];\n          if (typeof tmp === 'object' && !parsed.has(tmp)) {\n            parsed.add(tmp);\n            output[key] = $.call(output, key, revive(input, parsed, tmp, $));\n          } else {\n            output[key] = $.call(output, key, tmp);\n          }\n        } else\n          output[key] = $.call(output, key, value);\n        return output;\n      },\n      output\n    );\n  }\n\n  function set(known, input, value) {\n    var index = Primitive(input.push(value) - 1);\n    known.set(value, index);\n    return index;\n  }\n\n  // the two kinds of primitives\n  //  1. the real one\n  //  2. the wrapped one\n\n  function primitives(value) {\n    return value instanceof Primitive ? Primitive(value) : value;\n  }\n\n  function Primitives(key, value) {\n    return typeof value === primitive ? new Primitive(value) : value;\n  }\n\n}(String, 'string'));\n/* harmony default export */ __webpack_exports__[\"default\"] = (Flatted);\nvar parse = Flatted.parse;\nvar stringify = Flatted.stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvZmxhdHRlZC9lc20vaW5kZXguanM/NWJjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNjLHNFQUFPLEVBQUM7QUFDaEI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9mbGF0dGVkL2VzbS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBGbGF0dGVkID0gKGZ1bmN0aW9uIChQcmltaXRpdmUsIHByaW1pdGl2ZSkge1xuXG4gIC8qIVxuICAgKiBJU0MgTGljZW5zZVxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTgsIEFuZHJlYSBHaWFtbWFyY2hpLCBAV2ViUmVmbGVjdGlvblxuICAgKlxuICAgKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAgICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICAgKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICAgKlxuICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG4gICAqIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuICAgKiBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG4gICAqIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuICAgKiBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRVxuICAgKiBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG4gICAqIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gICAqL1xuXG4gIHZhciBGbGF0dGVkID0ge1xuXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRleHQsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnB1dCA9IEpTT04ucGFyc2UodGV4dCwgUHJpbWl0aXZlcykubWFwKHByaW1pdGl2ZXMpO1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbMF07XG4gICAgICB2YXIgJCA9IHJldml2ZXIgfHwgbm9vcDtcbiAgICAgIHZhciB0bXAgPSB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlID9cbiAgICAgICAgICAgICAgICAgIHJldml2ZShpbnB1dCwgbmV3IFNldCwgdmFsdWUsICQpIDpcbiAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgcmV0dXJuICQuY2FsbCh7Jyc6IHRtcH0sICcnLCB0bXApO1xuICAgIH0sXG5cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICBmb3IgKHZhclxuICAgICAgICBmaXJzdFJ1bixcbiAgICAgICAga25vd24gPSBuZXcgTWFwLFxuICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICBvdXRwdXQgPSBbXSxcbiAgICAgICAgJCA9IHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciA9PT0gdHlwZW9mIGlucHV0ID9cbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJycgfHwgLTEgPCByZXBsYWNlci5pbmRleE9mKGspKSByZXR1cm4gdjtcbiAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgIChyZXBsYWNlciB8fCBub29wKSxcbiAgICAgICAgaSA9ICtzZXQoa25vd24sIGlucHV0LCAkLmNhbGwoeycnOiB2YWx1ZX0sICcnLCB2YWx1ZSkpLFxuICAgICAgICByZXBsYWNlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoZmlyc3RSdW4pIHtcbiAgICAgICAgICAgIGZpcnN0UnVuID0gIWZpcnN0UnVuO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy8gdGhpcyB3YXMgaW52b2tpbmcgdHdpY2UgZWFjaCByb290IG9iamVjdFxuICAgICAgICAgICAgLy8gcmV0dXJuIGkgPCAxID8gdmFsdWUgOiAkLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhZnRlciA9ICQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhZnRlcikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgaWYgKGFmdGVyID09PSBudWxsKSByZXR1cm4gYWZ0ZXI7XG4gICAgICAgICAgICBjYXNlIHByaW1pdGl2ZTpcbiAgICAgICAgICAgICAgcmV0dXJuIGtub3duLmdldChhZnRlcikgfHwgc2V0KGtub3duLCBpbnB1dCwgYWZ0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGkgPCBpbnB1dC5sZW5ndGg7IGkrK1xuICAgICAgKSB7XG4gICAgICAgIGZpcnN0UnVuID0gdHJ1ZTtcbiAgICAgICAgb3V0cHV0W2ldID0gSlNPTi5zdHJpbmdpZnkoaW5wdXRbaV0sIHJlcGxhY2UsIHNwYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnWycgKyBvdXRwdXQuam9pbignLCcpICsgJ10nO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBGbGF0dGVkO1xuXG4gIGZ1bmN0aW9uIG5vb3Aoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldml2ZShpbnB1dCwgcGFyc2VkLCBvdXRwdXQsICQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3V0cHV0KS5yZWR1Y2UoXG4gICAgICBmdW5jdGlvbiAob3V0cHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3V0cHV0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByaW1pdGl2ZSkge1xuICAgICAgICAgIHZhciB0bXAgPSBpbnB1dFt2YWx1ZV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB0bXAgPT09ICdvYmplY3QnICYmICFwYXJzZWQuaGFzKHRtcCkpIHtcbiAgICAgICAgICAgIHBhcnNlZC5hZGQodG1wKTtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gJC5jYWxsKG91dHB1dCwga2V5LCByZXZpdmUoaW5wdXQsIHBhcnNlZCwgdG1wLCAkKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gJC5jYWxsKG91dHB1dCwga2V5LCB0bXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgb3V0cHV0W2tleV0gPSAkLmNhbGwob3V0cHV0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0sXG4gICAgICBvdXRwdXRcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KGtub3duLCBpbnB1dCwgdmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSBQcmltaXRpdmUoaW5wdXQucHVzaCh2YWx1ZSkgLSAxKTtcbiAgICBrbm93bi5zZXQodmFsdWUsIGluZGV4KTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvLyB0aGUgdHdvIGtpbmRzIG9mIHByaW1pdGl2ZXNcbiAgLy8gIDEuIHRoZSByZWFsIG9uZVxuICAvLyAgMi4gdGhlIHdyYXBwZWQgb25lXG5cbiAgZnVuY3Rpb24gcHJpbWl0aXZlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFByaW1pdGl2ZSA/IFByaW1pdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByaW1pdGl2ZXMoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHByaW1pdGl2ZSA/IG5ldyBQcmltaXRpdmUodmFsdWUpIDogdmFsdWU7XG4gIH1cblxufShTdHJpbmcsICdzdHJpbmcnKSk7XG5leHBvcnQgZGVmYXVsdCBGbGF0dGVkO1xuZXhwb3J0IHZhciBwYXJzZSA9IEZsYXR0ZWQucGFyc2U7XG5leHBvcnQgdmFyIHN0cmluZ2lmeSA9IEZsYXR0ZWQuc3RyaW5naWZ5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/flatted/esm/index.js\n"
          );

          /***/
        },

      /***/ './node_modules/save-svg-as-png/lib/saveSvgAsPng.js':
        /*!**********************************************************!*\
  !*** ./node_modules/save-svg-as-png/lib/saveSvgAsPng.js ***!
  \**********************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            "var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n(function () {\n  var out$ =  true && exports ||  true && {} || this || window;\n  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return out$;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  out$.default = out$;\n\n  var xmlNs = 'http://www.w3.org/2000/xmlns/';\n  var xhtmlNs = 'http://www.w3.org/1999/xhtml';\n  var svgNs = 'http://www.w3.org/2000/svg';\n  var doctype = '<?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [<!ENTITY nbsp \"&#160;\">]>';\n  var urlRegex = /url\\([\"']?(.+?)[\"']?\\)/;\n  var fontFormats = {\n    woff2: 'font/woff2',\n    woff: 'font/woff',\n    otf: 'application/x-font-opentype',\n    ttf: 'application/x-font-ttf',\n    eot: 'application/vnd.ms-fontobject',\n    sfnt: 'application/font-sfnt',\n    svg: 'image/svg+xml'\n  };\n\n  var isElement = function isElement(obj) {\n    return obj instanceof HTMLElement || obj instanceof SVGElement;\n  };\n  var requireDomNode = function requireDomNode(el) {\n    if (!isElement(el)) throw new Error('an HTMLElement or SVGElement is required; got ' + el);\n  };\n  var requireDomNodePromise = function requireDomNodePromise(el) {\n    return new Promise(function (resolve, reject) {\n      if (isElement(el)) resolve(el);else reject(new Error('an HTMLElement or SVGElement is required; got ' + el));\n    });\n  };\n  var isExternal = function isExternal(url) {\n    return url && url.lastIndexOf('http', 0) === 0 && url.lastIndexOf(window.location.host) === -1;\n  };\n\n  var getFontMimeTypeFromUrl = function getFontMimeTypeFromUrl(fontUrl) {\n    var formats = Object.keys(fontFormats).filter(function (extension) {\n      return fontUrl.indexOf('.' + extension) > 0;\n    }).map(function (extension) {\n      return fontFormats[extension];\n    });\n    if (formats) return formats[0];\n    console.error('Unknown font format for ' + fontUrl + '. Fonts may not be working correctly.');\n    return 'application/octet-stream';\n  };\n\n  var arrayBufferToBase64 = function arrayBufferToBase64(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }return window.btoa(binary);\n  };\n\n  var getDimension = function getDimension(el, clone, dim) {\n    var v = el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim] || clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim)) || el.getBoundingClientRect()[dim] || parseInt(clone.style[dim]) || parseInt(window.getComputedStyle(el).getPropertyValue(dim));\n    return typeof v === 'undefined' || v === null || isNaN(parseFloat(v)) ? 0 : v;\n  };\n\n  var getDimensions = function getDimensions(el, clone, width, height) {\n    if (el.tagName === 'svg') return {\n      width: width || getDimension(el, clone, 'width'),\n      height: height || getDimension(el, clone, 'height')\n    };else if (el.getBBox) {\n      var _el$getBBox = el.getBBox(),\n          x = _el$getBBox.x,\n          y = _el$getBBox.y,\n          _width = _el$getBBox.width,\n          _height = _el$getBBox.height;\n\n      return {\n        width: x + _width,\n        height: y + _height\n      };\n    }\n  };\n\n  var reEncode = function reEncode(data) {\n    return decodeURIComponent(encodeURIComponent(data).replace(/%([0-9A-F]{2})/g, function (match, p1) {\n      var c = String.fromCharCode('0x' + p1);\n      return c === '%' ? '%25' : c;\n    }));\n  };\n\n  var uriToBlob = function uriToBlob(uri) {\n    var byteString = window.atob(uri.split(',')[1]);\n    var mimeString = uri.split(',')[0].split(':')[1].split(';')[0];\n    var buffer = new ArrayBuffer(byteString.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < byteString.length; i++) {\n      intArray[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([buffer], { type: mimeString });\n  };\n\n  var query = function query(el, selector) {\n    if (!selector) return;\n    try {\n      return el.querySelector(selector) || el.parentNode && el.parentNode.querySelector(selector);\n    } catch (err) {\n      console.warn('Invalid CSS selector \"' + selector + '\"', err);\n    }\n  };\n\n  var detectCssFont = function detectCssFont(rule, href) {\n    // Match CSS font-face rules to external links.\n    // @font-face {\n    //   src: local('Abel'), url(https://fonts.gstatic.com/s/abel/v6/UzN-iejR1VoXU2Oc-7LsbvesZW2xOQ-xsNqO47m55DA.woff2);\n    // }\n    var match = rule.cssText.match(urlRegex);\n    var url = match && match[1] || '';\n    if (!url || url.match(/^data:/) || url === 'about:blank') return;\n    var fullUrl = url.startsWith('../') ? href + '/../' + url : url.startsWith('./') ? href + '/.' + url : url;\n    return {\n      text: rule.cssText,\n      format: getFontMimeTypeFromUrl(fullUrl),\n      url: fullUrl\n    };\n  };\n\n  var inlineImages = function inlineImages(el) {\n    return Promise.all(Array.from(el.querySelectorAll('image')).map(function (image) {\n      var href = image.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || image.getAttribute('href');\n      if (!href) return Promise.resolve(null);\n      if (isExternal(href)) {\n        href += (href.indexOf('?') === -1 ? '?' : '&') + 't=' + new Date().valueOf();\n      }\n      return new Promise(function (resolve, reject) {\n        var canvas = document.createElement('canvas');\n        var img = new Image();\n        img.crossOrigin = 'anonymous';\n        img.src = href;\n        img.onerror = function () {\n          return reject(new Error('Could not load ' + href));\n        };\n        img.onload = function () {\n          canvas.width = img.width;\n          canvas.height = img.height;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', canvas.toDataURL('image/png'));\n          resolve(true);\n        };\n      });\n    }));\n  };\n\n  var cachedFonts = {};\n  var inlineFonts = function inlineFonts(fonts) {\n    return Promise.all(fonts.map(function (font) {\n      return new Promise(function (resolve, reject) {\n        if (cachedFonts[font.url]) return resolve(cachedFonts[font.url]);\n\n        var req = new XMLHttpRequest();\n        req.addEventListener('load', function () {\n          // TODO: it may also be worth it to wait until fonts are fully loaded before\n          // attempting to rasterize them. (e.g. use https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet)\n          var fontInBase64 = arrayBufferToBase64(req.response);\n          var fontUri = font.text.replace(urlRegex, 'url(\"data:' + font.format + ';base64,' + fontInBase64 + '\")') + '\\n';\n          cachedFonts[font.url] = fontUri;\n          resolve(fontUri);\n        });\n        req.addEventListener('error', function (e) {\n          console.warn('Failed to load font from: ' + font.url, e);\n          cachedFonts[font.url] = null;\n          resolve(null);\n        });\n        req.addEventListener('abort', function (e) {\n          console.warn('Aborted loading font from: ' + font.url, e);\n          resolve(null);\n        });\n        req.open('GET', font.url);\n        req.responseType = 'arraybuffer';\n        req.send();\n      });\n    })).then(function (fontCss) {\n      return fontCss.filter(function (x) {\n        return x;\n      }).join('');\n    });\n  };\n\n  var cachedRules = null;\n  var styleSheetRules = function styleSheetRules() {\n    if (cachedRules) return cachedRules;\n    return cachedRules = Array.from(document.styleSheets).map(function (sheet) {\n      try {\n        return { rules: sheet.cssRules, href: sheet.href };\n      } catch (e) {\n        console.warn('Stylesheet could not be loaded: ' + sheet.href, e);\n        return {};\n      }\n    });\n  };\n\n  var inlineCss = function inlineCss(el, options) {\n    var _ref = options || {},\n        selectorRemap = _ref.selectorRemap,\n        modifyStyle = _ref.modifyStyle,\n        modifyCss = _ref.modifyCss,\n        fonts = _ref.fonts;\n\n    var generateCss = modifyCss || function (selector, properties) {\n      var sel = selectorRemap ? selectorRemap(selector) : selector;\n      var props = modifyStyle ? modifyStyle(properties) : properties;\n      return sel + '{' + props + '}\\n';\n    };\n    var css = [];\n    var detectFonts = typeof fonts === 'undefined';\n    var fontList = fonts || [];\n    styleSheetRules().forEach(function (_ref2) {\n      var rules = _ref2.rules,\n          href = _ref2.href;\n\n      if (!rules) return;\n      Array.from(rules).forEach(function (rule) {\n        if (typeof rule.style != 'undefined') {\n          if (query(el, rule.selectorText)) css.push(generateCss(rule.selectorText, rule.style.cssText));else if (detectFonts && rule.cssText.match(/^@font-face/)) {\n            var font = detectCssFont(rule, href);\n            if (font) fontList.push(font);\n          } else css.push(rule.cssText);\n        }\n      });\n    });\n\n    return inlineFonts(fontList).then(function (fontCss) {\n      return css.join('\\n') + fontCss;\n    });\n  };\n\n  var downloadOptions = function downloadOptions() {\n    if (!navigator.msSaveOrOpenBlob && !('download' in document.createElement('a'))) {\n      return { popup: window.open() };\n    }\n  };\n\n  out$.prepareSvg = function (el, options, done) {\n    requireDomNode(el);\n\n    var _ref3 = options || {},\n        _ref3$left = _ref3.left,\n        left = _ref3$left === undefined ? 0 : _ref3$left,\n        _ref3$top = _ref3.top,\n        top = _ref3$top === undefined ? 0 : _ref3$top,\n        w = _ref3.width,\n        h = _ref3.height,\n        _ref3$scale = _ref3.scale,\n        scale = _ref3$scale === undefined ? 1 : _ref3$scale,\n        _ref3$responsive = _ref3.responsive,\n        responsive = _ref3$responsive === undefined ? false : _ref3$responsive;\n\n    return inlineImages(el).then(function () {\n      var clone = el.cloneNode(true);\n      clone.style.backgroundColor = (options || {}).backgroundColor || el.style.backgroundColor;\n\n      var _getDimensions = getDimensions(el, clone, w, h),\n          width = _getDimensions.width,\n          height = _getDimensions.height;\n\n      if (el.tagName !== 'svg') {\n        if (el.getBBox) {\n          if (clone.getAttribute('transform') != null) {\n            clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\\(.*?\\)/, ''));\n          }\n          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n          svg.appendChild(clone);\n          clone = svg;\n        } else {\n          console.error('Attempted to render non-SVG element', el);\n          return;\n        }\n      }\n\n      clone.setAttribute('version', '1.1');\n      clone.setAttribute('viewBox', [left, top, width, height].join(' '));\n      if (!clone.getAttribute('xmlns')) clone.setAttributeNS(xmlNs, 'xmlns', svgNs);\n      if (!clone.getAttribute('xmlns:xlink')) clone.setAttributeNS(xmlNs, 'xmlns:xlink', 'http://www.w3.org/1999/xlink');\n\n      if (responsive) {\n        clone.removeAttribute('width');\n        clone.removeAttribute('height');\n        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n      } else {\n        clone.setAttribute('width', width * scale);\n        clone.setAttribute('height', height * scale);\n      }\n\n      Array.from(clone.querySelectorAll('foreignObject > *')).forEach(function (foreignObject) {\n        foreignObject.setAttributeNS(xmlNs, 'xmlns', foreignObject.tagName === 'svg' ? svgNs : xhtmlNs);\n      });\n\n      return inlineCss(el, options).then(function (css) {\n        var style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.innerHTML = '<![CDATA[\\n' + css + '\\n]]>';\n\n        var defs = document.createElement('defs');\n        defs.appendChild(style);\n        clone.insertBefore(defs, clone.firstChild);\n\n        var outer = document.createElement('div');\n        outer.appendChild(clone);\n        var src = outer.innerHTML.replace(/NS\\d+:href/gi, 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href');\n\n        if (typeof done === 'function') done(src, width, height);else return { src: src, width: width, height: height };\n      });\n    });\n  };\n\n  out$.svgAsDataUri = function (el, options, done) {\n    requireDomNode(el);\n    return out$.prepareSvg(el, options).then(function (_ref4) {\n      var src = _ref4.src,\n          width = _ref4.width,\n          height = _ref4.height;\n\n      var svgXml = 'data:image/svg+xml;base64,' + window.btoa(reEncode(doctype + src));\n      if (typeof done === 'function') {\n        done(svgXml, width, height);\n      }\n      return svgXml;\n    });\n  };\n\n  out$.svgAsPngUri = function (el, options, done) {\n    requireDomNode(el);\n\n    var _ref5 = options || {},\n        _ref5$encoderType = _ref5.encoderType,\n        encoderType = _ref5$encoderType === undefined ? 'image/png' : _ref5$encoderType,\n        _ref5$encoderOptions = _ref5.encoderOptions,\n        encoderOptions = _ref5$encoderOptions === undefined ? 0.8 : _ref5$encoderOptions,\n        canvg = _ref5.canvg;\n\n    var convertToPng = function convertToPng(_ref6) {\n      var src = _ref6.src,\n          width = _ref6.width,\n          height = _ref6.height;\n\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      var pixelRatio = window.devicePixelRatio || 1;\n\n      canvas.width = width * pixelRatio;\n      canvas.height = height * pixelRatio;\n      canvas.style.width = canvas.width + 'px';\n      canvas.style.height = canvas.height + 'px';\n      context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n      if (canvg) canvg(canvas, src);else context.drawImage(src, 0, 0);\n\n      var png = void 0;\n      try {\n        png = canvas.toDataURL(encoderType, encoderOptions);\n      } catch (e) {\n        if (typeof SecurityError !== 'undefined' && e instanceof SecurityError || e.name === 'SecurityError') {\n          console.error('Rendered SVG images cannot be downloaded in this browser.');\n          return;\n        } else throw e;\n      }\n      if (typeof done === 'function') done(png, canvas.width, canvas.height);\n      return Promise.resolve(png);\n    };\n\n    if (canvg) return out$.prepareSvg(el, options).then(convertToPng);else return out$.svgAsDataUri(el, options).then(function (uri) {\n      return new Promise(function (resolve, reject) {\n        var image = new Image();\n        image.onload = function () {\n          return resolve(convertToPng({\n            src: image,\n            width: image.width,\n            height: image.height\n          }));\n        };\n        image.onerror = function () {\n          reject('There was an error loading the data URI as an image on the following SVG\\n' + window.atob(uri.slice(26)) + 'Open the following link to see browser\\'s diagnosis\\n' + uri);\n        };\n        image.src = uri;\n      });\n    });\n  };\n\n  out$.download = function (name, uri, options) {\n    if (navigator.msSaveOrOpenBlob) navigator.msSaveOrOpenBlob(uriToBlob(uri), name);else {\n      var saveLink = document.createElement('a');\n      if ('download' in saveLink) {\n        saveLink.download = name;\n        saveLink.style.display = 'none';\n        document.body.appendChild(saveLink);\n        try {\n          var blob = uriToBlob(uri);\n          var url = URL.createObjectURL(blob);\n          saveLink.href = url;\n          saveLink.onclick = function () {\n            return requestAnimationFrame(function () {\n              return URL.revokeObjectURL(url);\n            });\n          };\n        } catch (e) {\n          console.error(e);\n          console.warn('Error while getting object URL. Falling back to string URL.');\n          saveLink.href = uri;\n        }\n        saveLink.click();\n        document.body.removeChild(saveLink);\n      } else if (options && options.popup) {\n        options.popup.document.title = name;\n        options.popup.location.replace(uri);\n      }\n    }\n  };\n\n  out$.saveSvg = function (el, name, options) {\n    var downloadOpts = downloadOptions(); // don't inline, can't be async\n    return requireDomNodePromise(el).then(function (el) {\n      return out$.svgAsDataUri(el, options || {});\n    }).then(function (uri) {\n      return out$.download(name, uri, downloadOpts);\n    });\n  };\n\n  out$.saveSvgAsPng = function (el, name, options) {\n    var downloadOpts = downloadOptions(); // don't inline, can't be async\n    return requireDomNodePromise(el).then(function (el) {\n      return out$.svgAsPngUri(el, options || {});\n    }).then(function (uri) {\n      return out$.download(name, uri, downloadOpts);\n    });\n  };\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvc2F2ZS1zdmctYXMtcG5nL2xpYi9zYXZlU3ZnQXNQbmcuanM/YmMwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnRUFBYTs7QUFFYjtBQUNBLGFBQWEsS0FBNkIsZUFBZSxLQUE0QixNQUFNO0FBQzNGLE1BQU0sSUFBNkIsRUFBRSxpQ0FBMEIsRUFBRSxtQ0FBRTtBQUNuRTtBQUNBLEdBQUc7QUFBQSxvR0FBQztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhLQUE4SztBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0VBQWdFO0FBQ3JHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxFQUFFO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUUsYUFBYTtBQUM5RSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGdEQUFnRDtBQUNoRCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSwrQ0FBK0M7QUFDL0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zYXZlLXN2Zy1hcy1wbmcvbGliL3NhdmVTdmdBc1BuZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYge30gfHwgdGhpcyB8fCB3aW5kb3c7XG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJykgZGVmaW5lKCdzYXZlLXN2Zy1hcy1wbmcnLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvdXQkO1xuICB9KTtcbiAgb3V0JC5kZWZhdWx0ID0gb3V0JDtcblxuICB2YXIgeG1sTnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuICB2YXIgeGh0bWxOcyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgdmFyIHN2Z05zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIGRvY3R5cGUgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIHN0YW5kYWxvbmU9XCJub1wiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIiBbPCFFTlRJVFkgbmJzcCBcIiYjMTYwO1wiPl0+JztcbiAgdmFyIHVybFJlZ2V4ID0gL3VybFxcKFtcIiddPyguKz8pW1wiJ10/XFwpLztcbiAgdmFyIGZvbnRGb3JtYXRzID0ge1xuICAgIHdvZmYyOiAnZm9udC93b2ZmMicsXG4gICAgd29mZjogJ2ZvbnQvd29mZicsXG4gICAgb3RmOiAnYXBwbGljYXRpb24veC1mb250LW9wZW50eXBlJyxcbiAgICB0dGY6ICdhcHBsaWNhdGlvbi94LWZvbnQtdHRmJyxcbiAgICBlb3Q6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgc2ZudDogJ2FwcGxpY2F0aW9uL2ZvbnQtc2ZudCcsXG4gICAgc3ZnOiAnaW1hZ2Uvc3ZnK3htbCdcbiAgfTtcblxuICB2YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBvYmogaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICB9O1xuICB2YXIgcmVxdWlyZURvbU5vZGUgPSBmdW5jdGlvbiByZXF1aXJlRG9tTm9kZShlbCkge1xuICAgIGlmICghaXNFbGVtZW50KGVsKSkgdGhyb3cgbmV3IEVycm9yKCdhbiBIVE1MRWxlbWVudCBvciBTVkdFbGVtZW50IGlzIHJlcXVpcmVkOyBnb3QgJyArIGVsKTtcbiAgfTtcbiAgdmFyIHJlcXVpcmVEb21Ob2RlUHJvbWlzZSA9IGZ1bmN0aW9uIHJlcXVpcmVEb21Ob2RlUHJvbWlzZShlbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsKSkgcmVzb2x2ZShlbCk7ZWxzZSByZWplY3QobmV3IEVycm9yKCdhbiBIVE1MRWxlbWVudCBvciBTVkdFbGVtZW50IGlzIHJlcXVpcmVkOyBnb3QgJyArIGVsKSk7XG4gICAgfSk7XG4gIH07XG4gIHZhciBpc0V4dGVybmFsID0gZnVuY3Rpb24gaXNFeHRlcm5hbCh1cmwpIHtcbiAgICByZXR1cm4gdXJsICYmIHVybC5sYXN0SW5kZXhPZignaHR0cCcsIDApID09PSAwICYmIHVybC5sYXN0SW5kZXhPZih3aW5kb3cubG9jYXRpb24uaG9zdCkgPT09IC0xO1xuICB9O1xuXG4gIHZhciBnZXRGb250TWltZVR5cGVGcm9tVXJsID0gZnVuY3Rpb24gZ2V0Rm9udE1pbWVUeXBlRnJvbVVybChmb250VXJsKSB7XG4gICAgdmFyIGZvcm1hdHMgPSBPYmplY3Qua2V5cyhmb250Rm9ybWF0cykuZmlsdGVyKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBmb250VXJsLmluZGV4T2YoJy4nICsgZXh0ZW5zaW9uKSA+IDA7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBmb250Rm9ybWF0c1tleHRlbnNpb25dO1xuICAgIH0pO1xuICAgIGlmIChmb3JtYXRzKSByZXR1cm4gZm9ybWF0c1swXTtcbiAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIGZvbnQgZm9ybWF0IGZvciAnICsgZm9udFVybCArICcuIEZvbnRzIG1heSBub3QgYmUgd29ya2luZyBjb3JyZWN0bHkuJyk7XG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICB9O1xuXG4gIHZhciBhcnJheUJ1ZmZlclRvQmFzZTY0ID0gZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICB2YXIgYmluYXJ5ID0gJyc7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1yZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbiAgfTtcblxuICB2YXIgZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uKGVsLCBjbG9uZSwgZGltKSB7XG4gICAgdmFyIHYgPSBlbC52aWV3Qm94ICYmIGVsLnZpZXdCb3guYmFzZVZhbCAmJiBlbC52aWV3Qm94LmJhc2VWYWxbZGltXSB8fCBjbG9uZS5nZXRBdHRyaWJ1dGUoZGltKSAhPT0gbnVsbCAmJiAhY2xvbmUuZ2V0QXR0cmlidXRlKGRpbSkubWF0Y2goLyUkLykgJiYgcGFyc2VJbnQoY2xvbmUuZ2V0QXR0cmlidXRlKGRpbSkpIHx8IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbV0gfHwgcGFyc2VJbnQoY2xvbmUuc3R5bGVbZGltXSkgfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoZGltKSk7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyB8fCB2ID09PSBudWxsIHx8IGlzTmFOKHBhcnNlRmxvYXQodikpID8gMCA6IHY7XG4gIH07XG5cbiAgdmFyIGdldERpbWVuc2lvbnMgPSBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsLCBjbG9uZSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmIChlbC50YWdOYW1lID09PSAnc3ZnJykgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCB8fCBnZXREaW1lbnNpb24oZWwsIGNsb25lLCAnd2lkdGgnKSxcbiAgICAgIGhlaWdodDogaGVpZ2h0IHx8IGdldERpbWVuc2lvbihlbCwgY2xvbmUsICdoZWlnaHQnKVxuICAgIH07ZWxzZSBpZiAoZWwuZ2V0QkJveCkge1xuICAgICAgdmFyIF9lbCRnZXRCQm94ID0gZWwuZ2V0QkJveCgpLFxuICAgICAgICAgIHggPSBfZWwkZ2V0QkJveC54LFxuICAgICAgICAgIHkgPSBfZWwkZ2V0QkJveC55LFxuICAgICAgICAgIF93aWR0aCA9IF9lbCRnZXRCQm94LndpZHRoLFxuICAgICAgICAgIF9oZWlnaHQgPSBfZWwkZ2V0QkJveC5oZWlnaHQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB4ICsgX3dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHkgKyBfaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVFbmNvZGUgPSBmdW5jdGlvbiByZUVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBwMSkge1xuICAgICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCcweCcgKyBwMSk7XG4gICAgICByZXR1cm4gYyA9PT0gJyUnID8gJyUyNScgOiBjO1xuICAgIH0pKTtcbiAgfTtcblxuICB2YXIgdXJpVG9CbG9iID0gZnVuY3Rpb24gdXJpVG9CbG9iKHVyaSkge1xuICAgIHZhciBieXRlU3RyaW5nID0gd2luZG93LmF0b2IodXJpLnNwbGl0KCcsJylbMV0pO1xuICAgIHZhciBtaW1lU3RyaW5nID0gdXJpLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRBcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6IG1pbWVTdHJpbmcgfSk7XG4gIH07XG5cbiAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgfHwgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIENTUyBzZWxlY3RvciBcIicgKyBzZWxlY3RvciArICdcIicsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZXRlY3RDc3NGb250ID0gZnVuY3Rpb24gZGV0ZWN0Q3NzRm9udChydWxlLCBocmVmKSB7XG4gICAgLy8gTWF0Y2ggQ1NTIGZvbnQtZmFjZSBydWxlcyB0byBleHRlcm5hbCBsaW5rcy5cbiAgICAvLyBAZm9udC1mYWNlIHtcbiAgICAvLyAgIHNyYzogbG9jYWwoJ0FiZWwnKSwgdXJsKGh0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb20vcy9hYmVsL3Y2L1V6Ti1pZWpSMVZvWFUyT2MtN0xzYnZlc1pXMnhPUS14c05xTzQ3bTU1REEud29mZjIpO1xuICAgIC8vIH1cbiAgICB2YXIgbWF0Y2ggPSBydWxlLmNzc1RleHQubWF0Y2godXJsUmVnZXgpO1xuICAgIHZhciB1cmwgPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICBpZiAoIXVybCB8fCB1cmwubWF0Y2goL15kYXRhOi8pIHx8IHVybCA9PT0gJ2Fib3V0OmJsYW5rJykgcmV0dXJuO1xuICAgIHZhciBmdWxsVXJsID0gdXJsLnN0YXJ0c1dpdGgoJy4uLycpID8gaHJlZiArICcvLi4vJyArIHVybCA6IHVybC5zdGFydHNXaXRoKCcuLycpID8gaHJlZiArICcvLicgKyB1cmwgOiB1cmw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHJ1bGUuY3NzVGV4dCxcbiAgICAgIGZvcm1hdDogZ2V0Rm9udE1pbWVUeXBlRnJvbVVybChmdWxsVXJsKSxcbiAgICAgIHVybDogZnVsbFVybFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGlubGluZUltYWdlcyA9IGZ1bmN0aW9uIGlubGluZUltYWdlcyhlbCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltYWdlJykpLm1hcChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHZhciBocmVmID0gaW1hZ2UuZ2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicpIHx8IGltYWdlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgaWYgKCFocmVmKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgaWYgKGlzRXh0ZXJuYWwoaHJlZikpIHtcbiAgICAgICAgaHJlZiArPSAoaHJlZi5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArICd0PScgKyBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgaW1nLnNyYyA9IGhyZWY7XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgaHJlZikpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH07XG5cbiAgdmFyIGNhY2hlZEZvbnRzID0ge307XG4gIHZhciBpbmxpbmVGb250cyA9IGZ1bmN0aW9uIGlubGluZUZvbnRzKGZvbnRzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZvbnRzLm1hcChmdW5jdGlvbiAoZm9udCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKGNhY2hlZEZvbnRzW2ZvbnQudXJsXSkgcmV0dXJuIHJlc29sdmUoY2FjaGVkRm9udHNbZm9udC51cmxdKTtcblxuICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRPRE86IGl0IG1heSBhbHNvIGJlIHdvcnRoIGl0IHRvIHdhaXQgdW50aWwgZm9udHMgYXJlIGZ1bGx5IGxvYWRlZCBiZWZvcmVcbiAgICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHJhc3Rlcml6ZSB0aGVtLiAoZS5nLiB1c2UgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZvbnRGYWNlU2V0KVxuICAgICAgICAgIHZhciBmb250SW5CYXNlNjQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGZvbnRVcmkgPSBmb250LnRleHQucmVwbGFjZSh1cmxSZWdleCwgJ3VybChcImRhdGE6JyArIGZvbnQuZm9ybWF0ICsgJztiYXNlNjQsJyArIGZvbnRJbkJhc2U2NCArICdcIiknKSArICdcXG4nO1xuICAgICAgICAgIGNhY2hlZEZvbnRzW2ZvbnQudXJsXSA9IGZvbnRVcmk7XG4gICAgICAgICAgcmVzb2x2ZShmb250VXJpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBmb250IGZyb206ICcgKyBmb250LnVybCwgZSk7XG4gICAgICAgICAgY2FjaGVkRm9udHNbZm9udC51cmxdID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Fib3J0ZWQgbG9hZGluZyBmb250IGZyb206ICcgKyBmb250LnVybCwgZSk7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vcGVuKCdHRVQnLCBmb250LnVybCk7XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgfSk7XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKGZvbnRDc3MpIHtcbiAgICAgIHJldHVybiBmb250Q3NzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjYWNoZWRSdWxlcyA9IG51bGw7XG4gIHZhciBzdHlsZVNoZWV0UnVsZXMgPSBmdW5jdGlvbiBzdHlsZVNoZWV0UnVsZXMoKSB7XG4gICAgaWYgKGNhY2hlZFJ1bGVzKSByZXR1cm4gY2FjaGVkUnVsZXM7XG4gICAgcmV0dXJuIGNhY2hlZFJ1bGVzID0gQXJyYXkuZnJvbShkb2N1bWVudC5zdHlsZVNoZWV0cykubWFwKGZ1bmN0aW9uIChzaGVldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgcnVsZXM6IHNoZWV0LmNzc1J1bGVzLCBocmVmOiBzaGVldC5ocmVmIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU3R5bGVzaGVldCBjb3VsZCBub3QgYmUgbG9hZGVkOiAnICsgc2hlZXQuaHJlZiwgZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgaW5saW5lQ3NzID0gZnVuY3Rpb24gaW5saW5lQ3NzKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBzZWxlY3RvclJlbWFwID0gX3JlZi5zZWxlY3RvclJlbWFwLFxuICAgICAgICBtb2RpZnlTdHlsZSA9IF9yZWYubW9kaWZ5U3R5bGUsXG4gICAgICAgIG1vZGlmeUNzcyA9IF9yZWYubW9kaWZ5Q3NzLFxuICAgICAgICBmb250cyA9IF9yZWYuZm9udHM7XG5cbiAgICB2YXIgZ2VuZXJhdGVDc3MgPSBtb2RpZnlDc3MgfHwgZnVuY3Rpb24gKHNlbGVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgc2VsID0gc2VsZWN0b3JSZW1hcCA/IHNlbGVjdG9yUmVtYXAoc2VsZWN0b3IpIDogc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBtb2RpZnlTdHlsZSA/IG1vZGlmeVN0eWxlKHByb3BlcnRpZXMpIDogcHJvcGVydGllcztcbiAgICAgIHJldHVybiBzZWwgKyAneycgKyBwcm9wcyArICd9XFxuJztcbiAgICB9O1xuICAgIHZhciBjc3MgPSBbXTtcbiAgICB2YXIgZGV0ZWN0Rm9udHMgPSB0eXBlb2YgZm9udHMgPT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBmb250TGlzdCA9IGZvbnRzIHx8IFtdO1xuICAgIHN0eWxlU2hlZXRSdWxlcygpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgcnVsZXMgPSBfcmVmMi5ydWxlcyxcbiAgICAgICAgICBocmVmID0gX3JlZjIuaHJlZjtcblxuICAgICAgaWYgKCFydWxlcykgcmV0dXJuO1xuICAgICAgQXJyYXkuZnJvbShydWxlcykuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUuc3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAocXVlcnkoZWwsIHJ1bGUuc2VsZWN0b3JUZXh0KSkgY3NzLnB1c2goZ2VuZXJhdGVDc3MocnVsZS5zZWxlY3RvclRleHQsIHJ1bGUuc3R5bGUuY3NzVGV4dCkpO2Vsc2UgaWYgKGRldGVjdEZvbnRzICYmIHJ1bGUuY3NzVGV4dC5tYXRjaCgvXkBmb250LWZhY2UvKSkge1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBkZXRlY3RDc3NGb250KHJ1bGUsIGhyZWYpO1xuICAgICAgICAgICAgaWYgKGZvbnQpIGZvbnRMaXN0LnB1c2goZm9udCk7XG4gICAgICAgICAgfSBlbHNlIGNzcy5wdXNoKHJ1bGUuY3NzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlubGluZUZvbnRzKGZvbnRMaXN0KS50aGVuKGZ1bmN0aW9uIChmb250Q3NzKSB7XG4gICAgICByZXR1cm4gY3NzLmpvaW4oJ1xcbicpICsgZm9udENzcztcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZG93bmxvYWRPcHRpb25zID0gZnVuY3Rpb24gZG93bmxvYWRPcHRpb25zKCkge1xuICAgIGlmICghbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IgJiYgISgnZG93bmxvYWQnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSkpIHtcbiAgICAgIHJldHVybiB7IHBvcHVwOiB3aW5kb3cub3BlbigpIH07XG4gICAgfVxuICB9O1xuXG4gIG91dCQucHJlcGFyZVN2ZyA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgZG9uZSkge1xuICAgIHJlcXVpcmVEb21Ob2RlKGVsKTtcblxuICAgIHZhciBfcmVmMyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgIF9yZWYzJGxlZnQgPSBfcmVmMy5sZWZ0LFxuICAgICAgICBsZWZ0ID0gX3JlZjMkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYzJGxlZnQsXG4gICAgICAgIF9yZWYzJHRvcCA9IF9yZWYzLnRvcCxcbiAgICAgICAgdG9wID0gX3JlZjMkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkdG9wLFxuICAgICAgICB3ID0gX3JlZjMud2lkdGgsXG4gICAgICAgIGggPSBfcmVmMy5oZWlnaHQsXG4gICAgICAgIF9yZWYzJHNjYWxlID0gX3JlZjMuc2NhbGUsXG4gICAgICAgIHNjYWxlID0gX3JlZjMkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmMyRzY2FsZSxcbiAgICAgICAgX3JlZjMkcmVzcG9uc2l2ZSA9IF9yZWYzLnJlc3BvbnNpdmUsXG4gICAgICAgIHJlc3BvbnNpdmUgPSBfcmVmMyRyZXNwb25zaXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYzJHJlc3BvbnNpdmU7XG5cbiAgICByZXR1cm4gaW5saW5lSW1hZ2VzKGVsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGNsb25lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IChvcHRpb25zIHx8IHt9KS5iYWNrZ3JvdW5kQ29sb3IgfHwgZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICB2YXIgX2dldERpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKGVsLCBjbG9uZSwgdywgaCksXG4gICAgICAgICAgd2lkdGggPSBfZ2V0RGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0RGltZW5zaW9ucy5oZWlnaHQ7XG5cbiAgICAgIGlmIChlbC50YWdOYW1lICE9PSAnc3ZnJykge1xuICAgICAgICBpZiAoZWwuZ2V0QkJveCkge1xuICAgICAgICAgIGlmIChjbG9uZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgY2xvbmUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKC90cmFuc2xhdGVcXCguKj9cXCkvLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgIGNsb25lID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byByZW5kZXIgbm9uLVNWRyBlbGVtZW50JywgZWwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCAnMS4xJyk7XG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0XS5qb2luKCcgJykpO1xuICAgICAgaWYgKCFjbG9uZS5nZXRBdHRyaWJ1dGUoJ3htbG5zJykpIGNsb25lLnNldEF0dHJpYnV0ZU5TKHhtbE5zLCAneG1sbnMnLCBzdmdOcyk7XG4gICAgICBpZiAoIWNsb25lLmdldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnKSkgY2xvbmUuc2V0QXR0cmlidXRlTlMoeG1sTnMsICd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG5cbiAgICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICAgIGNsb25lLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgY2xvbmUucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaW5ZTWluIG1lZXQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCAqIHNjYWxlKTtcbiAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQgKiBzY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIEFycmF5LmZyb20oY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnZm9yZWlnbk9iamVjdCA+IConKSkuZm9yRWFjaChmdW5jdGlvbiAoZm9yZWlnbk9iamVjdCkge1xuICAgICAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKHhtbE5zLCAneG1sbnMnLCBmb3JlaWduT2JqZWN0LnRhZ05hbWUgPT09ICdzdmcnID8gc3ZnTnMgOiB4aHRtbE5zKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaW5saW5lQ3NzKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChjc3MpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgIHN0eWxlLmlubmVySFRNTCA9ICc8IVtDREFUQVtcXG4nICsgY3NzICsgJ1xcbl1dPic7XG5cbiAgICAgICAgdmFyIGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkZWZzJyk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICBjbG9uZS5pbnNlcnRCZWZvcmUoZGVmcywgY2xvbmUuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG91dGVyLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgdmFyIHNyYyA9IG91dGVyLmlubmVySFRNTC5yZXBsYWNlKC9OU1xcZCs6aHJlZi9naSwgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhsaW5rOmhyZWYnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGRvbmUgPT09ICdmdW5jdGlvbicpIGRvbmUoc3JjLCB3aWR0aCwgaGVpZ2h0KTtlbHNlIHJldHVybiB7IHNyYzogc3JjLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBvdXQkLnN2Z0FzRGF0YVVyaSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgZG9uZSkge1xuICAgIHJlcXVpcmVEb21Ob2RlKGVsKTtcbiAgICByZXR1cm4gb3V0JC5wcmVwYXJlU3ZnKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgdmFyIHNyYyA9IF9yZWY0LnNyYyxcbiAgICAgICAgICB3aWR0aCA9IF9yZWY0LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWY0LmhlaWdodDtcblxuICAgICAgdmFyIHN2Z1htbCA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCcgKyB3aW5kb3cuYnRvYShyZUVuY29kZShkb2N0eXBlICsgc3JjKSk7XG4gICAgICBpZiAodHlwZW9mIGRvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9uZShzdmdYbWwsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1htbDtcbiAgICB9KTtcbiAgfTtcblxuICBvdXQkLnN2Z0FzUG5nVXJpID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zLCBkb25lKSB7XG4gICAgcmVxdWlyZURvbU5vZGUoZWwpO1xuXG4gICAgdmFyIF9yZWY1ID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgX3JlZjUkZW5jb2RlclR5cGUgPSBfcmVmNS5lbmNvZGVyVHlwZSxcbiAgICAgICAgZW5jb2RlclR5cGUgPSBfcmVmNSRlbmNvZGVyVHlwZSA9PT0gdW5kZWZpbmVkID8gJ2ltYWdlL3BuZycgOiBfcmVmNSRlbmNvZGVyVHlwZSxcbiAgICAgICAgX3JlZjUkZW5jb2Rlck9wdGlvbnMgPSBfcmVmNS5lbmNvZGVyT3B0aW9ucyxcbiAgICAgICAgZW5jb2Rlck9wdGlvbnMgPSBfcmVmNSRlbmNvZGVyT3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gMC44IDogX3JlZjUkZW5jb2Rlck9wdGlvbnMsXG4gICAgICAgIGNhbnZnID0gX3JlZjUuY2Fudmc7XG5cbiAgICB2YXIgY29udmVydFRvUG5nID0gZnVuY3Rpb24gY29udmVydFRvUG5nKF9yZWY2KSB7XG4gICAgICB2YXIgc3JjID0gX3JlZjYuc3JjLFxuICAgICAgICAgIHdpZHRoID0gX3JlZjYud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0O1xuXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCArICdweCc7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgaWYgKGNhbnZnKSBjYW52ZyhjYW52YXMsIHNyYyk7ZWxzZSBjb250ZXh0LmRyYXdJbWFnZShzcmMsIDAsIDApO1xuXG4gICAgICB2YXIgcG5nID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcG5nID0gY2FudmFzLnRvRGF0YVVSTChlbmNvZGVyVHlwZSwgZW5jb2Rlck9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIFNlY3VyaXR5RXJyb3IgIT09ICd1bmRlZmluZWQnICYmIGUgaW5zdGFuY2VvZiBTZWN1cml0eUVycm9yIHx8IGUubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUmVuZGVyZWQgU1ZHIGltYWdlcyBjYW5ub3QgYmUgZG93bmxvYWRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZG9uZSA9PT0gJ2Z1bmN0aW9uJykgZG9uZShwbmcsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBuZyk7XG4gICAgfTtcblxuICAgIGlmIChjYW52ZykgcmV0dXJuIG91dCQucHJlcGFyZVN2ZyhlbCwgb3B0aW9ucykudGhlbihjb252ZXJ0VG9QbmcpO2Vsc2UgcmV0dXJuIG91dCQuc3ZnQXNEYXRhVXJpKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29udmVydFRvUG5nKHtcbiAgICAgICAgICAgIHNyYzogaW1hZ2UsXG4gICAgICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGltYWdlLmhlaWdodFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoJ1RoZXJlIHdhcyBhbiBlcnJvciBsb2FkaW5nIHRoZSBkYXRhIFVSSSBhcyBhbiBpbWFnZSBvbiB0aGUgZm9sbG93aW5nIFNWR1xcbicgKyB3aW5kb3cuYXRvYih1cmkuc2xpY2UoMjYpKSArICdPcGVuIHRoZSBmb2xsb3dpbmcgbGluayB0byBzZWUgYnJvd3NlclxcJ3MgZGlhZ25vc2lzXFxuJyArIHVyaSk7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLnNyYyA9IHVyaTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIG91dCQuZG93bmxvYWQgPSBmdW5jdGlvbiAobmFtZSwgdXJpLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYih1cmlUb0Jsb2IodXJpKSwgbmFtZSk7ZWxzZSB7XG4gICAgICB2YXIgc2F2ZUxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBpZiAoJ2Rvd25sb2FkJyBpbiBzYXZlTGluaykge1xuICAgICAgICBzYXZlTGluay5kb3dubG9hZCA9IG5hbWU7XG4gICAgICAgIHNhdmVMaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2F2ZUxpbmspO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBibG9iID0gdXJpVG9CbG9iKHVyaSk7XG4gICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgc2F2ZUxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgICBzYXZlTGluay5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHdoaWxlIGdldHRpbmcgb2JqZWN0IFVSTC4gRmFsbGluZyBiYWNrIHRvIHN0cmluZyBVUkwuJyk7XG4gICAgICAgICAgc2F2ZUxpbmsuaHJlZiA9IHVyaTtcbiAgICAgICAgfVxuICAgICAgICBzYXZlTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNhdmVMaW5rKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBvcHVwKSB7XG4gICAgICAgIG9wdGlvbnMucG9wdXAuZG9jdW1lbnQudGl0bGUgPSBuYW1lO1xuICAgICAgICBvcHRpb25zLnBvcHVwLmxvY2F0aW9uLnJlcGxhY2UodXJpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb3V0JC5zYXZlU3ZnID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvd25sb2FkT3B0cyA9IGRvd25sb2FkT3B0aW9ucygpOyAvLyBkb24ndCBpbmxpbmUsIGNhbid0IGJlIGFzeW5jXG4gICAgcmV0dXJuIHJlcXVpcmVEb21Ob2RlUHJvbWlzZShlbCkudGhlbihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBvdXQkLnN2Z0FzRGF0YVVyaShlbCwgb3B0aW9ucyB8fCB7fSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodXJpKSB7XG4gICAgICByZXR1cm4gb3V0JC5kb3dubG9hZChuYW1lLCB1cmksIGRvd25sb2FkT3B0cyk7XG4gICAgfSk7XG4gIH07XG5cbiAgb3V0JC5zYXZlU3ZnQXNQbmcgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG93bmxvYWRPcHRzID0gZG93bmxvYWRPcHRpb25zKCk7IC8vIGRvbid0IGlubGluZSwgY2FuJ3QgYmUgYXN5bmNcbiAgICByZXR1cm4gcmVxdWlyZURvbU5vZGVQcm9taXNlKGVsKS50aGVuKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIG91dCQuc3ZnQXNQbmdVcmkoZWwsIG9wdGlvbnMgfHwge30pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVyaSkge1xuICAgICAgcmV0dXJuIG91dCQuZG93bmxvYWQobmFtZSwgdXJpLCBkb3dubG9hZE9wdHMpO1xuICAgIH0pO1xuICB9O1xufSkoKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/save-svg-as-png/lib/saveSvgAsPng.js\n"
          );

          /***/
        },

      /***/ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js':
        /*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            "\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBOztBQUVBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxTQUFJOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsR0FBRzs7QUFFSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDOztBQUVBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucykge1xuICB2YXIgc3R5bGVzID0gW107XG4gIHZhciBuZXdTdHlsZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNzcyA9IGl0ZW1bMV07XG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXTtcbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXTtcbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9O1xuXG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHBhcnRzOiBbcGFydF1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG4gICAgdmFyIGogPSAwO1xuXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKys7XG5cbiAgICAgIGZvciAoOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmF0dHJpYnV0ZXMgOiB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuICAgICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICAgIGRvbVN0eWxlLnJlZnMtLTtcbiAgICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICB2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgYWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbWF5UmVtb3ZlLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kb21TdHlsZSA9IG1heVJlbW92ZVtfaV07XG5cbiAgICAgIGlmIChfZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9kb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIF9kb21TdHlsZS5wYXJ0c1tqXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW19kb21TdHlsZS5pZF07XG4gICAgICB9XG4gICAgfVxuICB9O1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n"
          );

          /***/
        },

      /***/ './src/SplitStream.js':
        /*!****************************!*\
  !*** ./src/SplitStream.js ***!
  \****************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SplitStream; });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/d3svgfilters/src/d3-svg-filters.js */ "./libs/d3svgfilters/src/d3-svg-filters.js");\n/* harmony import */ var _libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SplitStreamInputData.js */ "./src/SplitStreamInputData.js");\n/* harmony import */ var _SplitStreamFilter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SplitStreamFilter.js */ "./src/SplitStreamFilter.js");\n/* harmony import */ var _SplitStreamData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SplitStreamData.js */ "./src/SplitStreamData.js");\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functions.js */ "./src/functions.js");\n/* harmony import */ var _css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../css/SplitStream.css */ "./css/SplitStream.css");\n/* harmony import */ var _css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SplitStream {\r\n  constructor(container, opts = {}) {\r\n    this._opts = {\r\n      animDuration: 1000,\r\n      margin: { top: 20, right: 20, bottom: 20, left: 20 },\r\n      height: container.clientHeight,\r\n      width: container.clientWidth,\r\n      automaticUpdate: true,\r\n      minSizeThreshold: 0,\r\n      //separationXMethod: "",\r\n      xMargin: 0,\r\n      //separationYMethod: "",\r\n      yMargin: 0,\r\n      yPadding: 0,\r\n      zoomTimeFactor: 1,\r\n      unifySize: false,\r\n      unifyPosition: false,\r\n      drawStroke: false,\r\n      showLabels: false,\r\n      mirror: false,\r\n      splitRoot: false,\r\n      shapeRendering: "geometricPrecision",\r\n      offset: "silhouette", // zero, expand, silhouette,\r\n      filterMode: "fast",\r\n\r\n      ...opts // overwrite default settings with user settings\r\n    };\r\n\r\n    this._name = container.id;\r\n    this._container = container;\r\n    this._data;\r\n    this._pathContainer;\r\n    this._textContainer;\r\n    this._svg;\r\n    this._svgFilters;\r\n    this._filters;\r\n    this._datasetsLoaded = 0;\r\n\r\n    this._streamData = new _SplitStreamData_js__WEBPACK_IMPORTED_MODULE_4__["default"]();\r\n    this._minTime;\r\n    this._maxTime;\r\n    this._maxValue;\r\n    this._maxDepth;\r\n    this._indices = {};\r\n\r\n    this._xSpacing = this.xSpacingFixed;\r\n    this._ySpacing = this.ySpacingFixed;\r\n\r\n    this._onMouseOver;\r\n    this._onMouseOut;\r\n\r\n    this._color = d3__WEBPACK_IMPORTED_MODULE_0__["scaleSequential"](d3__WEBPACK_IMPORTED_MODULE_0__["interpolateBlues"]);\r\n    this._colorRandom = false;\r\n\r\n    this._init();\r\n  }\r\n\r\n  static get a() {}\r\n\r\n  data(d) {\r\n    return d == null ? this._data : (this._setData(d), this);\r\n  }\r\n\r\n  filters(d) {\r\n    return d == null ? this._filters : (this._setFilters(d), this);\r\n  }\r\n\r\n  options(opts) {\r\n    Object.assign(this._opts, opts);\r\n  }\r\n\r\n  set automaticUpdate(auto) {\r\n    this._opts.automaticUpdate = auto;\r\n  }\r\n  set unifySize(unify) {\r\n    this._opts.unifySize = unify;\r\n    this._update();\r\n  }\r\n  set yPadding(value) {\r\n    this._opts.yPadding = +value;\r\n    this._update();\r\n  }\r\n  set unifyPosition(unify) {\r\n    this._opts.unifyPosition = unify;\r\n    this._update();\r\n  }\r\n  set mirror(mirror) {\r\n    this._opts.mirror = mirror;\r\n    this._update();\r\n  }\r\n  set splitRoot(splitRoot) {\r\n    this._opts.splitRoot = splitRoot;\r\n    this._update();\r\n  }\r\n  set minSizeThreshold(threshold) {\r\n    this._opts.minSizeThreshold = +threshold / 100;\r\n    this._update();\r\n  }\r\n  set zoomTime(factor) {\r\n    this._opts.zoomTimeFactor = +factor;\r\n    this._update();\r\n  }\r\n  set offset(offset) {\r\n    this._opts.offset = offset;\r\n    this._update();\r\n  }\r\n  set xMargin(value) {\r\n    this._opts.xMargin = +value;\r\n    this._update();\r\n  }\r\n  set yMargin(value) {\r\n    this._opts.yMargin = +value;\r\n    this._update();\r\n  }\r\n  set shapeRendering(rendering) {\r\n    this._opts.shapeRendering = rendering;\r\n    this.render();\r\n  }\r\n  set filterMode(mode) {\r\n    if (mode != this._opts.filterMode) {\r\n      d3__WEBPACK_IMPORTED_MODULE_0__["selectAll"](".depthLayer").clearFilter();\r\n      d3__WEBPACK_IMPORTED_MODULE_0__["selectAll"]("path.stream").clearFilter();\r\n    }\r\n    this._opts.filterMode = mode;\r\n    this._applyFilters();\r\n  }\r\n\r\n  set color(colorFunction) {\r\n    this._color = colorFunction;\r\n    this.render();\r\n  }\r\n  set colorRandom(random) {\r\n    this._colorRandom = random;\r\n    this.render();\r\n  }\r\n  set proportion(value) {\r\n    this._streamData.proportion = this._opts.proportion = +value;\r\n    this._update();\r\n  }\r\n  set startEndEncoding(encoding) {\r\n    this._streamData.startEndEncoding = encoding;\r\n    this._update();\r\n  }\r\n  set startEndEncodingX(x) {\r\n    this._streamData.startEndEncodingX = x;\r\n    this._update();\r\n  }\r\n  set startEndEncodingY(y) {\r\n    this._streamData.startEndEncodingY = y;\r\n    this._update();\r\n  }\r\n  set xSpacing(callback) {\r\n    this._xSpacing = callback;\r\n    this._update();\r\n  }\r\n  set ySpacing(callback) {\r\n    this._ySpacing = callback;\r\n    this._update();\r\n  }\r\n\r\n  set onMouseOver(callback) {\r\n    this._onMouseOver = callback;\r\n    this.render();\r\n  }\r\n\r\n  set onMouseOut(callback) {\r\n    this._onMouseOut = callback;\r\n    this.render();\r\n  }\r\n\r\n  get splits() {\r\n    this._streamData.splits;\r\n  }\r\n\r\n  // expects SplitStreamInputData as input\r\n  _setData(d) {\r\n    if (!(d instanceof _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_2__["default"] || d instanceof _SplitStreamFilter_js__WEBPACK_IMPORTED_MODULE_3__["default"]))\r\n      console.error(\r\n        "Added data is not an instance of SplitStreamData or SplitStreamFilter"\r\n      );\r\n\r\n    this._datasetsLoaded++;\r\n    this._data = d.data;\r\n    this._normalizeData();\r\n    this._update();\r\n  }\r\n\r\n  _setFilters(d) {\r\n    if (!d || typeof d !== "object")\r\n      return console.log(`ERROR: Added data "${d}" is not an object.`);\r\n    this._filters = d;\r\n    this._applyFilters();\r\n  }\r\n\r\n  _init() {\r\n    const { margin } = this._opts;\r\n    this._svg = d3__WEBPACK_IMPORTED_MODULE_0__["select"](this._container)\r\n      .append("svg")\r\n      .classed("secstream", "true")\r\n      .attr("height", this._container.clientHeight)\r\n      .attr("width", this._container.clientWidth)\r\n      .call(\r\n        d3__WEBPACK_IMPORTED_MODULE_0__["zoom"]().on("zoom", () => {\r\n          this._pathContainer.attr("transform", d3__WEBPACK_IMPORTED_MODULE_0__["event"].transform);\r\n          this._textContainer.attr("transform", d3__WEBPACK_IMPORTED_MODULE_0__["event"].transform);\r\n        })\r\n      );\r\n    //.on("contextmenu", () => d3.event.preventDefault());\r\n    //.append(\'g\')\r\n    //\t.attr(\'id\', \'svg-drawn\')\r\n    //.attr(\'transform\', "translate(" + margin.left + "," + margin.top + ")");\r\n\r\n    this._svgFilters = this._svg.append("defs");\r\n    this._pathContainer = this._svg.append("g").classed("pathContainer", true);\r\n    this._textContainer = this._svg.append("g").classed("textContainer", true);\r\n  }\r\n\r\n  _applyOrdering() {\r\n    // change the order of siblings in the data for less edge crossings\r\n    // TEST: RANDOM ORDER OF LEAF NODES\r\n  }\r\n\r\n  // returns true if node id did not exist before\r\n  _findStreamId(node) {\r\n    if (!!node.prev) {\r\n      // use id of prev node\r\n      node.streamId = node.prev[0].streamId;\r\n      return false;\r\n    } else {\r\n      // new node\r\n      // check if id is already in use\r\n      if (!this._indices[node.id]) {\r\n        // if not, use this id for the stream\r\n        this._indices[node.id] = true;\r\n        node.streamId = node.id;\r\n      } else {\r\n        // find a new ID\r\n        let count = 0;\r\n        let id;\r\n        do {\r\n          count++;\r\n          id = node.id + "_" + count;\r\n        } while (!!this._indices[id]);\r\n        // console.log(`ID \'${node.id}\' is already in use. Use \'${id}\' instead.`);\r\n        // ID is now in use\r\n        this._indices[id] = true;\r\n        node.streamId = id;\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n\r\n  _clearStreamIds() {\r\n    this._streamData.clear();\r\n    this._indices = {};\r\n  }\r\n\r\n  _normalizeData() {\r\n    // if node does not have a size, set it\'s size to the sum of the sizes of its children\r\n    // if a node does not have a size and does not have children, give it size 1\r\n\r\n    // TODO: this padding interferes with positions\r\n    let checkSizes = node => {\r\n      if (!!node.children) {\r\n        let aggregate = 0;\r\n        for (let child of node.children) {\r\n          checkSizes(child);\r\n          aggregate += child.size;\r\n        }\r\n        if (aggregate > node.dataSize || this._opts.unifySize)\r\n          node.size = aggregate;\r\n        else node.size = node.dataSize;\r\n\r\n        let padding = (node.children.length + 1) * this._opts.yPadding; // * (1 / (node.depth + 1));\r\n        node.size += padding;\r\n      } else\r\n        node.size = this._opts.unifySize\r\n          ? 1\r\n          : node.dataSize + this._opts.yPadding;\r\n    };\r\n\r\n    // TODO: This version is better with positions but doesn\'t work properly in general\r\n    // let checkSizes = node => {\r\n    //   if (!!node.children) {\r\n    //     let aggregate = 0;\r\n    //     for (let child of node.children) {\r\n    //       checkSizes(child);\r\n    //       aggregate += child.size;\r\n    //     }\r\n    //     let dataSize = node.dataSize + this._opts.yPadding;\r\n    //     if (aggregate > dataSize || this._opts.unifySize)\r\n    //       node.size = aggregate + this._opts.yPadding;\r\n    //     else node.size = dataSize;\r\n    //   } else node.size = this._opts.unifySize ? 1 : node.dataSize;\r\n    // };\r\n\r\n    // positions must be unified, if sizes are unified\r\n    let checkPositions = (node, pos = 0) => {\r\n      if (\r\n        this._opts.unifySize ||\r\n        this._opts.unifyPosition ||\r\n        !node.dataPos ||\r\n        (!!node.parent && node.parent.id == "fakeRoot")\r\n      )\r\n        node.pos = pos;\r\n      else node.pos = node.dataPos;\r\n\r\n      if (!!node.children && node.children.length > 0) {\r\n        let aggregate = 0;\r\n        for (let child of node.children) {\r\n          aggregate += child.size;\r\n        }\r\n        let spacing = (node.size - aggregate) / (node.children.length + 1);\r\n\r\n        for (let [i, child] of node.children.entries()) {\r\n          pos += spacing;\r\n          checkPositions(child, pos);\r\n          pos += child.size;\r\n        }\r\n      }\r\n    };\r\n\r\n    this._clearStreamIds();\r\n    let time = this._data.timesteps;\r\n    this._maxValue = 0;\r\n    this._maxTime = 0;\r\n    this._minTime = Infinity;\r\n    for (let t in time) {\r\n      checkSizes(time[t].tree);\r\n      checkPositions(time[t].tree);\r\n      this._maxValue = Math.max(this._maxValue, time[t].tree.size);\r\n      this._minTime = Math.min(this._minTime, +t);\r\n      this._maxTime = Math.max(this._maxTime, +t);\r\n    }\r\n\r\n    this._maxDepth = 0;\r\n    let traverse = (node, depth) => {\r\n      this._maxDepth = Math.max(this._maxDepth, depth);\r\n      node.depth = depth++;\r\n      let isNew = this._findStreamId(node);\r\n      if (isNew) this._streamData.add(node);\r\n\r\n      if (!!node.children)\r\n        node.children.forEach(child => traverse(child, depth));\r\n    };\r\n\r\n    for (let i in time) traverse(time[i].tree, 0);\r\n  }\r\n\r\n  _calculatePositions() {\r\n    let { height, width, margin, minSizeThreshold, offset } = this._opts;\r\n\r\n    let setOffset = root => {\r\n      if (offset == "zero") {\r\n        root.y0 = 0;\r\n        root.y1 = root.size / this._maxValue;\r\n      } else if (offset == "expand") {\r\n        root.y0 = 0;\r\n        root.y1 = 1;\r\n      } else if (offset == "silhouette") {\r\n        root.y0 = 0.5 - (0.5 * root.size) / this._maxValue;\r\n        root.y1 = 0.5 + (0.5 * root.size) / this._maxValue;\r\n      }\r\n    };\r\n\r\n    let traverse = (node, childX = 0) => {\r\n      let p = node.parent;\r\n      if (!p) {\r\n        node.marginX = this._opts.splitRoot ? this._xSpacing(node) : 0;\r\n      } else {\r\n        node.x = p.x;\r\n        let numMargins = p.children.length + 1;\r\n        let space = p.y1 - p.y0 - numMargins * p.marginY;\r\n        if (space <= 0) {\r\n          node.y0 = 0.5 * (p.y0 + p.y1);\r\n          node.y1 = 0.5 * (p.y0 + p.y1);\r\n        } else {\r\n          // normalize\r\n          node.rpos = (node.pos - p.pos) / p.size;\r\n          node.rsize = node.size / p.size;\r\n          node.y0 = p.y0 + (childX + 1) * p.marginY + space * node.rpos;\r\n          node.y1 = node.y0 + space * node.rsize;\r\n\r\n          let size = node.y1 - node.y0;\r\n          if (size <= minSizeThreshold) {\r\n            node.y0 = 0.5 * (node.y0 + node.y1);\r\n            node.y1 = 0.5 * (node.y0 + node.y1);\r\n          }\r\n        }\r\n\r\n        node.marginX = p.marginX + this._xSpacing(node);\r\n      }\r\n\r\n      node.marginY = this._ySpacing(node);\r\n\r\n      if (!!node.children)\r\n        node.children.forEach((child, i) => traverse(child, i));\r\n    };\r\n\r\n    let time = this._data.timesteps;\r\n    for (let i in time) {\r\n      time[i].tree.x = +i;\r\n      setOffset(time[i].tree);\r\n      traverse(time[i].tree);\r\n    }\r\n\r\n    // treemaps require 0.5 time space to the left and right of the timestep\r\n    this._streamData.xScale = d3__WEBPACK_IMPORTED_MODULE_0__["scaleLinear"]()\r\n      .domain([this._minTime - 0.5, this._maxTime + 0.5])\r\n      // .domain([\r\n      //   this._minTime - 0.5 * (1 - this._opts.proportion),\r\n      //   this._maxTime + 0.5 * (1 - this._opts.proportion)\r\n      // ])\r\n      .range([margin.left, width * this._opts.zoomTimeFactor - margin.right]);\r\n\r\n    let domain = this._opts.mirror ? [1, 0] : [0, 1];\r\n    this._streamData.yScale = d3__WEBPACK_IMPORTED_MODULE_0__["scaleLinear"]()\r\n      .domain(domain)\r\n      .nice()\r\n      .range([height - margin.bottom, margin.top]);\r\n    //.range(margin.top, height - margin.bottom);\r\n  }\r\n\r\n  setRootNodeById(Id) {\r\n    let root = this._streamData.streams.find(d => d.id == id);\r\n  }\r\n\r\n  render() {\r\n    let color = this._colorRandom\r\n      ? _functions_js__WEBPACK_IMPORTED_MODULE_5__["getRandomColor"]\r\n      : this._color.domain([this._maxDepth, 0]);\r\n\r\n    let streamsByDepth = d3__WEBPACK_IMPORTED_MODULE_0__["nest"]()\r\n      .key(d => d.deepestDepth)\r\n      .entries(this._streamData.streams);\r\n\r\n    let depthLayers = this._pathContainer\r\n      .selectAll("g.depthLayer > g.clipLayer")\r\n      .data(streamsByDepth, d => this._name + this._datasetsLoaded + d.key)\r\n      .join(enter =>\r\n        enter\r\n          .append("g")\r\n          .classed("depthLayer", true)\r\n          .each(function(d) {\r\n            this.classList.add("depth-" + d.key);\r\n          })\r\n          .append("g")\r\n          .classed("clipLayer", true)\r\n      );\r\n\r\n    // .attr(\'clip-path\', d => \'url(#clip\' + d.key + \'wrapper)\');\r\n\r\n    depthLayers\r\n      .selectAll("path.stream")\r\n      .data(d => d.values, d => this._name + this._datasetsLoaded + d.id)\r\n      .join(enter =>\r\n        enter\r\n          .append("path")\r\n          .classed("stream", true)\r\n          .on("mouseover", this._onMouseOver)\r\n          .on("mouseout", this._onMouseOut)\r\n          .attr("clip-path", d => "url(#clip" + d.id + this._name + ")")\r\n          .attr("id", d => "stream" + d.id + this._name)\r\n          //.attr(\'stroke-width\', 3)\r\n          .attr("paint-order", "stroke")\r\n      )\r\n      .attr("d", d => d.path)\r\n      .attr("shape-rendering", this._opts.shapeRendering)\r\n      .attr(\r\n        "fill",\r\n        d => (!!d.data ? d.data.color : null) || color(d.deepestDepth)\r\n        // \'white\'\r\n      )\r\n      // remove empty streams (they do not include a single bezier curve)\r\n      .filter(d => d.path.indexOf("C") == -1)\r\n      .remove();\r\n\r\n    this.showLabels(this._opts.showLabels);\r\n    this.drawStroke(this._opts.drawStroke);\r\n\r\n    let splitData = this._svgFilters\r\n      .selectAll("clipPath")\r\n      .data(\r\n        this._streamData.clipPaths,\r\n        d => this._name + this._datasetsLoaded + d.id\r\n      );\r\n\r\n    splitData\r\n      .enter()\r\n      .append("clipPath")\r\n      .attr("id", d => "clip" + d.id + this._name)\r\n      .merge(splitData)\r\n      .html(d => \'<path d="\' + d.path + \'">\');\r\n\r\n    splitData.exit().remove();\r\n\r\n    this._applyFilters();\r\n  }\r\n\r\n  showLabels(show = true) {\r\n    this._opts.showLabels = show;\r\n    let labelData = this._opts.showLabels ? this._streamData.streams : [];\r\n\r\n    let labels = this._textContainer\r\n      .selectAll("text")\r\n      .data(labelData, d => d.id);\r\n\r\n    labels\r\n      .enter()\r\n      .append("text")\r\n      .text(d => (!!d.data ? d.data.typeLabel : d.id))\r\n      .merge(labels)\r\n      .attr("x", d => d.textPos.x)\r\n      .attr("y", d => d.textPos.y);\r\n\r\n    labels.exit().remove();\r\n  }\r\n\r\n  drawStroke(draw = true) {\r\n    this._opts.drawStroke = draw;\r\n    let color = this._opts.drawStroke ? "black" : null;\r\n    this._pathContainer.attr("stroke", color);\r\n    this._pathContainer.attr("stroke-width", 3);\r\n    // d3.selectAll(\'path\').attr(\'stroke-width\', 0.001)\r\n  }\r\n\r\n  _applyFilters() {\r\n    if (!this._filters) return;\r\n\r\n    let filters = [];\r\n    for (let filter of this._filters)\r\n      filters.push(filter.type, {\r\n        color: "black",\r\n        dx: filter.dx,\r\n        dy: filter.dy,\r\n        blur: filter.stdDeviation\r\n      });\r\n\r\n    if (this._opts.filterMode == "fast")\r\n      d3__WEBPACK_IMPORTED_MODULE_0__["selectAll"](".depthLayer").svgFilter(...filters);\r\n    else if (this._opts.filterMode == "accurate")\r\n      d3__WEBPACK_IMPORTED_MODULE_0__["selectAll"]("path.stream").svgFilter(...filters);\r\n  }\r\n\r\n  update() {\r\n    this._update(true);\r\n  }\r\n  _update(manuallyTriggered = false) {\r\n    if (!this._data) return;\r\n\r\n    if (!this._opts.automaticUpdate) if (!manuallyTriggered) return;\r\n\r\n    console.log("update");\r\n    let startTime = Date.now();\r\n\r\n    this._normalizeData();\r\n    this._applyOrdering();\r\n    this._calculatePositions();\r\n\r\n    // this._streamData.preprocess();\r\n    this._streamData.calculatePaths();\r\n    this.render();\r\n\r\n    console.log(\r\n      "TIMING: " + this._data.numNodes + "," + (Date.now() - startTime)\r\n    );\r\n  }\r\n\r\n  resize(\r\n    width = this._container.clientWidth,\r\n    height = this._container.clientHeight\r\n  ) {\r\n    this._opts.width = width;\r\n    this._opts.height = height;\r\n    this._svg.attr("width", width).attr("height", height);\r\n\r\n    this._update();\r\n  }\r\n\r\n  ySpacingFixed(node) {\r\n    return this._opts.yMargin / 4;\r\n  }\r\n\r\n  ySpacingPercentage(node) {\r\n    return ((node.y1 - node.y0) * this._opts.yMargin) / 2;\r\n  }\r\n\r\n  ySpacingHierarchical(node) {\r\n    return ((node.depth + 1) * this._opts.yMargin) / 4;\r\n  }\r\n\r\n  ySpacingHierarchicalReverse(node) {\r\n    return ((1 / (node.depth + 1)) * this._opts.yMargin) / 4;\r\n  }\r\n\r\n  xSpacingFixed(node) {\r\n    return this._opts.xMargin / 10;\r\n  }\r\n\r\n  // TODO: use the max depth at that timepoint instead\r\n  xSpacingHierarchical(node) {\r\n    return ((node.depth + 1) / this._maxDepth) * this._opts.xMargin;\r\n  }\r\n\r\n  xSpacingHierarchicalReverse(node) {\r\n    return (1 / (node.depth + 1)) * this._opts.xMargin;\r\n  }\r\n\r\n  addSplits(splits) {\r\n    this._streamData.addSplits(splits);\r\n    this._update();\r\n  }\r\n\r\n  addSplitsAtTimepoints() {\r\n    let splits = [];\r\n    for (let i = this._minTime; i <= this._maxTime; i++) splits.push(i);\r\n    this.addSplits(splits);\r\n  }\r\n\r\n  addSplitsBetweenTimepoints() {\r\n    let splits = [];\r\n    for (let i = this._minTime - 1; i <= this._maxTime; i++)\r\n      splits.push(i + 0.5);\r\n    this.addSplits(splits);\r\n  }\r\n\r\n  addSplitsRandomly(num = 1) {\r\n    let t0 = this._minTime - 1;\r\n    let t1 = this._maxTime + 1;\r\n    let splits = [];\r\n    for (let i = 0; i < num; i++) {\r\n      let r = t0 + Math.random() * (t1 - t0);\r\n      splits.push(r.toString());\r\n      splits.sort();\r\n    }\r\n    this.addSplits(splits);\r\n  }\r\n\r\n  removeSplits(splits) {\r\n    this._streamData.removeSplits(splits);\r\n    this._update();\r\n  }\r\n\r\n  // static extend(...args) {\r\n  //     this.myNewFunction\r\n  // }\r\n  // extend(...args) {\r\n  //     return SplitStream.extend(...args);\r\n  // }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW0uanM/OWQzYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUI7QUFDMkI7O0FBRVM7QUFDTjtBQUNKOztBQUVIO0FBQ2hCOztBQUVqQjtBQUNmLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZUFBZSwyQ0FBMkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDJEQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixrREFBa0IsQ0FBQyxtREFBbUI7QUFDeEQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQVk7QUFDbEIsTUFBTSw0Q0FBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFvQixpQkFBaUIsNkRBQWlCO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsZ0JBQWdCLHlDQUNIO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQU87QUFDZixnREFBZ0Qsd0NBQVE7QUFDeEQsZ0RBQWdELHdDQUFRO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QixRQUFRLDRCQUE0QixHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFQUF1RTtBQUN2RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGtEQUFrRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDhDQUNaO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw4Q0FDWjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSw0REFBYztBQUN0Qjs7QUFFQSx5QkFBeUIsdUNBQ2Q7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLE1BQU0sNENBQVk7QUFDbEI7QUFDQSxNQUFNLDRDQUFZO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3BsaXRTdHJlYW0uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBkMyBmcm9tIFwiZDNcIjtcclxuaW1wb3J0IFwiLi4vbGlicy9kM3N2Z2ZpbHRlcnMvc3JjL2QzLXN2Zy1maWx0ZXJzLmpzXCI7XHJcblxyXG5pbXBvcnQgU3BsaXRTdHJlYW1JbnB1dERhdGEgZnJvbSBcIi4vU3BsaXRTdHJlYW1JbnB1dERhdGEuanNcIjtcclxuaW1wb3J0IFNwbGl0U3RyZWFtRmlsdGVyIGZyb20gXCIuL1NwbGl0U3RyZWFtRmlsdGVyLmpzXCI7XHJcbmltcG9ydCBTcGxpdFN0cmVhbURhdGEgZnJvbSBcIi4vU3BsaXRTdHJlYW1EYXRhLmpzXCI7XHJcblxyXG5pbXBvcnQgeyBnZXRSYW5kb21Db2xvciB9IGZyb20gXCIuL2Z1bmN0aW9ucy5qc1wiO1xyXG5pbXBvcnQgXCIuLi9jc3MvU3BsaXRTdHJlYW0uY3NzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdFN0cmVhbSB7XHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBvcHRzID0ge30pIHtcclxuICAgIHRoaXMuX29wdHMgPSB7XHJcbiAgICAgIGFuaW1EdXJhdGlvbjogMTAwMCxcclxuICAgICAgbWFyZ2luOiB7IHRvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiAyMCwgbGVmdDogMjAgfSxcclxuICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0LFxyXG4gICAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG4gICAgICBhdXRvbWF0aWNVcGRhdGU6IHRydWUsXHJcbiAgICAgIG1pblNpemVUaHJlc2hvbGQ6IDAsXHJcbiAgICAgIC8vc2VwYXJhdGlvblhNZXRob2Q6IFwiXCIsXHJcbiAgICAgIHhNYXJnaW46IDAsXHJcbiAgICAgIC8vc2VwYXJhdGlvbllNZXRob2Q6IFwiXCIsXHJcbiAgICAgIHlNYXJnaW46IDAsXHJcbiAgICAgIHlQYWRkaW5nOiAwLFxyXG4gICAgICB6b29tVGltZUZhY3RvcjogMSxcclxuICAgICAgdW5pZnlTaXplOiBmYWxzZSxcclxuICAgICAgdW5pZnlQb3NpdGlvbjogZmFsc2UsXHJcbiAgICAgIGRyYXdTdHJva2U6IGZhbHNlLFxyXG4gICAgICBzaG93TGFiZWxzOiBmYWxzZSxcclxuICAgICAgbWlycm9yOiBmYWxzZSxcclxuICAgICAgc3BsaXRSb290OiBmYWxzZSxcclxuICAgICAgc2hhcGVSZW5kZXJpbmc6IFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXHJcbiAgICAgIG9mZnNldDogXCJzaWxob3VldHRlXCIsIC8vIHplcm8sIGV4cGFuZCwgc2lsaG91ZXR0ZSxcclxuICAgICAgZmlsdGVyTW9kZTogXCJmYXN0XCIsXHJcblxyXG4gICAgICAuLi5vcHRzIC8vIG92ZXJ3cml0ZSBkZWZhdWx0IHNldHRpbmdzIHdpdGggdXNlciBzZXR0aW5nc1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9uYW1lID0gY29udGFpbmVyLmlkO1xyXG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgdGhpcy5fZGF0YTtcclxuICAgIHRoaXMuX3BhdGhDb250YWluZXI7XHJcbiAgICB0aGlzLl90ZXh0Q29udGFpbmVyO1xyXG4gICAgdGhpcy5fc3ZnO1xyXG4gICAgdGhpcy5fc3ZnRmlsdGVycztcclxuICAgIHRoaXMuX2ZpbHRlcnM7XHJcbiAgICB0aGlzLl9kYXRhc2V0c0xvYWRlZCA9IDA7XHJcblxyXG4gICAgdGhpcy5fc3RyZWFtRGF0YSA9IG5ldyBTcGxpdFN0cmVhbURhdGEoKTtcclxuICAgIHRoaXMuX21pblRpbWU7XHJcbiAgICB0aGlzLl9tYXhUaW1lO1xyXG4gICAgdGhpcy5fbWF4VmFsdWU7XHJcbiAgICB0aGlzLl9tYXhEZXB0aDtcclxuICAgIHRoaXMuX2luZGljZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLl94U3BhY2luZyA9IHRoaXMueFNwYWNpbmdGaXhlZDtcclxuICAgIHRoaXMuX3lTcGFjaW5nID0gdGhpcy55U3BhY2luZ0ZpeGVkO1xyXG5cclxuICAgIHRoaXMuX29uTW91c2VPdmVyO1xyXG4gICAgdGhpcy5fb25Nb3VzZU91dDtcclxuXHJcbiAgICB0aGlzLl9jb2xvciA9IGQzLnNjYWxlU2VxdWVudGlhbChkMy5pbnRlcnBvbGF0ZUJsdWVzKTtcclxuICAgIHRoaXMuX2NvbG9yUmFuZG9tID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5faW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBhKCkge31cclxuXHJcbiAgZGF0YShkKSB7XHJcbiAgICByZXR1cm4gZCA9PSBudWxsID8gdGhpcy5fZGF0YSA6ICh0aGlzLl9zZXREYXRhKGQpLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIGZpbHRlcnMoZCkge1xyXG4gICAgcmV0dXJuIGQgPT0gbnVsbCA/IHRoaXMuX2ZpbHRlcnMgOiAodGhpcy5fc2V0RmlsdGVycyhkKSwgdGhpcyk7XHJcbiAgfVxyXG5cclxuICBvcHRpb25zKG9wdHMpIHtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fb3B0cywgb3B0cyk7XHJcbiAgfVxyXG5cclxuICBzZXQgYXV0b21hdGljVXBkYXRlKGF1dG8pIHtcclxuICAgIHRoaXMuX29wdHMuYXV0b21hdGljVXBkYXRlID0gYXV0bztcclxuICB9XHJcbiAgc2V0IHVuaWZ5U2l6ZSh1bmlmeSkge1xyXG4gICAgdGhpcy5fb3B0cy51bmlmeVNpemUgPSB1bmlmeTtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuICBzZXQgeVBhZGRpbmcodmFsdWUpIHtcclxuICAgIHRoaXMuX29wdHMueVBhZGRpbmcgPSArdmFsdWU7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcbiAgc2V0IHVuaWZ5UG9zaXRpb24odW5pZnkpIHtcclxuICAgIHRoaXMuX29wdHMudW5pZnlQb3NpdGlvbiA9IHVuaWZ5O1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG4gIHNldCBtaXJyb3IobWlycm9yKSB7XHJcbiAgICB0aGlzLl9vcHRzLm1pcnJvciA9IG1pcnJvcjtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuICBzZXQgc3BsaXRSb290KHNwbGl0Um9vdCkge1xyXG4gICAgdGhpcy5fb3B0cy5zcGxpdFJvb3QgPSBzcGxpdFJvb3Q7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcbiAgc2V0IG1pblNpemVUaHJlc2hvbGQodGhyZXNob2xkKSB7XHJcbiAgICB0aGlzLl9vcHRzLm1pblNpemVUaHJlc2hvbGQgPSArdGhyZXNob2xkIC8gMTAwO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG4gIHNldCB6b29tVGltZShmYWN0b3IpIHtcclxuICAgIHRoaXMuX29wdHMuem9vbVRpbWVGYWN0b3IgPSArZmFjdG9yO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG4gIHNldCBvZmZzZXQob2Zmc2V0KSB7XHJcbiAgICB0aGlzLl9vcHRzLm9mZnNldCA9IG9mZnNldDtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuICBzZXQgeE1hcmdpbih2YWx1ZSkge1xyXG4gICAgdGhpcy5fb3B0cy54TWFyZ2luID0gK3ZhbHVlO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG4gIHNldCB5TWFyZ2luKHZhbHVlKSB7XHJcbiAgICB0aGlzLl9vcHRzLnlNYXJnaW4gPSArdmFsdWU7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcbiAgc2V0IHNoYXBlUmVuZGVyaW5nKHJlbmRlcmluZykge1xyXG4gICAgdGhpcy5fb3B0cy5zaGFwZVJlbmRlcmluZyA9IHJlbmRlcmluZztcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgfVxyXG4gIHNldCBmaWx0ZXJNb2RlKG1vZGUpIHtcclxuICAgIGlmIChtb2RlICE9IHRoaXMuX29wdHMuZmlsdGVyTW9kZSkge1xyXG4gICAgICBkMy5zZWxlY3RBbGwoXCIuZGVwdGhMYXllclwiKS5jbGVhckZpbHRlcigpO1xyXG4gICAgICBkMy5zZWxlY3RBbGwoXCJwYXRoLnN0cmVhbVwiKS5jbGVhckZpbHRlcigpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fb3B0cy5maWx0ZXJNb2RlID0gbW9kZTtcclxuICAgIHRoaXMuX2FwcGx5RmlsdGVycygpO1xyXG4gIH1cclxuXHJcbiAgc2V0IGNvbG9yKGNvbG9yRnVuY3Rpb24pIHtcclxuICAgIHRoaXMuX2NvbG9yID0gY29sb3JGdW5jdGlvbjtcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgfVxyXG4gIHNldCBjb2xvclJhbmRvbShyYW5kb20pIHtcclxuICAgIHRoaXMuX2NvbG9yUmFuZG9tID0gcmFuZG9tO1xyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuICB9XHJcbiAgc2V0IHByb3BvcnRpb24odmFsdWUpIHtcclxuICAgIHRoaXMuX3N0cmVhbURhdGEucHJvcG9ydGlvbiA9IHRoaXMuX29wdHMucHJvcG9ydGlvbiA9ICt2YWx1ZTtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuICBzZXQgc3RhcnRFbmRFbmNvZGluZyhlbmNvZGluZykge1xyXG4gICAgdGhpcy5fc3RyZWFtRGF0YS5zdGFydEVuZEVuY29kaW5nID0gZW5jb2Rpbmc7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcbiAgc2V0IHN0YXJ0RW5kRW5jb2RpbmdYKHgpIHtcclxuICAgIHRoaXMuX3N0cmVhbURhdGEuc3RhcnRFbmRFbmNvZGluZ1ggPSB4O1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG4gIHNldCBzdGFydEVuZEVuY29kaW5nWSh5KSB7XHJcbiAgICB0aGlzLl9zdHJlYW1EYXRhLnN0YXJ0RW5kRW5jb2RpbmdZID0geTtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuICBzZXQgeFNwYWNpbmcoY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX3hTcGFjaW5nID0gY2FsbGJhY2s7XHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICB9XHJcbiAgc2V0IHlTcGFjaW5nKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLl95U3BhY2luZyA9IGNhbGxiYWNrO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBzZXQgb25Nb3VzZU92ZXIoY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX29uTW91c2VPdmVyID0gY2FsbGJhY2s7XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgc2V0IG9uTW91c2VPdXQoY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX29uTW91c2VPdXQgPSBjYWxsYmFjaztcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgc3BsaXRzKCkge1xyXG4gICAgdGhpcy5fc3RyZWFtRGF0YS5zcGxpdHM7XHJcbiAgfVxyXG5cclxuICAvLyBleHBlY3RzIFNwbGl0U3RyZWFtSW5wdXREYXRhIGFzIGlucHV0XHJcbiAgX3NldERhdGEoZCkge1xyXG4gICAgaWYgKCEoZCBpbnN0YW5jZW9mIFNwbGl0U3RyZWFtSW5wdXREYXRhIHx8IGQgaW5zdGFuY2VvZiBTcGxpdFN0cmVhbUZpbHRlcikpXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgXCJBZGRlZCBkYXRhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBTcGxpdFN0cmVhbURhdGEgb3IgU3BsaXRTdHJlYW1GaWx0ZXJcIlxyXG4gICAgICApO1xyXG5cclxuICAgIHRoaXMuX2RhdGFzZXRzTG9hZGVkKys7XHJcbiAgICB0aGlzLl9kYXRhID0gZC5kYXRhO1xyXG4gICAgdGhpcy5fbm9ybWFsaXplRGF0YSgpO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBfc2V0RmlsdGVycyhkKSB7XHJcbiAgICBpZiAoIWQgfHwgdHlwZW9mIGQgIT09IFwib2JqZWN0XCIpXHJcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyhgRVJST1I6IEFkZGVkIGRhdGEgXCIke2R9XCIgaXMgbm90IGFuIG9iamVjdC5gKTtcclxuICAgIHRoaXMuX2ZpbHRlcnMgPSBkO1xyXG4gICAgdGhpcy5fYXBwbHlGaWx0ZXJzKCk7XHJcbiAgfVxyXG5cclxuICBfaW5pdCgpIHtcclxuICAgIGNvbnN0IHsgbWFyZ2luIH0gPSB0aGlzLl9vcHRzO1xyXG4gICAgdGhpcy5fc3ZnID0gZDNcclxuICAgICAgLnNlbGVjdCh0aGlzLl9jb250YWluZXIpXHJcbiAgICAgIC5hcHBlbmQoXCJzdmdcIilcclxuICAgICAgLmNsYXNzZWQoXCJzZWNzdHJlYW1cIiwgXCJ0cnVlXCIpXHJcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpXHJcbiAgICAgIC5hdHRyKFwid2lkdGhcIiwgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoKVxyXG4gICAgICAuY2FsbChcclxuICAgICAgICBkMy56b29tKCkub24oXCJ6b29tXCIsICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3BhdGhDb250YWluZXIuYXR0cihcInRyYW5zZm9ybVwiLCBkMy5ldmVudC50cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgdGhpcy5fdGV4dENvbnRhaW5lci5hdHRyKFwidHJhbnNmb3JtXCIsIGQzLmV2ZW50LnRyYW5zZm9ybSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIC8vLm9uKFwiY29udGV4dG1lbnVcIiwgKCkgPT4gZDMuZXZlbnQucHJldmVudERlZmF1bHQoKSk7XHJcbiAgICAvLy5hcHBlbmQoJ2cnKVxyXG4gICAgLy9cdC5hdHRyKCdpZCcsICdzdmctZHJhd24nKVxyXG4gICAgLy8uYXR0cigndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcclxuXHJcbiAgICB0aGlzLl9zdmdGaWx0ZXJzID0gdGhpcy5fc3ZnLmFwcGVuZChcImRlZnNcIik7XHJcbiAgICB0aGlzLl9wYXRoQ29udGFpbmVyID0gdGhpcy5fc3ZnLmFwcGVuZChcImdcIikuY2xhc3NlZChcInBhdGhDb250YWluZXJcIiwgdHJ1ZSk7XHJcbiAgICB0aGlzLl90ZXh0Q29udGFpbmVyID0gdGhpcy5fc3ZnLmFwcGVuZChcImdcIikuY2xhc3NlZChcInRleHRDb250YWluZXJcIiwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBfYXBwbHlPcmRlcmluZygpIHtcclxuICAgIC8vIGNoYW5nZSB0aGUgb3JkZXIgb2Ygc2libGluZ3MgaW4gdGhlIGRhdGEgZm9yIGxlc3MgZWRnZSBjcm9zc2luZ3NcclxuICAgIC8vIFRFU1Q6IFJBTkRPTSBPUkRFUiBPRiBMRUFGIE5PREVTXHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm5zIHRydWUgaWYgbm9kZSBpZCBkaWQgbm90IGV4aXN0IGJlZm9yZVxyXG4gIF9maW5kU3RyZWFtSWQobm9kZSkge1xyXG4gICAgaWYgKCEhbm9kZS5wcmV2KSB7XHJcbiAgICAgIC8vIHVzZSBpZCBvZiBwcmV2IG5vZGVcclxuICAgICAgbm9kZS5zdHJlYW1JZCA9IG5vZGUucHJldlswXS5zdHJlYW1JZDtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gbmV3IG5vZGVcclxuICAgICAgLy8gY2hlY2sgaWYgaWQgaXMgYWxyZWFkeSBpbiB1c2VcclxuICAgICAgaWYgKCF0aGlzLl9pbmRpY2VzW25vZGUuaWRdKSB7XHJcbiAgICAgICAgLy8gaWYgbm90LCB1c2UgdGhpcyBpZCBmb3IgdGhlIHN0cmVhbVxyXG4gICAgICAgIHRoaXMuX2luZGljZXNbbm9kZS5pZF0gPSB0cnVlO1xyXG4gICAgICAgIG5vZGUuc3RyZWFtSWQgPSBub2RlLmlkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGZpbmQgYSBuZXcgSURcclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGxldCBpZDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgaWQgPSBub2RlLmlkICsgXCJfXCIgKyBjb3VudDtcclxuICAgICAgICB9IHdoaWxlICghIXRoaXMuX2luZGljZXNbaWRdKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgSUQgJyR7bm9kZS5pZH0nIGlzIGFscmVhZHkgaW4gdXNlLiBVc2UgJyR7aWR9JyBpbnN0ZWFkLmApO1xyXG4gICAgICAgIC8vIElEIGlzIG5vdyBpbiB1c2VcclxuICAgICAgICB0aGlzLl9pbmRpY2VzW2lkXSA9IHRydWU7XHJcbiAgICAgICAgbm9kZS5zdHJlYW1JZCA9IGlkO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NsZWFyU3RyZWFtSWRzKCkge1xyXG4gICAgdGhpcy5fc3RyZWFtRGF0YS5jbGVhcigpO1xyXG4gICAgdGhpcy5faW5kaWNlcyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgX25vcm1hbGl6ZURhdGEoKSB7XHJcbiAgICAvLyBpZiBub2RlIGRvZXMgbm90IGhhdmUgYSBzaXplLCBzZXQgaXQncyBzaXplIHRvIHRoZSBzdW0gb2YgdGhlIHNpemVzIG9mIGl0cyBjaGlsZHJlblxyXG4gICAgLy8gaWYgYSBub2RlIGRvZXMgbm90IGhhdmUgYSBzaXplIGFuZCBkb2VzIG5vdCBoYXZlIGNoaWxkcmVuLCBnaXZlIGl0IHNpemUgMVxyXG5cclxuICAgIC8vIFRPRE86IHRoaXMgcGFkZGluZyBpbnRlcmZlcmVzIHdpdGggcG9zaXRpb25zXHJcbiAgICBsZXQgY2hlY2tTaXplcyA9IG5vZGUgPT4ge1xyXG4gICAgICBpZiAoISFub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgbGV0IGFnZ3JlZ2F0ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgY2hlY2tTaXplcyhjaGlsZCk7XHJcbiAgICAgICAgICBhZ2dyZWdhdGUgKz0gY2hpbGQuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFnZ3JlZ2F0ZSA+IG5vZGUuZGF0YVNpemUgfHwgdGhpcy5fb3B0cy51bmlmeVNpemUpXHJcbiAgICAgICAgICBub2RlLnNpemUgPSBhZ2dyZWdhdGU7XHJcbiAgICAgICAgZWxzZSBub2RlLnNpemUgPSBub2RlLmRhdGFTaXplO1xyXG5cclxuICAgICAgICBsZXQgcGFkZGluZyA9IChub2RlLmNoaWxkcmVuLmxlbmd0aCArIDEpICogdGhpcy5fb3B0cy55UGFkZGluZzsgLy8gKiAoMSAvIChub2RlLmRlcHRoICsgMSkpO1xyXG4gICAgICAgIG5vZGUuc2l6ZSArPSBwYWRkaW5nO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICBub2RlLnNpemUgPSB0aGlzLl9vcHRzLnVuaWZ5U2l6ZVxyXG4gICAgICAgICAgPyAxXHJcbiAgICAgICAgICA6IG5vZGUuZGF0YVNpemUgKyB0aGlzLl9vcHRzLnlQYWRkaW5nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPOiBUaGlzIHZlcnNpb24gaXMgYmV0dGVyIHdpdGggcG9zaXRpb25zIGJ1dCBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaW4gZ2VuZXJhbFxyXG4gICAgLy8gbGV0IGNoZWNrU2l6ZXMgPSBub2RlID0+IHtcclxuICAgIC8vICAgaWYgKCEhbm9kZS5jaGlsZHJlbikge1xyXG4gICAgLy8gICAgIGxldCBhZ2dyZWdhdGUgPSAwO1xyXG4gICAgLy8gICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgIC8vICAgICAgIGNoZWNrU2l6ZXMoY2hpbGQpO1xyXG4gICAgLy8gICAgICAgYWdncmVnYXRlICs9IGNoaWxkLnNpemU7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIGxldCBkYXRhU2l6ZSA9IG5vZGUuZGF0YVNpemUgKyB0aGlzLl9vcHRzLnlQYWRkaW5nO1xyXG4gICAgLy8gICAgIGlmIChhZ2dyZWdhdGUgPiBkYXRhU2l6ZSB8fCB0aGlzLl9vcHRzLnVuaWZ5U2l6ZSlcclxuICAgIC8vICAgICAgIG5vZGUuc2l6ZSA9IGFnZ3JlZ2F0ZSArIHRoaXMuX29wdHMueVBhZGRpbmc7XHJcbiAgICAvLyAgICAgZWxzZSBub2RlLnNpemUgPSBkYXRhU2l6ZTtcclxuICAgIC8vICAgfSBlbHNlIG5vZGUuc2l6ZSA9IHRoaXMuX29wdHMudW5pZnlTaXplID8gMSA6IG5vZGUuZGF0YVNpemU7XHJcbiAgICAvLyB9O1xyXG5cclxuICAgIC8vIHBvc2l0aW9ucyBtdXN0IGJlIHVuaWZpZWQsIGlmIHNpemVzIGFyZSB1bmlmaWVkXHJcbiAgICBsZXQgY2hlY2tQb3NpdGlvbnMgPSAobm9kZSwgcG9zID0gMCkgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdGhpcy5fb3B0cy51bmlmeVNpemUgfHxcclxuICAgICAgICB0aGlzLl9vcHRzLnVuaWZ5UG9zaXRpb24gfHxcclxuICAgICAgICAhbm9kZS5kYXRhUG9zIHx8XHJcbiAgICAgICAgKCEhbm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQuaWQgPT0gXCJmYWtlUm9vdFwiKVxyXG4gICAgICApXHJcbiAgICAgICAgbm9kZS5wb3MgPSBwb3M7XHJcbiAgICAgIGVsc2Ugbm9kZS5wb3MgPSBub2RlLmRhdGFQb3M7XHJcblxyXG4gICAgICBpZiAoISFub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCBhZ2dyZWdhdGUgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgIGFnZ3JlZ2F0ZSArPSBjaGlsZC5zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3BhY2luZyA9IChub2RlLnNpemUgLSBhZ2dyZWdhdGUpIC8gKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICsgMSk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IFtpLCBjaGlsZF0gb2Ygbm9kZS5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgIHBvcyArPSBzcGFjaW5nO1xyXG4gICAgICAgICAgY2hlY2tQb3NpdGlvbnMoY2hpbGQsIHBvcyk7XHJcbiAgICAgICAgICBwb3MgKz0gY2hpbGQuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fY2xlYXJTdHJlYW1JZHMoKTtcclxuICAgIGxldCB0aW1lID0gdGhpcy5fZGF0YS50aW1lc3RlcHM7XHJcbiAgICB0aGlzLl9tYXhWYWx1ZSA9IDA7XHJcbiAgICB0aGlzLl9tYXhUaW1lID0gMDtcclxuICAgIHRoaXMuX21pblRpbWUgPSBJbmZpbml0eTtcclxuICAgIGZvciAobGV0IHQgaW4gdGltZSkge1xyXG4gICAgICBjaGVja1NpemVzKHRpbWVbdF0udHJlZSk7XHJcbiAgICAgIGNoZWNrUG9zaXRpb25zKHRpbWVbdF0udHJlZSk7XHJcbiAgICAgIHRoaXMuX21heFZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWF4VmFsdWUsIHRpbWVbdF0udHJlZS5zaXplKTtcclxuICAgICAgdGhpcy5fbWluVGltZSA9IE1hdGgubWluKHRoaXMuX21pblRpbWUsICt0KTtcclxuICAgICAgdGhpcy5fbWF4VGltZSA9IE1hdGgubWF4KHRoaXMuX21heFRpbWUsICt0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9tYXhEZXB0aCA9IDA7XHJcbiAgICBsZXQgdHJhdmVyc2UgPSAobm9kZSwgZGVwdGgpID0+IHtcclxuICAgICAgdGhpcy5fbWF4RGVwdGggPSBNYXRoLm1heCh0aGlzLl9tYXhEZXB0aCwgZGVwdGgpO1xyXG4gICAgICBub2RlLmRlcHRoID0gZGVwdGgrKztcclxuICAgICAgbGV0IGlzTmV3ID0gdGhpcy5fZmluZFN0cmVhbUlkKG5vZGUpO1xyXG4gICAgICBpZiAoaXNOZXcpIHRoaXMuX3N0cmVhbURhdGEuYWRkKG5vZGUpO1xyXG5cclxuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbilcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdHJhdmVyc2UoY2hpbGQsIGRlcHRoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IGkgaW4gdGltZSkgdHJhdmVyc2UodGltZVtpXS50cmVlLCAwKTtcclxuICB9XHJcblxyXG4gIF9jYWxjdWxhdGVQb3NpdGlvbnMoKSB7XHJcbiAgICBsZXQgeyBoZWlnaHQsIHdpZHRoLCBtYXJnaW4sIG1pblNpemVUaHJlc2hvbGQsIG9mZnNldCB9ID0gdGhpcy5fb3B0cztcclxuXHJcbiAgICBsZXQgc2V0T2Zmc2V0ID0gcm9vdCA9PiB7XHJcbiAgICAgIGlmIChvZmZzZXQgPT0gXCJ6ZXJvXCIpIHtcclxuICAgICAgICByb290LnkwID0gMDtcclxuICAgICAgICByb290LnkxID0gcm9vdC5zaXplIC8gdGhpcy5fbWF4VmFsdWU7XHJcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09IFwiZXhwYW5kXCIpIHtcclxuICAgICAgICByb290LnkwID0gMDtcclxuICAgICAgICByb290LnkxID0gMTtcclxuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT0gXCJzaWxob3VldHRlXCIpIHtcclxuICAgICAgICByb290LnkwID0gMC41IC0gKDAuNSAqIHJvb3Quc2l6ZSkgLyB0aGlzLl9tYXhWYWx1ZTtcclxuICAgICAgICByb290LnkxID0gMC41ICsgKDAuNSAqIHJvb3Quc2l6ZSkgLyB0aGlzLl9tYXhWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgdHJhdmVyc2UgPSAobm9kZSwgY2hpbGRYID0gMCkgPT4ge1xyXG4gICAgICBsZXQgcCA9IG5vZGUucGFyZW50O1xyXG4gICAgICBpZiAoIXApIHtcclxuICAgICAgICBub2RlLm1hcmdpblggPSB0aGlzLl9vcHRzLnNwbGl0Um9vdCA/IHRoaXMuX3hTcGFjaW5nKG5vZGUpIDogMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub2RlLnggPSBwLng7XHJcbiAgICAgICAgbGV0IG51bU1hcmdpbnMgPSBwLmNoaWxkcmVuLmxlbmd0aCArIDE7XHJcbiAgICAgICAgbGV0IHNwYWNlID0gcC55MSAtIHAueTAgLSBudW1NYXJnaW5zICogcC5tYXJnaW5ZO1xyXG4gICAgICAgIGlmIChzcGFjZSA8PSAwKSB7XHJcbiAgICAgICAgICBub2RlLnkwID0gMC41ICogKHAueTAgKyBwLnkxKTtcclxuICAgICAgICAgIG5vZGUueTEgPSAwLjUgKiAocC55MCArIHAueTEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBub3JtYWxpemVcclxuICAgICAgICAgIG5vZGUucnBvcyA9IChub2RlLnBvcyAtIHAucG9zKSAvIHAuc2l6ZTtcclxuICAgICAgICAgIG5vZGUucnNpemUgPSBub2RlLnNpemUgLyBwLnNpemU7XHJcbiAgICAgICAgICBub2RlLnkwID0gcC55MCArIChjaGlsZFggKyAxKSAqIHAubWFyZ2luWSArIHNwYWNlICogbm9kZS5ycG9zO1xyXG4gICAgICAgICAgbm9kZS55MSA9IG5vZGUueTAgKyBzcGFjZSAqIG5vZGUucnNpemU7XHJcblxyXG4gICAgICAgICAgbGV0IHNpemUgPSBub2RlLnkxIC0gbm9kZS55MDtcclxuICAgICAgICAgIGlmIChzaXplIDw9IG1pblNpemVUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgbm9kZS55MCA9IDAuNSAqIChub2RlLnkwICsgbm9kZS55MSk7XHJcbiAgICAgICAgICAgIG5vZGUueTEgPSAwLjUgKiAobm9kZS55MCArIG5vZGUueTEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbm9kZS5tYXJnaW5YID0gcC5tYXJnaW5YICsgdGhpcy5feFNwYWNpbmcobm9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5vZGUubWFyZ2luWSA9IHRoaXMuX3lTcGFjaW5nKG5vZGUpO1xyXG5cclxuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbilcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpKSA9PiB0cmF2ZXJzZShjaGlsZCwgaSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgdGltZSA9IHRoaXMuX2RhdGEudGltZXN0ZXBzO1xyXG4gICAgZm9yIChsZXQgaSBpbiB0aW1lKSB7XHJcbiAgICAgIHRpbWVbaV0udHJlZS54ID0gK2k7XHJcbiAgICAgIHNldE9mZnNldCh0aW1lW2ldLnRyZWUpO1xyXG4gICAgICB0cmF2ZXJzZSh0aW1lW2ldLnRyZWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHRyZWVtYXBzIHJlcXVpcmUgMC41IHRpbWUgc3BhY2UgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSB0aW1lc3RlcFxyXG4gICAgdGhpcy5fc3RyZWFtRGF0YS54U2NhbGUgPSBkM1xyXG4gICAgICAuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAuZG9tYWluKFt0aGlzLl9taW5UaW1lIC0gMC41LCB0aGlzLl9tYXhUaW1lICsgMC41XSlcclxuICAgICAgLy8gLmRvbWFpbihbXHJcbiAgICAgIC8vICAgdGhpcy5fbWluVGltZSAtIDAuNSAqICgxIC0gdGhpcy5fb3B0cy5wcm9wb3J0aW9uKSxcclxuICAgICAgLy8gICB0aGlzLl9tYXhUaW1lICsgMC41ICogKDEgLSB0aGlzLl9vcHRzLnByb3BvcnRpb24pXHJcbiAgICAgIC8vIF0pXHJcbiAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHdpZHRoICogdGhpcy5fb3B0cy56b29tVGltZUZhY3RvciAtIG1hcmdpbi5yaWdodF0pO1xyXG5cclxuICAgIGxldCBkb21haW4gPSB0aGlzLl9vcHRzLm1pcnJvciA/IFsxLCAwXSA6IFswLCAxXTtcclxuICAgIHRoaXMuX3N0cmVhbURhdGEueVNjYWxlID0gZDNcclxuICAgICAgLnNjYWxlTGluZWFyKClcclxuICAgICAgLmRvbWFpbihkb21haW4pXHJcbiAgICAgIC5uaWNlKClcclxuICAgICAgLnJhbmdlKFtoZWlnaHQgLSBtYXJnaW4uYm90dG9tLCBtYXJnaW4udG9wXSk7XHJcbiAgICAvLy5yYW5nZShtYXJnaW4udG9wLCBoZWlnaHQgLSBtYXJnaW4uYm90dG9tKTtcclxuICB9XHJcblxyXG4gIHNldFJvb3ROb2RlQnlJZChJZCkge1xyXG4gICAgbGV0IHJvb3QgPSB0aGlzLl9zdHJlYW1EYXRhLnN0cmVhbXMuZmluZChkID0+IGQuaWQgPT0gaWQpO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgbGV0IGNvbG9yID0gdGhpcy5fY29sb3JSYW5kb21cclxuICAgICAgPyBnZXRSYW5kb21Db2xvclxyXG4gICAgICA6IHRoaXMuX2NvbG9yLmRvbWFpbihbdGhpcy5fbWF4RGVwdGgsIDBdKTtcclxuXHJcbiAgICBsZXQgc3RyZWFtc0J5RGVwdGggPSBkM1xyXG4gICAgICAubmVzdCgpXHJcbiAgICAgIC5rZXkoZCA9PiBkLmRlZXBlc3REZXB0aClcclxuICAgICAgLmVudHJpZXModGhpcy5fc3RyZWFtRGF0YS5zdHJlYW1zKTtcclxuXHJcbiAgICBsZXQgZGVwdGhMYXllcnMgPSB0aGlzLl9wYXRoQ29udGFpbmVyXHJcbiAgICAgIC5zZWxlY3RBbGwoXCJnLmRlcHRoTGF5ZXIgPiBnLmNsaXBMYXllclwiKVxyXG4gICAgICAuZGF0YShzdHJlYW1zQnlEZXB0aCwgZCA9PiB0aGlzLl9uYW1lICsgdGhpcy5fZGF0YXNldHNMb2FkZWQgKyBkLmtleSlcclxuICAgICAgLmpvaW4oZW50ZXIgPT5cclxuICAgICAgICBlbnRlclxyXG4gICAgICAgICAgLmFwcGVuZChcImdcIilcclxuICAgICAgICAgIC5jbGFzc2VkKFwiZGVwdGhMYXllclwiLCB0cnVlKVxyXG4gICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoXCJkZXB0aC1cIiArIGQua2V5KTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxyXG4gICAgICAgICAgLmNsYXNzZWQoXCJjbGlwTGF5ZXJcIiwgdHJ1ZSlcclxuICAgICAgKTtcclxuXHJcbiAgICAvLyAuYXR0cignY2xpcC1wYXRoJywgZCA9PiAndXJsKCNjbGlwJyArIGQua2V5ICsgJ3dyYXBwZXIpJyk7XHJcblxyXG4gICAgZGVwdGhMYXllcnNcclxuICAgICAgLnNlbGVjdEFsbChcInBhdGguc3RyZWFtXCIpXHJcbiAgICAgIC5kYXRhKGQgPT4gZC52YWx1ZXMsIGQgPT4gdGhpcy5fbmFtZSArIHRoaXMuX2RhdGFzZXRzTG9hZGVkICsgZC5pZClcclxuICAgICAgLmpvaW4oZW50ZXIgPT5cclxuICAgICAgICBlbnRlclxyXG4gICAgICAgICAgLmFwcGVuZChcInBhdGhcIilcclxuICAgICAgICAgIC5jbGFzc2VkKFwic3RyZWFtXCIsIHRydWUpXHJcbiAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgdGhpcy5fb25Nb3VzZU92ZXIpXHJcbiAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCB0aGlzLl9vbk1vdXNlT3V0KVxyXG4gICAgICAgICAgLmF0dHIoXCJjbGlwLXBhdGhcIiwgZCA9PiBcInVybCgjY2xpcFwiICsgZC5pZCArIHRoaXMuX25hbWUgKyBcIilcIilcclxuICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZCA9PiBcInN0cmVhbVwiICsgZC5pZCArIHRoaXMuX25hbWUpXHJcbiAgICAgICAgICAvLy5hdHRyKCdzdHJva2Utd2lkdGgnLCAzKVxyXG4gICAgICAgICAgLmF0dHIoXCJwYWludC1vcmRlclwiLCBcInN0cm9rZVwiKVxyXG4gICAgICApXHJcbiAgICAgIC5hdHRyKFwiZFwiLCBkID0+IGQucGF0aClcclxuICAgICAgLmF0dHIoXCJzaGFwZS1yZW5kZXJpbmdcIiwgdGhpcy5fb3B0cy5zaGFwZVJlbmRlcmluZylcclxuICAgICAgLmF0dHIoXHJcbiAgICAgICAgXCJmaWxsXCIsXHJcbiAgICAgICAgZCA9PiAoISFkLmRhdGEgPyBkLmRhdGEuY29sb3IgOiBudWxsKSB8fCBjb2xvcihkLmRlZXBlc3REZXB0aClcclxuICAgICAgICAvLyAnd2hpdGUnXHJcbiAgICAgIClcclxuICAgICAgLy8gcmVtb3ZlIGVtcHR5IHN0cmVhbXMgKHRoZXkgZG8gbm90IGluY2x1ZGUgYSBzaW5nbGUgYmV6aWVyIGN1cnZlKVxyXG4gICAgICAuZmlsdGVyKGQgPT4gZC5wYXRoLmluZGV4T2YoXCJDXCIpID09IC0xKVxyXG4gICAgICAucmVtb3ZlKCk7XHJcblxyXG4gICAgdGhpcy5zaG93TGFiZWxzKHRoaXMuX29wdHMuc2hvd0xhYmVscyk7XHJcbiAgICB0aGlzLmRyYXdTdHJva2UodGhpcy5fb3B0cy5kcmF3U3Ryb2tlKTtcclxuXHJcbiAgICBsZXQgc3BsaXREYXRhID0gdGhpcy5fc3ZnRmlsdGVyc1xyXG4gICAgICAuc2VsZWN0QWxsKFwiY2xpcFBhdGhcIilcclxuICAgICAgLmRhdGEoXHJcbiAgICAgICAgdGhpcy5fc3RyZWFtRGF0YS5jbGlwUGF0aHMsXHJcbiAgICAgICAgZCA9PiB0aGlzLl9uYW1lICsgdGhpcy5fZGF0YXNldHNMb2FkZWQgKyBkLmlkXHJcbiAgICAgICk7XHJcblxyXG4gICAgc3BsaXREYXRhXHJcbiAgICAgIC5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoXCJjbGlwUGF0aFwiKVxyXG4gICAgICAuYXR0cihcImlkXCIsIGQgPT4gXCJjbGlwXCIgKyBkLmlkICsgdGhpcy5fbmFtZSlcclxuICAgICAgLm1lcmdlKHNwbGl0RGF0YSlcclxuICAgICAgLmh0bWwoZCA9PiAnPHBhdGggZD1cIicgKyBkLnBhdGggKyAnXCI+Jyk7XHJcblxyXG4gICAgc3BsaXREYXRhLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICB0aGlzLl9hcHBseUZpbHRlcnMoKTtcclxuICB9XHJcblxyXG4gIHNob3dMYWJlbHMoc2hvdyA9IHRydWUpIHtcclxuICAgIHRoaXMuX29wdHMuc2hvd0xhYmVscyA9IHNob3c7XHJcbiAgICBsZXQgbGFiZWxEYXRhID0gdGhpcy5fb3B0cy5zaG93TGFiZWxzID8gdGhpcy5fc3RyZWFtRGF0YS5zdHJlYW1zIDogW107XHJcblxyXG4gICAgbGV0IGxhYmVscyA9IHRoaXMuX3RleHRDb250YWluZXJcclxuICAgICAgLnNlbGVjdEFsbChcInRleHRcIilcclxuICAgICAgLmRhdGEobGFiZWxEYXRhLCBkID0+IGQuaWQpO1xyXG5cclxuICAgIGxhYmVsc1xyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKFwidGV4dFwiKVxyXG4gICAgICAudGV4dChkID0+ICghIWQuZGF0YSA/IGQuZGF0YS50eXBlTGFiZWwgOiBkLmlkKSlcclxuICAgICAgLm1lcmdlKGxhYmVscylcclxuICAgICAgLmF0dHIoXCJ4XCIsIGQgPT4gZC50ZXh0UG9zLngpXHJcbiAgICAgIC5hdHRyKFwieVwiLCBkID0+IGQudGV4dFBvcy55KTtcclxuXHJcbiAgICBsYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xyXG4gIH1cclxuXHJcbiAgZHJhd1N0cm9rZShkcmF3ID0gdHJ1ZSkge1xyXG4gICAgdGhpcy5fb3B0cy5kcmF3U3Ryb2tlID0gZHJhdztcclxuICAgIGxldCBjb2xvciA9IHRoaXMuX29wdHMuZHJhd1N0cm9rZSA/IFwiYmxhY2tcIiA6IG51bGw7XHJcbiAgICB0aGlzLl9wYXRoQ29udGFpbmVyLmF0dHIoXCJzdHJva2VcIiwgY29sb3IpO1xyXG4gICAgdGhpcy5fcGF0aENvbnRhaW5lci5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDMpO1xyXG4gICAgLy8gZDMuc2VsZWN0QWxsKCdwYXRoJykuYXR0cignc3Ryb2tlLXdpZHRoJywgMC4wMDEpXHJcbiAgfVxyXG5cclxuICBfYXBwbHlGaWx0ZXJzKCkge1xyXG4gICAgaWYgKCF0aGlzLl9maWx0ZXJzKSByZXR1cm47XHJcblxyXG4gICAgbGV0IGZpbHRlcnMgPSBbXTtcclxuICAgIGZvciAobGV0IGZpbHRlciBvZiB0aGlzLl9maWx0ZXJzKVxyXG4gICAgICBmaWx0ZXJzLnB1c2goZmlsdGVyLnR5cGUsIHtcclxuICAgICAgICBjb2xvcjogXCJibGFja1wiLFxyXG4gICAgICAgIGR4OiBmaWx0ZXIuZHgsXHJcbiAgICAgICAgZHk6IGZpbHRlci5keSxcclxuICAgICAgICBibHVyOiBmaWx0ZXIuc3RkRGV2aWF0aW9uXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl9vcHRzLmZpbHRlck1vZGUgPT0gXCJmYXN0XCIpXHJcbiAgICAgIGQzLnNlbGVjdEFsbChcIi5kZXB0aExheWVyXCIpLnN2Z0ZpbHRlciguLi5maWx0ZXJzKTtcclxuICAgIGVsc2UgaWYgKHRoaXMuX29wdHMuZmlsdGVyTW9kZSA9PSBcImFjY3VyYXRlXCIpXHJcbiAgICAgIGQzLnNlbGVjdEFsbChcInBhdGguc3RyZWFtXCIpLnN2Z0ZpbHRlciguLi5maWx0ZXJzKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZSgpIHtcclxuICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcclxuICB9XHJcbiAgX3VwZGF0ZShtYW51YWxseVRyaWdnZXJlZCA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXRoaXMuX2RhdGEpIHJldHVybjtcclxuXHJcbiAgICBpZiAoIXRoaXMuX29wdHMuYXV0b21hdGljVXBkYXRlKSBpZiAoIW1hbnVhbGx5VHJpZ2dlcmVkKSByZXR1cm47XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJ1cGRhdGVcIik7XHJcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICB0aGlzLl9ub3JtYWxpemVEYXRhKCk7XHJcbiAgICB0aGlzLl9hcHBseU9yZGVyaW5nKCk7XHJcbiAgICB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbnMoKTtcclxuXHJcbiAgICAvLyB0aGlzLl9zdHJlYW1EYXRhLnByZXByb2Nlc3MoKTtcclxuICAgIHRoaXMuX3N0cmVhbURhdGEuY2FsY3VsYXRlUGF0aHMoKTtcclxuICAgIHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXHJcbiAgICAgIFwiVElNSU5HOiBcIiArIHRoaXMuX2RhdGEubnVtTm9kZXMgKyBcIixcIiArIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHJlc2l6ZShcclxuICAgIHdpZHRoID0gdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG4gICAgaGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodFxyXG4gICkge1xyXG4gICAgdGhpcy5fb3B0cy53aWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5fb3B0cy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB0aGlzLl9zdmcuYXR0cihcIndpZHRoXCIsIHdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICB5U3BhY2luZ0ZpeGVkKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLl9vcHRzLnlNYXJnaW4gLyA0O1xyXG4gIH1cclxuXHJcbiAgeVNwYWNpbmdQZXJjZW50YWdlKG5vZGUpIHtcclxuICAgIHJldHVybiAoKG5vZGUueTEgLSBub2RlLnkwKSAqIHRoaXMuX29wdHMueU1hcmdpbikgLyAyO1xyXG4gIH1cclxuXHJcbiAgeVNwYWNpbmdIaWVyYXJjaGljYWwobm9kZSkge1xyXG4gICAgcmV0dXJuICgobm9kZS5kZXB0aCArIDEpICogdGhpcy5fb3B0cy55TWFyZ2luKSAvIDQ7XHJcbiAgfVxyXG5cclxuICB5U3BhY2luZ0hpZXJhcmNoaWNhbFJldmVyc2Uobm9kZSkge1xyXG4gICAgcmV0dXJuICgoMSAvIChub2RlLmRlcHRoICsgMSkpICogdGhpcy5fb3B0cy55TWFyZ2luKSAvIDQ7XHJcbiAgfVxyXG5cclxuICB4U3BhY2luZ0ZpeGVkKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLl9vcHRzLnhNYXJnaW4gLyAxMDtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IHVzZSB0aGUgbWF4IGRlcHRoIGF0IHRoYXQgdGltZXBvaW50IGluc3RlYWRcclxuICB4U3BhY2luZ0hpZXJhcmNoaWNhbChub2RlKSB7XHJcbiAgICByZXR1cm4gKChub2RlLmRlcHRoICsgMSkgLyB0aGlzLl9tYXhEZXB0aCkgKiB0aGlzLl9vcHRzLnhNYXJnaW47XHJcbiAgfVxyXG5cclxuICB4U3BhY2luZ0hpZXJhcmNoaWNhbFJldmVyc2Uobm9kZSkge1xyXG4gICAgcmV0dXJuICgxIC8gKG5vZGUuZGVwdGggKyAxKSkgKiB0aGlzLl9vcHRzLnhNYXJnaW47XHJcbiAgfVxyXG5cclxuICBhZGRTcGxpdHMoc3BsaXRzKSB7XHJcbiAgICB0aGlzLl9zdHJlYW1EYXRhLmFkZFNwbGl0cyhzcGxpdHMpO1xyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgfVxyXG5cclxuICBhZGRTcGxpdHNBdFRpbWVwb2ludHMoKSB7XHJcbiAgICBsZXQgc3BsaXRzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gdGhpcy5fbWluVGltZTsgaSA8PSB0aGlzLl9tYXhUaW1lOyBpKyspIHNwbGl0cy5wdXNoKGkpO1xyXG4gICAgdGhpcy5hZGRTcGxpdHMoc3BsaXRzKTtcclxuICB9XHJcblxyXG4gIGFkZFNwbGl0c0JldHdlZW5UaW1lcG9pbnRzKCkge1xyXG4gICAgbGV0IHNwbGl0cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX21pblRpbWUgLSAxOyBpIDw9IHRoaXMuX21heFRpbWU7IGkrKylcclxuICAgICAgc3BsaXRzLnB1c2goaSArIDAuNSk7XHJcbiAgICB0aGlzLmFkZFNwbGl0cyhzcGxpdHMpO1xyXG4gIH1cclxuXHJcbiAgYWRkU3BsaXRzUmFuZG9tbHkobnVtID0gMSkge1xyXG4gICAgbGV0IHQwID0gdGhpcy5fbWluVGltZSAtIDE7XHJcbiAgICBsZXQgdDEgPSB0aGlzLl9tYXhUaW1lICsgMTtcclxuICAgIGxldCBzcGxpdHMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcclxuICAgICAgbGV0IHIgPSB0MCArIE1hdGgucmFuZG9tKCkgKiAodDEgLSB0MCk7XHJcbiAgICAgIHNwbGl0cy5wdXNoKHIudG9TdHJpbmcoKSk7XHJcbiAgICAgIHNwbGl0cy5zb3J0KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFkZFNwbGl0cyhzcGxpdHMpO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlU3BsaXRzKHNwbGl0cykge1xyXG4gICAgdGhpcy5fc3RyZWFtRGF0YS5yZW1vdmVTcGxpdHMoc3BsaXRzKTtcclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gc3RhdGljIGV4dGVuZCguLi5hcmdzKSB7XHJcbiAgLy8gICAgIHRoaXMubXlOZXdGdW5jdGlvblxyXG4gIC8vIH1cclxuICAvLyBleHRlbmQoLi4uYXJncykge1xyXG4gIC8vICAgICByZXR1cm4gU3BsaXRTdHJlYW0uZXh0ZW5kKC4uLmFyZ3MpO1xyXG4gIC8vIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/SplitStream.js\n'
          );

          /***/
        },

      /***/ './src/SplitStreamData.js':
        /*!********************************!*\
  !*** ./src/SplitStreamData.js ***!
  \********************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStreamData; });\n/* harmony import */ var _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SvgPath.js */ \"./src/SvgPath.js\");\n\r\n\r\nclass SplitStreamData {\r\n  // array of streams\r\n  // every stream has a unique ID\r\n  // every stream contains references to all nodes which belong to that stream\r\n\r\n  // if parent never changes, draw stream after parent\r\n  // if parent changes, draw after both parents.\r\n  // if special case, split path in 2 and draw before and after\r\n  constructor() {\r\n    this._streamNodes = [];\r\n    this._streams = [];\r\n    this._splits = {};\r\n    this._xScale = d => d;\r\n    this._yScale = d => d;\r\n    this._proportion = 1;\r\n\r\n    this._xCurve = 'bezier'; // linear, bezier\r\n    this._startEnd = {\r\n      encoding: 'plug', // circle, plug, default\r\n      x: 0.85,\r\n      y: 0\r\n    };\r\n  }\r\n\r\n  get streams() {\r\n    return this._streams;\r\n  }\r\n  get clipPaths() {\r\n    return this._clipPaths;\r\n  }\r\n  get splits() {\r\n    return Object.keys(this._splits);\r\n  }\r\n\r\n  set xScale(callback) {\r\n    this._xScale = callback;\r\n  }\r\n  set yScale(callback) {\r\n    this._yScale = callback;\r\n  }\r\n  set startEndEncoding(encoding) {\r\n    this._startEnd.encoding = encoding;\r\n  }\r\n  set startEndEncodingX(x) {\r\n    this._startEnd.x = x;\r\n  }\r\n  set startEndEncodingY(y) {\r\n    this._startEnd.y = y;\r\n  }\r\n  set proportion(p) {\r\n    this._proportion = p;\r\n  }\r\n\r\n  add(node) {\r\n    this._streamNodes.push(node);\r\n  }\r\n\r\n  // extract special operations (splits, merges, parentSwap) from the data and treat it extra\r\n  preprocess() {\r\n    let mergeNodes = [];\r\n    let splitNodes = [];\r\n    let parentSwaps = [];\r\n    let newStreams = [];\r\n\r\n    // cut connection between node and previous nodes\r\n    let cutPrevious = node => {\r\n      if (!!node.prev) {\r\n        for (let prev of node.prev) {\r\n          if (prev.next.length == 1) prev.next = undefined;\r\n          else prev.next.splice(prev.next.indexOf(node), 1);\r\n        }\r\n      }\r\n    };\r\n\r\n    // cut connection between node and next nodes\r\n    let cutNext = node => {\r\n      if (!!node.next) {\r\n        for (let next of node.next) {\r\n          if (next.prev.length == 1) next.prev = undefined;\r\n          else next.prev.splice(next.prev.indexOf(node), 1);\r\n        }\r\n      }\r\n    };\r\n\r\n    let traverse = node => {\r\n      if (!!node.next) for (let next of node.next) traverse(next);\r\n\r\n      // split nodes\r\n      if (!!node.next && node.next.length > 1) {\r\n        splitNodes.push(node);\r\n        cutNext(node);\r\n        // create new streams from here\r\n        newStreams.push({ ...node.next });\r\n\r\n        // end stream here\r\n        node.next = undefined;\r\n      }\r\n\r\n      // merge nodes\r\n      if (!!node.prev && node.prev.length > 1) {\r\n        mergeNodes.push(node);\r\n        endPrevious(node);\r\n\r\n        node.prev = undefined;\r\n        this.newStreams.push(node);\r\n      }\r\n\r\n      // parent swap\r\n      if (!!node.next) {\r\n        for (let next of node.next) {\r\n          // only consider nodes whos parents change\r\n          // 1. node becomes root node (parent changes from defined to undefined)\r\n          // 2. parent id changes (TODO: make sure that this case is not handled twice, because both node's parents change)\r\n          if (\r\n            (!node.parent && !!next.parent) ||\r\n            (!!node.parent && !!next.parent && node.parent.id != next.parent.id)\r\n          ) {\r\n            // check if next.parent had node as an ancestor in the previous step\r\n\r\n            if (!!next.parent.prev) {\r\n              for (let prev of next.parent.prev) {\r\n                let isAncestor = false;\r\n                let p = prev;\r\n                while (p && !isAncestor) {\r\n                  if (p.id == node.id) isAncestor = true;\r\n                  else p = p.parent;\r\n                }\r\n                if (isAncestor) {\r\n                  endPrevious(prev);\r\n                  if (!!prev.next) addFollowing(prev.next);\r\n                  parentSwaps.push({\r\n                    node: { ...prev },\r\n                    next: { ...next.parent }\r\n                  });\r\n                  prev.next = undefined;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    // draw special case for node \"p\" and all its children, as well as node\r\n\r\n    // loop in reverse, because elements are added and deleted\r\n    for (let i = this._streamNodes.length - 1; i >= 0; i--) {\r\n      traverse(this._streamNodes[i]);\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this._streamNodes = [];\r\n    this._streams = [];\r\n    this._clipPaths = [];\r\n  }\r\n\r\n  addSplits(splits) {\r\n    if (Array.isArray(splits))\r\n      splits.forEach(d => {\r\n        this._splits[d] = true;\r\n      });\r\n    else this._splits[d] = true;\r\n  }\r\n\r\n  removeSplits(splits) {\r\n    if (!splits) this._splits = {};\r\n    else\r\n      splits.forEach(d => {\r\n        this._splits[d].remove();\r\n      });\r\n  }\r\n\r\n  //TODO: find more elaborate solution\r\n  _findSplits(t0, t1) {\r\n    let splits = [];\r\n    for (let split in this._splits) {\r\n      if (split >= t0 && split <= t1) splits.push(+split);\r\n    }\r\n    return splits;\r\n  }\r\n\r\n  _findClosestNode(stream, x) {\r\n    let traverseTime = function(node) {\r\n      let distance = Math.abs(node.x - x);\r\n      if (distance < minDistance) {\r\n        minDistance = distance;\r\n        closestNode = node;\r\n        // if distance is greater than minDistance, it will only increase with following nodes\r\n        if (!!node.next) {\r\n          node.next.forEach(traverseTime);\r\n        }\r\n      }\r\n    };\r\n    let minDistance = Infinity;\r\n    let closestNode;\r\n    traverseTime(stream);\r\n    return closestNode;\r\n  }\r\n\r\n  // WARNING: work in process\r\n  _checkForNullStreams() {\r\n    for (let i = 0; i < this._streamNodes.length; i++) {\r\n      let isNull = true;\r\n\r\n      let traverse = node => {\r\n        if (node.y1 - node.y0 > 0) {\r\n          isNull = false;\r\n          return;\r\n        }\r\n\r\n        if (!!node.next) node.next.forEach(traverse);\r\n      };\r\n\r\n      traverse(this._streamNodes[i]);\r\n\r\n      if (isNull) {\r\n        delete this._streamNodes[i]; //delete stream;\r\n        i--;\r\n      }\r\n    }\r\n  }\r\n\r\n  _drawStart(path, node) {\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    // extend to left\r\n    d.move(x(node.x), y(node.y1));\r\n\r\n    // don't draw start for zero values\r\n    if (node.y1 - node.y0 <= 0) return;\r\n\r\n    let t = node.x - 0.5 * (1 - prop);\r\n    d.horizontal(x(t));\r\n\r\n    // connect top and bottom\r\n    let root = node;\r\n    while (!!root.parent) root = root.parent;\r\n\r\n    if (!root.prev) {\r\n      // make first timestep flat\r\n      d.vertical(y(node.y0));\r\n    } else {\r\n      if (this._startEnd.encoding == 'circle') this._drawStartCircle(d, node);\r\n      else if (this._startEnd.encoding == 'plug') this._drawStartPlug(d, node);\r\n      else this._drawStartDefault(d, node);\r\n    }\r\n\r\n    // connect back\r\n    d.horizontal(x(node.x));\r\n  }\r\n\r\n  _drawEnd(path, node) {\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    if (node.y1 - node.y0 <= 0) return;\r\n\r\n    // extend to right\r\n    let t = node.x + 0.5 * (1 - prop);\r\n    d.horizontal(x(t));\r\n\r\n    // connect bottom and top\r\n    let root = node;\r\n    while (!!root.parent) root = root.parent;\r\n    if (!root.next) {\r\n      // make last timestep flat\r\n      d.vertical(y(node.y1));\r\n    } else {\r\n      if (this._startEnd.encoding == 'circle') this._drawEndCircle(d, node);\r\n      else if (this._startEnd.encoding == 'plug') this._drawEndPlug(d, node);\r\n      else this._drawEndDefault(d, node);\r\n    }\r\n\r\n    // connect back\r\n    d.horizontal(x(node.x));\r\n  }\r\n\r\n  _drawStartDefault(path, node) {\r\n    // insert node\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    // find position to insert node\r\n    let pos;\r\n    // find the oldest parent of node, which does not exist in the previous step\r\n    let parentNoPrev = node;\r\n    while (!!parentNoPrev.parent && !parentNoPrev.parent.prev)\r\n      parentNoPrev = parentNoPrev.parent;\r\n\r\n    // p is an ancestor who existed in the previous timestep\r\n    let p = parentNoPrev.parent;\r\n    if (!p) {\r\n      d.vertical(y(node.y0));\r\n    } else {\r\n      // use the center of the stream as reference point\r\n      let mid = 0.5 * (parentNoPrev.y0 + parentNoPrev.y1);\r\n\r\n      // if the nodes parent has multiple previous nodes, find the one closest to mid\r\n      let refPrevId = -1;\r\n      for (let n = 0; n < p.prev.length && refPrevId == -1; n++) {\r\n        let prev = p.prev[n];\r\n        // if mid lies within a prev node\r\n        if (prev.y0 <= mid && prev.y1 >= mid) {\r\n          // if node has children\r\n          if (!!prev.children && prev.children.length > 0) {\r\n            let refChildId = -1; // find two children to put the mid in between\r\n            for (let i = 0; i < prev.children.length && refChildId == -1; i++) {\r\n              let child = prev.children[i];\r\n              if (mid <= 0.5 * (child.y0 + child.y1)) refChildId = i; // setting ID breaks the loop\r\n            }\r\n            if (refChildId == 0)\r\n              // before first child\r\n              pos = 0.5 * (prev.y0 + prev.children[0].y0);\r\n            else if (refChildId == -1)\r\n              // after last child\r\n              pos =\r\n                0.5 * (prev.y1 + prev.children[prev.children.length - 1].y1);\r\n            else\r\n              pos =\r\n                0.5 *\r\n                (prev.children[refChildId - 1].y1 +\r\n                  prev.children[refChildId].y0);\r\n          } // node has no children\r\n          else pos = 0.5 * (prev.y0 + prev.y1);\r\n          refPrevId = -2; // setting ID breaks the loop\r\n        }\r\n        // if it lies outside, find two nodes to put it inbetween\r\n        else {\r\n          if (mid <= 0.5 * (prev.y0 + prev.y1)) refPrevId = n; // setting ID breaks the loop\r\n        }\r\n      }\r\n\r\n      if (refPrevId != -2) {\r\n        // if -2, then pos was already set\r\n        let node; // define the node to draw inside\r\n        let first; // boolean to define if it should be drawn before the first or after the last child\r\n        if (refPrevId == 0) {\r\n          // before first child\r\n          node = p.prev[0];\r\n          first = true;\r\n        } else if (refPrevId == -1) {\r\n          // after last child\r\n          node = p.prev[p.prev.length - 1];\r\n          first = false;\r\n        } else {\r\n          // find which node is closer\r\n          if (\r\n            Math.abs(p.prev[refPrevId].y0 - mid) <\r\n            Math.abs(p.prev[refPrevId - 1].y1)\r\n          ) {\r\n            node = p.prev[refPrevId];\r\n            first = true;\r\n          } else {\r\n            node = p.prev[refPrevId - 1];\r\n            first = false;\r\n          }\r\n        }\r\n\r\n        if (!!node.children && node.children.length > 0) {\r\n          if (first) pos = 0.5 * (node.y0 + node.children[0].y0);\r\n          else\r\n            pos = 0.5 * (node.y1 + node.children[node.children.length - 1].y1);\r\n        } else pos = 0.5 * (node.y0 + node.y1);\r\n      }\r\n\r\n      let tdiff = node.x - p.prev[0].x;\r\n      let t0 = node.x - 0.5 * (1 - prop) * tdiff;\r\n      let t1 = t0 - 0.5 * prop * tdiff;\r\n\r\n      if (this._xCurve == 'linear') {\r\n        d.line(x(p.prev[0].x), y(pos));\r\n        d.line(x(t0), y(node.y0));\r\n      } else if (this._xCurve == 'bezier') {\r\n        d.bezier(x(t1), y(node.y1), x(t1), y(pos), x(p.prev[0].x), y(pos));\r\n        d.bezier(x(t1), y(pos), x(t1), y(node.y0), x(t0), y(node.y0));\r\n      }\r\n    }\r\n  }\r\n\r\n  _drawEndDefault(path, node) {\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    // find position to delete node to\r\n    let pos;\r\n    // find the oldest parent of node, which does not exist in the next step\r\n    let parentNoNext = node;\r\n    while (!!parentNoNext.parent && !parentNoNext.parent.next)\r\n      parentNoNext = parentNoNext.parent; // p is the oldest parent of node, which does not exist in the next step\r\n\r\n    // p is an ancestor who exists in the next timestep\r\n    let p = parentNoNext.parent;\r\n    if (!p) {\r\n      d.vertical(y(node.y1));\r\n    } else {\r\n      // use the center of the stream as reference point\r\n      let mid = 0.5 * (parentNoNext.y0 + parentNoNext.y1);\r\n      // if the nodes parent has multiple next nodes, find the one closest to mid\r\n      let refNextId = -1;\r\n      for (let n = 0; n < p.next.length && refNextId == -1; n++) {\r\n        let next = p.next[n];\r\n        // if mid lies within a next node\r\n        if (next.y0 <= mid && next.y1 >= mid) {\r\n          // if node has children\r\n          if (!!next.children && next.children.length > 0) {\r\n            let refChildId = -1; // find two children to put the mid in between\r\n            for (let i = 0; i < next.children.length && refChildId == -1; i++) {\r\n              let child = next.children[i];\r\n              if (mid <= 0.5 * (child.y0 + child.y1)) refChildId = i; // setting ID breaks the loop\r\n            }\r\n            if (refChildId == 0)\r\n              // before first child\r\n              pos = 0.5 * (next.y0 + next.children[0].y0);\r\n            else if (refChildId == -1)\r\n              // after last child\r\n              pos =\r\n                0.5 * (next.y1 + next.children[next.children.length - 1].y1);\r\n            else\r\n              pos =\r\n                0.5 *\r\n                (next.children[refChildId - 1].y1 +\r\n                  next.children[refChildId].y0);\r\n          } // node has no children\r\n          else pos = 0.5 * (next.y0 + next.y1);\r\n          refNextId = -2; // setting ID breaks the loop\r\n        }\r\n        // if it lies outside, find two nodes to put it inbetween\r\n        else {\r\n          if (mid <= 0.5 * (next.y0 + next.y1)) refNextId = n; // setting ID breaks the loop\r\n        }\r\n      }\r\n\r\n      if (refNextId != -2) {\r\n        // if -2, then pos was already set\r\n        let node; // define the node to draw inside\r\n        let first; // boolean to define if it should be drawn before the first or after the last child\r\n        if (refNextId == 0) {\r\n          // before first child\r\n          node = p.next[0];\r\n          first = true;\r\n        } else if (refNextId == -1) {\r\n          // after last child\r\n          node = p.next[p.next.length - 1];\r\n          first = false;\r\n        } else {\r\n          // find which node is closer\r\n          if (\r\n            Math.abs(p.next[refNextId].y0 - mid) <\r\n            Math.abs(p.next[refNextId - 1].y1)\r\n          ) {\r\n            node = p.next[refNextId];\r\n            first = true;\r\n          } else {\r\n            node = p.next[refNextId - 1];\r\n            first = false;\r\n          }\r\n        }\r\n\r\n        if (!!node.children && node.children.length > 0) {\r\n          if (first) pos = 0.5 * (node.y0 + node.children[0].y0);\r\n          else\r\n            pos = 0.5 * (node.y1 + node.children[node.children.length - 1].y1);\r\n        } else pos = 0.5 * (node.y0 + node.y1);\r\n      }\r\n\r\n      let tdiff = p.next[0].x - node.x;\r\n      let t0 = node.x + 0.5 * (1 - prop) * tdiff;\r\n      let t1 = t0 + 0.5 * prop * tdiff;\r\n\r\n      if (this._xCurve == 'linear') {\r\n        d.line(x(p.next[0].x), y(pos));\r\n        d.line(x(t0), y(node.y1));\r\n      } else if (this._xCurve == 'bezier') {\r\n        d.bezier(x(t1), y(node.y0), x(t1), y(pos), x(p.next[0].x), y(pos));\r\n        d.bezier(x(t1), y(pos), x(t1), y(node.y1), x(t0), y(node.y1));\r\n      }\r\n    }\r\n  }\r\n\r\n  _drawStartCircle(path, node) {\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    let height = node.y1 - node.y0;\r\n    let t = node.x - 0.5 * (1 - prop);\r\n    d.move(x(t), y(node.y1));\r\n    //d.arc(Math.log(height), 1, 0, 0, 0, x(node.x), y(node.y0));\r\n    d.arc(prop, 1, 0, 0, 0, x(t), y(node.y0));\r\n  }\r\n\r\n  _drawEndCircle(path, node) {\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    let height = node.y1 - node.y0;\r\n    let t = node.x + 0.5 * (1 - prop);\r\n    //d.arc(Math.log(height), 1, 0, 0, 0, x(node.x), y(node.y1));\r\n    d.arc(prop, 1, 0, 0, 0, x(t), y(node.y1));\r\n  }\r\n\r\n  _drawStartPlug(path, node) {\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    let t = node.x - 0.5 * (1 - prop);\r\n    let height = node.y1 - node.y0;\r\n    d.bezier(\r\n      x(t - prop * this._startEnd.x * Math.sqrt(height)),\r\n      y(node.y1 + this._startEnd.y * height),\r\n      x(t - prop * this._startEnd.x * Math.sqrt(height)),\r\n      y(node.y0 - this._startEnd.y * height),\r\n      x(t),\r\n      y(node.y0)\r\n    );\r\n  }\r\n\r\n  _drawEndPlug(path, node) {\r\n    const d = path,\r\n      prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n\r\n    let t = node.x + 0.5 * (1 - prop);\r\n    let height = node.y1 - node.y0;\r\n    d.bezier(\r\n      x(t + prop * this._startEnd.x * Math.sqrt(height)),\r\n      y(node.y0 - this._startEnd.y * height),\r\n      x(t + prop * this._startEnd.x * Math.sqrt(height)),\r\n      y(node.y1 + this._startEnd.y * height),\r\n      x(t),\r\n      y(node.y1)\r\n    );\r\n  }\r\n\r\n  calculatePaths() {\r\n    //this._checkForNullStreams();\r\n\r\n    const prop = this._proportion,\r\n      x = this._xScale,\r\n      y = this._yScale;\r\n    let d, lastTimepoint, deepestDepth, largestSize; // find the deepest depth each stream has over the whole timeseries\r\n\r\n    let drawLine = (t1, t2, t3, ySource, yDest) => {\r\n      let t12 = 0.5 * (t1 + t2); // mid between t1 and t2\r\n      d.horizontal(t1);\r\n      if (this._xCurve == 'linear') {\r\n        d.line(t2, y(yDest));\r\n      } else if (this._xCurve == 'bezier') {\r\n        d.bezier(t12, y(ySource), t12, y(yDest), t2, y(yDest));\r\n      }\r\n      d.horizontal(t3);\r\n    };\r\n\r\n    let traverse = node => {\r\n      if (node.x > lastTimepoint) lastTimepoint = node.x;\r\n\r\n      if (node.depth > deepestDepth) deepestDepth = node.depth;\r\n      if (node.size > largestSize) largestSize = node.size;\r\n\r\n      if (!!node.next) {\r\n        let dt = node.next[0].x - node.x;\r\n        let t0 = x(node.x);\r\n        let t1 = x(node.x + 0.5 * (1 - prop) * dt);\r\n        let t2 = x(node.next[0].x - 0.5 * (1 - prop) * dt);\r\n        let t3 = x(node.next[0].x);\r\n\r\n        for (let i = 0; i < node.next.length; i++) {\r\n          let y0 = node.y0;\r\n          let y1 = node.y1;\r\n          let dest = node.next[i];\r\n\r\n          // don't draw anything for streams with zero height\r\n          if (y1 - y0 <= 0 && dest.y1 - dest.y0 <= 0) {\r\n            d.move(t3, y(dest.y0));\r\n            traverse(dest);\r\n            d.move(t0, y(y0));\r\n          } else {\r\n            drawLine(t1, t2, t3, y0, dest.y0); // bottom line (forwards)\r\n            traverse(dest);\r\n            drawLine(t2, t1, t0, dest.y1, y1); // top line (backwards)\r\n          }\r\n        }\r\n      } else this._drawEnd(d, node);\r\n    };\r\n\r\n    for (let stream of this._streamNodes) {\r\n      d = new _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n      // reset before new values are found by traverse\r\n      lastTimepoint = 0;\r\n      deepestDepth = 0;\r\n      largestSize = 0;\r\n\r\n      this._drawStart(d, stream);\r\n      traverse(stream);\r\n      //d.close();\r\n\r\n      // add splits\r\n\r\n      let clipPath = new _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n      let splits = this._findSplits(stream.x - 0.5, lastTimepoint + 0.5);\r\n\r\n      let clipStart = x(-1);\r\n      let y0 = y(0);\r\n      let y1 = y(1);\r\n      for (let split of splits) {\r\n        // we move by 0.0001 to avoid cases in which the split is in the middle of 2 nodes\r\n        let clipEnd = x(\r\n          split - 0.5 * this._findClosestNode(stream, split - 0.0001).marginX\r\n        );\r\n\r\n        if (clipEnd - clipStart > 0) {\r\n          clipPath.move(clipStart, y0);\r\n          clipPath.horizontal(clipEnd);\r\n          clipPath.vertical(y1);\r\n          /*let dist = y1-y0;\r\n          let zigzags = 300;\r\n          let zigzagWidth = 5;\r\n          for (let z = 0; z < zigzags; z++) {\r\n              let dir = (z % 2 * 2 - 1);\r\n              clipPath.lineD(dir * zigzagWidth, dist/zigzags)\r\n          }*/\r\n\r\n          clipPath.horizontal(clipStart);\r\n          clipPath.vertical(y0);\r\n          /*for (let z = 0; z < zigzags; z++) {\r\n              let dir = (z % 2 * 2 - 1);\r\n              clipPath.lineD(dir * zigzagWidth, -dist/zigzags)\r\n          }*/\r\n        }\r\n        clipStart = x(\r\n          split + 0.5 * this._findClosestNode(stream, split + 0.0001).marginX\r\n        );\r\n      }\r\n      clipPath.move(clipStart, y0);\r\n      clipPath.horizontal(x(lastTimepoint + 1));\r\n      clipPath.vertical(y1);\r\n      clipPath.horizontal(clipStart);\r\n      clipPath.vertical(y0);\r\n\r\n      this._clipPaths.push({\r\n        id: stream.streamId,\r\n        path: clipPath.get()\r\n      });\r\n\r\n      // find position to put a text label\r\n      let textPos;\r\n      if (Math.abs(y(stream.y1) - y(stream.y0)) < 25) textPos = -1;\r\n      else {\r\n        if (y(stream.y1) > y(stream.y0)) textPos = y(stream.y0) + 15;\r\n        else textPos = y(stream.y1) + 15;\r\n      }\r\n\r\n      let streamObj = {\r\n        path: d.get(),\r\n        depth: stream.depth,\r\n        deepestDepth: deepestDepth,\r\n        largestSize: largestSize,\r\n        id: stream.streamId,\r\n        data: stream.data,\r\n        textPos: {\r\n          x: x(stream.x - 0.5 * (1 - this._proportion) + 0.5 * stream.marginX),\r\n          y: textPos\r\n        }\r\n      };\r\n\r\n      this._streams.push(streamObj);\r\n      // if (!this._streams[stream.depth])\r\n      //     this._streams[stream.depth] = [];\r\n      // this._streams[stream.depth].push(streamObj);\r\n    }\r\n\r\n    // WARNING: This was a fix for: \"if stream IDs are strings, the clipPath array has an empty value in the beginning --> remove\"\r\n    // But instead it just removes all clipPaths which have string as an ID\r\n    //this._clipPaths = this._clipPaths.filter(d => d);\r\n\r\n    // TODO: apply an order in which children are drawn correctly\r\n    // this._streams.sort((a,b) => (a.depth < b.depth) ? -1 : 1)\r\n    this._streams.sort((a, b) => (a.deepestDepth < b.deepestDepth ? -1 : 1));\r\n    //this._streams.sort((a,b) => a.id < b.id ? -1: 1)\r\n    //this._streams.reverse();\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1EYXRhLmpzP2UwMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQW1DOztBQUVwQjtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckMsMkJBQTJCO0FBQzNCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCw4Q0FBOEM7QUFDOUM7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGNBQWMsbURBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QixtREFBTztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3BsaXRTdHJlYW1EYXRhLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN2Z1BhdGggZnJvbSAnLi9TdmdQYXRoLmpzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0U3RyZWFtRGF0YSB7XHJcbiAgLy8gYXJyYXkgb2Ygc3RyZWFtc1xyXG4gIC8vIGV2ZXJ5IHN0cmVhbSBoYXMgYSB1bmlxdWUgSURcclxuICAvLyBldmVyeSBzdHJlYW0gY29udGFpbnMgcmVmZXJlbmNlcyB0byBhbGwgbm9kZXMgd2hpY2ggYmVsb25nIHRvIHRoYXQgc3RyZWFtXHJcblxyXG4gIC8vIGlmIHBhcmVudCBuZXZlciBjaGFuZ2VzLCBkcmF3IHN0cmVhbSBhZnRlciBwYXJlbnRcclxuICAvLyBpZiBwYXJlbnQgY2hhbmdlcywgZHJhdyBhZnRlciBib3RoIHBhcmVudHMuXHJcbiAgLy8gaWYgc3BlY2lhbCBjYXNlLCBzcGxpdCBwYXRoIGluIDIgYW5kIGRyYXcgYmVmb3JlIGFuZCBhZnRlclxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fc3RyZWFtTm9kZXMgPSBbXTtcclxuICAgIHRoaXMuX3N0cmVhbXMgPSBbXTtcclxuICAgIHRoaXMuX3NwbGl0cyA9IHt9O1xyXG4gICAgdGhpcy5feFNjYWxlID0gZCA9PiBkO1xyXG4gICAgdGhpcy5feVNjYWxlID0gZCA9PiBkO1xyXG4gICAgdGhpcy5fcHJvcG9ydGlvbiA9IDE7XHJcblxyXG4gICAgdGhpcy5feEN1cnZlID0gJ2Jlemllcic7IC8vIGxpbmVhciwgYmV6aWVyXHJcbiAgICB0aGlzLl9zdGFydEVuZCA9IHtcclxuICAgICAgZW5jb2Rpbmc6ICdwbHVnJywgLy8gY2lyY2xlLCBwbHVnLCBkZWZhdWx0XHJcbiAgICAgIHg6IDAuODUsXHJcbiAgICAgIHk6IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBnZXQgc3RyZWFtcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdHJlYW1zO1xyXG4gIH1cclxuICBnZXQgY2xpcFBhdGhzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NsaXBQYXRocztcclxuICB9XHJcbiAgZ2V0IHNwbGl0cygpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zcGxpdHMpO1xyXG4gIH1cclxuXHJcbiAgc2V0IHhTY2FsZShjYWxsYmFjaykge1xyXG4gICAgdGhpcy5feFNjYWxlID0gY2FsbGJhY2s7XHJcbiAgfVxyXG4gIHNldCB5U2NhbGUoY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX3lTY2FsZSA9IGNhbGxiYWNrO1xyXG4gIH1cclxuICBzZXQgc3RhcnRFbmRFbmNvZGluZyhlbmNvZGluZykge1xyXG4gICAgdGhpcy5fc3RhcnRFbmQuZW5jb2RpbmcgPSBlbmNvZGluZztcclxuICB9XHJcbiAgc2V0IHN0YXJ0RW5kRW5jb2RpbmdYKHgpIHtcclxuICAgIHRoaXMuX3N0YXJ0RW5kLnggPSB4O1xyXG4gIH1cclxuICBzZXQgc3RhcnRFbmRFbmNvZGluZ1koeSkge1xyXG4gICAgdGhpcy5fc3RhcnRFbmQueSA9IHk7XHJcbiAgfVxyXG4gIHNldCBwcm9wb3J0aW9uKHApIHtcclxuICAgIHRoaXMuX3Byb3BvcnRpb24gPSBwO1xyXG4gIH1cclxuXHJcbiAgYWRkKG5vZGUpIHtcclxuICAgIHRoaXMuX3N0cmVhbU5vZGVzLnB1c2gobm9kZSk7XHJcbiAgfVxyXG5cclxuICAvLyBleHRyYWN0IHNwZWNpYWwgb3BlcmF0aW9ucyAoc3BsaXRzLCBtZXJnZXMsIHBhcmVudFN3YXApIGZyb20gdGhlIGRhdGEgYW5kIHRyZWF0IGl0IGV4dHJhXHJcbiAgcHJlcHJvY2VzcygpIHtcclxuICAgIGxldCBtZXJnZU5vZGVzID0gW107XHJcbiAgICBsZXQgc3BsaXROb2RlcyA9IFtdO1xyXG4gICAgbGV0IHBhcmVudFN3YXBzID0gW107XHJcbiAgICBsZXQgbmV3U3RyZWFtcyA9IFtdO1xyXG5cclxuICAgIC8vIGN1dCBjb25uZWN0aW9uIGJldHdlZW4gbm9kZSBhbmQgcHJldmlvdXMgbm9kZXNcclxuICAgIGxldCBjdXRQcmV2aW91cyA9IG5vZGUgPT4ge1xyXG4gICAgICBpZiAoISFub2RlLnByZXYpIHtcclxuICAgICAgICBmb3IgKGxldCBwcmV2IG9mIG5vZGUucHJldikge1xyXG4gICAgICAgICAgaWYgKHByZXYubmV4dC5sZW5ndGggPT0gMSkgcHJldi5uZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgZWxzZSBwcmV2Lm5leHQuc3BsaWNlKHByZXYubmV4dC5pbmRleE9mKG5vZGUpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gY3V0IGNvbm5lY3Rpb24gYmV0d2VlbiBub2RlIGFuZCBuZXh0IG5vZGVzXHJcbiAgICBsZXQgY3V0TmV4dCA9IG5vZGUgPT4ge1xyXG4gICAgICBpZiAoISFub2RlLm5leHQpIHtcclxuICAgICAgICBmb3IgKGxldCBuZXh0IG9mIG5vZGUubmV4dCkge1xyXG4gICAgICAgICAgaWYgKG5leHQucHJldi5sZW5ndGggPT0gMSkgbmV4dC5wcmV2ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgZWxzZSBuZXh0LnByZXYuc3BsaWNlKG5leHQucHJldi5pbmRleE9mKG5vZGUpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbGV0IHRyYXZlcnNlID0gbm9kZSA9PiB7XHJcbiAgICAgIGlmICghIW5vZGUubmV4dCkgZm9yIChsZXQgbmV4dCBvZiBub2RlLm5leHQpIHRyYXZlcnNlKG5leHQpO1xyXG5cclxuICAgICAgLy8gc3BsaXQgbm9kZXNcclxuICAgICAgaWYgKCEhbm9kZS5uZXh0ICYmIG5vZGUubmV4dC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgc3BsaXROb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgIGN1dE5leHQobm9kZSk7XHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBzdHJlYW1zIGZyb20gaGVyZVxyXG4gICAgICAgIG5ld1N0cmVhbXMucHVzaCh7IC4uLm5vZGUubmV4dCB9KTtcclxuXHJcbiAgICAgICAgLy8gZW5kIHN0cmVhbSBoZXJlXHJcbiAgICAgICAgbm9kZS5uZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBtZXJnZSBub2Rlc1xyXG4gICAgICBpZiAoISFub2RlLnByZXYgJiYgbm9kZS5wcmV2Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBtZXJnZU5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgZW5kUHJldmlvdXMobm9kZSk7XHJcblxyXG4gICAgICAgIG5vZGUucHJldiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm5ld1N0cmVhbXMucHVzaChub2RlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcGFyZW50IHN3YXBcclxuICAgICAgaWYgKCEhbm9kZS5uZXh0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgbmV4dCBvZiBub2RlLm5leHQpIHtcclxuICAgICAgICAgIC8vIG9ubHkgY29uc2lkZXIgbm9kZXMgd2hvcyBwYXJlbnRzIGNoYW5nZVxyXG4gICAgICAgICAgLy8gMS4gbm9kZSBiZWNvbWVzIHJvb3Qgbm9kZSAocGFyZW50IGNoYW5nZXMgZnJvbSBkZWZpbmVkIHRvIHVuZGVmaW5lZClcclxuICAgICAgICAgIC8vIDIuIHBhcmVudCBpZCBjaGFuZ2VzIChUT0RPOiBtYWtlIHN1cmUgdGhhdCB0aGlzIGNhc2UgaXMgbm90IGhhbmRsZWQgdHdpY2UsIGJlY2F1c2UgYm90aCBub2RlJ3MgcGFyZW50cyBjaGFuZ2UpXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICghbm9kZS5wYXJlbnQgJiYgISFuZXh0LnBhcmVudCkgfHxcclxuICAgICAgICAgICAgKCEhbm9kZS5wYXJlbnQgJiYgISFuZXh0LnBhcmVudCAmJiBub2RlLnBhcmVudC5pZCAhPSBuZXh0LnBhcmVudC5pZClcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBuZXh0LnBhcmVudCBoYWQgbm9kZSBhcyBhbiBhbmNlc3RvciBpbiB0aGUgcHJldmlvdXMgc3RlcFxyXG5cclxuICAgICAgICAgICAgaWYgKCEhbmV4dC5wYXJlbnQucHJldikge1xyXG4gICAgICAgICAgICAgIGZvciAobGV0IHByZXYgb2YgbmV4dC5wYXJlbnQucHJldikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzQW5jZXN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBwID0gcHJldjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwICYmICFpc0FuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwLmlkID09IG5vZGUuaWQpIGlzQW5jZXN0b3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBlbHNlIHAgPSBwLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVuZFByZXZpb3VzKHByZXYpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoISFwcmV2Lm5leHQpIGFkZEZvbGxvd2luZyhwcmV2Lm5leHQpO1xyXG4gICAgICAgICAgICAgICAgICBwYXJlbnRTd2Fwcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiB7IC4uLnByZXYgfSxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiB7IC4uLm5leHQucGFyZW50IH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gZHJhdyBzcGVjaWFsIGNhc2UgZm9yIG5vZGUgXCJwXCIgYW5kIGFsbCBpdHMgY2hpbGRyZW4sIGFzIHdlbGwgYXMgbm9kZVxyXG5cclxuICAgIC8vIGxvb3AgaW4gcmV2ZXJzZSwgYmVjYXVzZSBlbGVtZW50cyBhcmUgYWRkZWQgYW5kIGRlbGV0ZWRcclxuICAgIGZvciAobGV0IGkgPSB0aGlzLl9zdHJlYW1Ob2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICB0cmF2ZXJzZSh0aGlzLl9zdHJlYW1Ob2Rlc1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuX3N0cmVhbU5vZGVzID0gW107XHJcbiAgICB0aGlzLl9zdHJlYW1zID0gW107XHJcbiAgICB0aGlzLl9jbGlwUGF0aHMgPSBbXTtcclxuICB9XHJcblxyXG4gIGFkZFNwbGl0cyhzcGxpdHMpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNwbGl0cykpXHJcbiAgICAgIHNwbGl0cy5mb3JFYWNoKGQgPT4ge1xyXG4gICAgICAgIHRoaXMuX3NwbGl0c1tkXSA9IHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgZWxzZSB0aGlzLl9zcGxpdHNbZF0gPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmVtb3ZlU3BsaXRzKHNwbGl0cykge1xyXG4gICAgaWYgKCFzcGxpdHMpIHRoaXMuX3NwbGl0cyA9IHt9O1xyXG4gICAgZWxzZVxyXG4gICAgICBzcGxpdHMuZm9yRWFjaChkID0+IHtcclxuICAgICAgICB0aGlzLl9zcGxpdHNbZF0ucmVtb3ZlKCk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy9UT0RPOiBmaW5kIG1vcmUgZWxhYm9yYXRlIHNvbHV0aW9uXHJcbiAgX2ZpbmRTcGxpdHModDAsIHQxKSB7XHJcbiAgICBsZXQgc3BsaXRzID0gW107XHJcbiAgICBmb3IgKGxldCBzcGxpdCBpbiB0aGlzLl9zcGxpdHMpIHtcclxuICAgICAgaWYgKHNwbGl0ID49IHQwICYmIHNwbGl0IDw9IHQxKSBzcGxpdHMucHVzaCgrc3BsaXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNwbGl0cztcclxuICB9XHJcblxyXG4gIF9maW5kQ2xvc2VzdE5vZGUoc3RyZWFtLCB4KSB7XHJcbiAgICBsZXQgdHJhdmVyc2VUaW1lID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICBsZXQgZGlzdGFuY2UgPSBNYXRoLmFicyhub2RlLnggLSB4KTtcclxuICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgIGNsb3Nlc3ROb2RlID0gbm9kZTtcclxuICAgICAgICAvLyBpZiBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gbWluRGlzdGFuY2UsIGl0IHdpbGwgb25seSBpbmNyZWFzZSB3aXRoIGZvbGxvd2luZyBub2Rlc1xyXG4gICAgICAgIGlmICghIW5vZGUubmV4dCkge1xyXG4gICAgICAgICAgbm9kZS5uZXh0LmZvckVhY2godHJhdmVyc2VUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcclxuICAgIGxldCBjbG9zZXN0Tm9kZTtcclxuICAgIHRyYXZlcnNlVGltZShzdHJlYW0pO1xyXG4gICAgcmV0dXJuIGNsb3Nlc3ROb2RlO1xyXG4gIH1cclxuXHJcbiAgLy8gV0FSTklORzogd29yayBpbiBwcm9jZXNzXHJcbiAgX2NoZWNrRm9yTnVsbFN0cmVhbXMoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0cmVhbU5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBpc051bGwgPSB0cnVlO1xyXG5cclxuICAgICAgbGV0IHRyYXZlcnNlID0gbm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKG5vZGUueTEgLSBub2RlLnkwID4gMCkge1xyXG4gICAgICAgICAgaXNOdWxsID0gZmFsc2U7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoISFub2RlLm5leHQpIG5vZGUubmV4dC5mb3JFYWNoKHRyYXZlcnNlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRyYXZlcnNlKHRoaXMuX3N0cmVhbU5vZGVzW2ldKTtcclxuXHJcbiAgICAgIGlmIChpc051bGwpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fc3RyZWFtTm9kZXNbaV07IC8vZGVsZXRlIHN0cmVhbTtcclxuICAgICAgICBpLS07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9kcmF3U3RhcnQocGF0aCwgbm9kZSkge1xyXG4gICAgY29uc3QgZCA9IHBhdGgsXHJcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxyXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxyXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xyXG5cclxuICAgIC8vIGV4dGVuZCB0byBsZWZ0XHJcbiAgICBkLm1vdmUoeChub2RlLngpLCB5KG5vZGUueTEpKTtcclxuXHJcbiAgICAvLyBkb24ndCBkcmF3IHN0YXJ0IGZvciB6ZXJvIHZhbHVlc1xyXG4gICAgaWYgKG5vZGUueTEgLSBub2RlLnkwIDw9IDApIHJldHVybjtcclxuXHJcbiAgICBsZXQgdCA9IG5vZGUueCAtIDAuNSAqICgxIC0gcHJvcCk7XHJcbiAgICBkLmhvcml6b250YWwoeCh0KSk7XHJcblxyXG4gICAgLy8gY29ubmVjdCB0b3AgYW5kIGJvdHRvbVxyXG4gICAgbGV0IHJvb3QgPSBub2RlO1xyXG4gICAgd2hpbGUgKCEhcm9vdC5wYXJlbnQpIHJvb3QgPSByb290LnBhcmVudDtcclxuXHJcbiAgICBpZiAoIXJvb3QucHJldikge1xyXG4gICAgICAvLyBtYWtlIGZpcnN0IHRpbWVzdGVwIGZsYXRcclxuICAgICAgZC52ZXJ0aWNhbCh5KG5vZGUueTApKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLl9zdGFydEVuZC5lbmNvZGluZyA9PSAnY2lyY2xlJykgdGhpcy5fZHJhd1N0YXJ0Q2lyY2xlKGQsIG5vZGUpO1xyXG4gICAgICBlbHNlIGlmICh0aGlzLl9zdGFydEVuZC5lbmNvZGluZyA9PSAncGx1ZycpIHRoaXMuX2RyYXdTdGFydFBsdWcoZCwgbm9kZSk7XHJcbiAgICAgIGVsc2UgdGhpcy5fZHJhd1N0YXJ0RGVmYXVsdChkLCBub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25uZWN0IGJhY2tcclxuICAgIGQuaG9yaXpvbnRhbCh4KG5vZGUueCkpO1xyXG4gIH1cclxuXHJcbiAgX2RyYXdFbmQocGF0aCwgbm9kZSkge1xyXG4gICAgY29uc3QgZCA9IHBhdGgsXHJcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxyXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxyXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xyXG5cclxuICAgIGlmIChub2RlLnkxIC0gbm9kZS55MCA8PSAwKSByZXR1cm47XHJcblxyXG4gICAgLy8gZXh0ZW5kIHRvIHJpZ2h0XHJcbiAgICBsZXQgdCA9IG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCk7XHJcbiAgICBkLmhvcml6b250YWwoeCh0KSk7XHJcblxyXG4gICAgLy8gY29ubmVjdCBib3R0b20gYW5kIHRvcFxyXG4gICAgbGV0IHJvb3QgPSBub2RlO1xyXG4gICAgd2hpbGUgKCEhcm9vdC5wYXJlbnQpIHJvb3QgPSByb290LnBhcmVudDtcclxuICAgIGlmICghcm9vdC5uZXh0KSB7XHJcbiAgICAgIC8vIG1ha2UgbGFzdCB0aW1lc3RlcCBmbGF0XHJcbiAgICAgIGQudmVydGljYWwoeShub2RlLnkxKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5fc3RhcnRFbmQuZW5jb2RpbmcgPT0gJ2NpcmNsZScpIHRoaXMuX2RyYXdFbmRDaXJjbGUoZCwgbm9kZSk7XHJcbiAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXJ0RW5kLmVuY29kaW5nID09ICdwbHVnJykgdGhpcy5fZHJhd0VuZFBsdWcoZCwgbm9kZSk7XHJcbiAgICAgIGVsc2UgdGhpcy5fZHJhd0VuZERlZmF1bHQoZCwgbm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29ubmVjdCBiYWNrXHJcbiAgICBkLmhvcml6b250YWwoeChub2RlLngpKTtcclxuICB9XHJcblxyXG4gIF9kcmF3U3RhcnREZWZhdWx0KHBhdGgsIG5vZGUpIHtcclxuICAgIC8vIGluc2VydCBub2RlXHJcbiAgICBjb25zdCBkID0gcGF0aCxcclxuICAgICAgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb24sXHJcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXHJcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XHJcblxyXG4gICAgLy8gZmluZCBwb3NpdGlvbiB0byBpbnNlcnQgbm9kZVxyXG4gICAgbGV0IHBvcztcclxuICAgIC8vIGZpbmQgdGhlIG9sZGVzdCBwYXJlbnQgb2Ygbm9kZSwgd2hpY2ggZG9lcyBub3QgZXhpc3QgaW4gdGhlIHByZXZpb3VzIHN0ZXBcclxuICAgIGxldCBwYXJlbnROb1ByZXYgPSBub2RlO1xyXG4gICAgd2hpbGUgKCEhcGFyZW50Tm9QcmV2LnBhcmVudCAmJiAhcGFyZW50Tm9QcmV2LnBhcmVudC5wcmV2KVxyXG4gICAgICBwYXJlbnROb1ByZXYgPSBwYXJlbnROb1ByZXYucGFyZW50O1xyXG5cclxuICAgIC8vIHAgaXMgYW4gYW5jZXN0b3Igd2hvIGV4aXN0ZWQgaW4gdGhlIHByZXZpb3VzIHRpbWVzdGVwXHJcbiAgICBsZXQgcCA9IHBhcmVudE5vUHJldi5wYXJlbnQ7XHJcbiAgICBpZiAoIXApIHtcclxuICAgICAgZC52ZXJ0aWNhbCh5KG5vZGUueTApKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHVzZSB0aGUgY2VudGVyIG9mIHRoZSBzdHJlYW0gYXMgcmVmZXJlbmNlIHBvaW50XHJcbiAgICAgIGxldCBtaWQgPSAwLjUgKiAocGFyZW50Tm9QcmV2LnkwICsgcGFyZW50Tm9QcmV2LnkxKTtcclxuXHJcbiAgICAgIC8vIGlmIHRoZSBub2RlcyBwYXJlbnQgaGFzIG11bHRpcGxlIHByZXZpb3VzIG5vZGVzLCBmaW5kIHRoZSBvbmUgY2xvc2VzdCB0byBtaWRcclxuICAgICAgbGV0IHJlZlByZXZJZCA9IC0xO1xyXG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHAucHJldi5sZW5ndGggJiYgcmVmUHJldklkID09IC0xOyBuKyspIHtcclxuICAgICAgICBsZXQgcHJldiA9IHAucHJldltuXTtcclxuICAgICAgICAvLyBpZiBtaWQgbGllcyB3aXRoaW4gYSBwcmV2IG5vZGVcclxuICAgICAgICBpZiAocHJldi55MCA8PSBtaWQgJiYgcHJldi55MSA+PSBtaWQpIHtcclxuICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIGNoaWxkcmVuXHJcbiAgICAgICAgICBpZiAoISFwcmV2LmNoaWxkcmVuICYmIHByZXYuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcmVmQ2hpbGRJZCA9IC0xOyAvLyBmaW5kIHR3byBjaGlsZHJlbiB0byBwdXQgdGhlIG1pZCBpbiBiZXR3ZWVuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZHJlbi5sZW5ndGggJiYgcmVmQ2hpbGRJZCA9PSAtMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcHJldi5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICBpZiAobWlkIDw9IDAuNSAqIChjaGlsZC55MCArIGNoaWxkLnkxKSkgcmVmQ2hpbGRJZCA9IGk7IC8vIHNldHRpbmcgSUQgYnJlYWtzIHRoZSBsb29wXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZkNoaWxkSWQgPT0gMClcclxuICAgICAgICAgICAgICAvLyBiZWZvcmUgZmlyc3QgY2hpbGRcclxuICAgICAgICAgICAgICBwb3MgPSAwLjUgKiAocHJldi55MCArIHByZXYuY2hpbGRyZW5bMF0ueTApO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChyZWZDaGlsZElkID09IC0xKVxyXG4gICAgICAgICAgICAgIC8vIGFmdGVyIGxhc3QgY2hpbGRcclxuICAgICAgICAgICAgICBwb3MgPVxyXG4gICAgICAgICAgICAgICAgMC41ICogKHByZXYueTEgKyBwcmV2LmNoaWxkcmVuW3ByZXYuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueTEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgcG9zID1cclxuICAgICAgICAgICAgICAgIDAuNSAqXHJcbiAgICAgICAgICAgICAgICAocHJldi5jaGlsZHJlbltyZWZDaGlsZElkIC0gMV0ueTEgK1xyXG4gICAgICAgICAgICAgICAgICBwcmV2LmNoaWxkcmVuW3JlZkNoaWxkSWRdLnkwKTtcclxuICAgICAgICAgIH0gLy8gbm9kZSBoYXMgbm8gY2hpbGRyZW5cclxuICAgICAgICAgIGVsc2UgcG9zID0gMC41ICogKHByZXYueTAgKyBwcmV2LnkxKTtcclxuICAgICAgICAgIHJlZlByZXZJZCA9IC0yOyAvLyBzZXR0aW5nIElEIGJyZWFrcyB0aGUgbG9vcFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBpdCBsaWVzIG91dHNpZGUsIGZpbmQgdHdvIG5vZGVzIHRvIHB1dCBpdCBpbmJldHdlZW5cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmIChtaWQgPD0gMC41ICogKHByZXYueTAgKyBwcmV2LnkxKSkgcmVmUHJldklkID0gbjsgLy8gc2V0dGluZyBJRCBicmVha3MgdGhlIGxvb3BcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWZQcmV2SWQgIT0gLTIpIHtcclxuICAgICAgICAvLyBpZiAtMiwgdGhlbiBwb3Mgd2FzIGFscmVhZHkgc2V0XHJcbiAgICAgICAgbGV0IG5vZGU7IC8vIGRlZmluZSB0aGUgbm9kZSB0byBkcmF3IGluc2lkZVxyXG4gICAgICAgIGxldCBmaXJzdDsgLy8gYm9vbGVhbiB0byBkZWZpbmUgaWYgaXQgc2hvdWxkIGJlIGRyYXduIGJlZm9yZSB0aGUgZmlyc3Qgb3IgYWZ0ZXIgdGhlIGxhc3QgY2hpbGRcclxuICAgICAgICBpZiAocmVmUHJldklkID09IDApIHtcclxuICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBjaGlsZFxyXG4gICAgICAgICAgbm9kZSA9IHAucHJldlswXTtcclxuICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJlZlByZXZJZCA9PSAtMSkge1xyXG4gICAgICAgICAgLy8gYWZ0ZXIgbGFzdCBjaGlsZFxyXG4gICAgICAgICAgbm9kZSA9IHAucHJldltwLnByZXYubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBmaW5kIHdoaWNoIG5vZGUgaXMgY2xvc2VyXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIE1hdGguYWJzKHAucHJldltyZWZQcmV2SWRdLnkwIC0gbWlkKSA8XHJcbiAgICAgICAgICAgIE1hdGguYWJzKHAucHJldltyZWZQcmV2SWQgLSAxXS55MSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBub2RlID0gcC5wcmV2W3JlZlByZXZJZF07XHJcbiAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBwLnByZXZbcmVmUHJldklkIC0gMV07XHJcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoISFub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgaWYgKGZpcnN0KSBwb3MgPSAwLjUgKiAobm9kZS55MCArIG5vZGUuY2hpbGRyZW5bMF0ueTApO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBwb3MgPSAwLjUgKiAobm9kZS55MSArIG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS55MSk7XHJcbiAgICAgICAgfSBlbHNlIHBvcyA9IDAuNSAqIChub2RlLnkwICsgbm9kZS55MSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB0ZGlmZiA9IG5vZGUueCAtIHAucHJldlswXS54O1xyXG4gICAgICBsZXQgdDAgPSBub2RlLnggLSAwLjUgKiAoMSAtIHByb3ApICogdGRpZmY7XHJcbiAgICAgIGxldCB0MSA9IHQwIC0gMC41ICogcHJvcCAqIHRkaWZmO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnbGluZWFyJykge1xyXG4gICAgICAgIGQubGluZSh4KHAucHJldlswXS54KSwgeShwb3MpKTtcclxuICAgICAgICBkLmxpbmUoeCh0MCksIHkobm9kZS55MCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnYmV6aWVyJykge1xyXG4gICAgICAgIGQuYmV6aWVyKHgodDEpLCB5KG5vZGUueTEpLCB4KHQxKSwgeShwb3MpLCB4KHAucHJldlswXS54KSwgeShwb3MpKTtcclxuICAgICAgICBkLmJlemllcih4KHQxKSwgeShwb3MpLCB4KHQxKSwgeShub2RlLnkwKSwgeCh0MCksIHkobm9kZS55MCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZHJhd0VuZERlZmF1bHQocGF0aCwgbm9kZSkge1xyXG4gICAgY29uc3QgZCA9IHBhdGgsXHJcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxyXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxyXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xyXG5cclxuICAgIC8vIGZpbmQgcG9zaXRpb24gdG8gZGVsZXRlIG5vZGUgdG9cclxuICAgIGxldCBwb3M7XHJcbiAgICAvLyBmaW5kIHRoZSBvbGRlc3QgcGFyZW50IG9mIG5vZGUsIHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIHRoZSBuZXh0IHN0ZXBcclxuICAgIGxldCBwYXJlbnROb05leHQgPSBub2RlO1xyXG4gICAgd2hpbGUgKCEhcGFyZW50Tm9OZXh0LnBhcmVudCAmJiAhcGFyZW50Tm9OZXh0LnBhcmVudC5uZXh0KVxyXG4gICAgICBwYXJlbnROb05leHQgPSBwYXJlbnROb05leHQucGFyZW50OyAvLyBwIGlzIHRoZSBvbGRlc3QgcGFyZW50IG9mIG5vZGUsIHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIHRoZSBuZXh0IHN0ZXBcclxuXHJcbiAgICAvLyBwIGlzIGFuIGFuY2VzdG9yIHdobyBleGlzdHMgaW4gdGhlIG5leHQgdGltZXN0ZXBcclxuICAgIGxldCBwID0gcGFyZW50Tm9OZXh0LnBhcmVudDtcclxuICAgIGlmICghcCkge1xyXG4gICAgICBkLnZlcnRpY2FsKHkobm9kZS55MSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gdXNlIHRoZSBjZW50ZXIgb2YgdGhlIHN0cmVhbSBhcyByZWZlcmVuY2UgcG9pbnRcclxuICAgICAgbGV0IG1pZCA9IDAuNSAqIChwYXJlbnROb05leHQueTAgKyBwYXJlbnROb05leHQueTEpO1xyXG4gICAgICAvLyBpZiB0aGUgbm9kZXMgcGFyZW50IGhhcyBtdWx0aXBsZSBuZXh0IG5vZGVzLCBmaW5kIHRoZSBvbmUgY2xvc2VzdCB0byBtaWRcclxuICAgICAgbGV0IHJlZk5leHRJZCA9IC0xO1xyXG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHAubmV4dC5sZW5ndGggJiYgcmVmTmV4dElkID09IC0xOyBuKyspIHtcclxuICAgICAgICBsZXQgbmV4dCA9IHAubmV4dFtuXTtcclxuICAgICAgICAvLyBpZiBtaWQgbGllcyB3aXRoaW4gYSBuZXh0IG5vZGVcclxuICAgICAgICBpZiAobmV4dC55MCA8PSBtaWQgJiYgbmV4dC55MSA+PSBtaWQpIHtcclxuICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIGNoaWxkcmVuXHJcbiAgICAgICAgICBpZiAoISFuZXh0LmNoaWxkcmVuICYmIG5leHQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcmVmQ2hpbGRJZCA9IC0xOyAvLyBmaW5kIHR3byBjaGlsZHJlbiB0byBwdXQgdGhlIG1pZCBpbiBiZXR3ZWVuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dC5jaGlsZHJlbi5sZW5ndGggJiYgcmVmQ2hpbGRJZCA9PSAtMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbGV0IGNoaWxkID0gbmV4dC5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICBpZiAobWlkIDw9IDAuNSAqIChjaGlsZC55MCArIGNoaWxkLnkxKSkgcmVmQ2hpbGRJZCA9IGk7IC8vIHNldHRpbmcgSUQgYnJlYWtzIHRoZSBsb29wXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZkNoaWxkSWQgPT0gMClcclxuICAgICAgICAgICAgICAvLyBiZWZvcmUgZmlyc3QgY2hpbGRcclxuICAgICAgICAgICAgICBwb3MgPSAwLjUgKiAobmV4dC55MCArIG5leHQuY2hpbGRyZW5bMF0ueTApO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChyZWZDaGlsZElkID09IC0xKVxyXG4gICAgICAgICAgICAgIC8vIGFmdGVyIGxhc3QgY2hpbGRcclxuICAgICAgICAgICAgICBwb3MgPVxyXG4gICAgICAgICAgICAgICAgMC41ICogKG5leHQueTEgKyBuZXh0LmNoaWxkcmVuW25leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueTEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgcG9zID1cclxuICAgICAgICAgICAgICAgIDAuNSAqXHJcbiAgICAgICAgICAgICAgICAobmV4dC5jaGlsZHJlbltyZWZDaGlsZElkIC0gMV0ueTEgK1xyXG4gICAgICAgICAgICAgICAgICBuZXh0LmNoaWxkcmVuW3JlZkNoaWxkSWRdLnkwKTtcclxuICAgICAgICAgIH0gLy8gbm9kZSBoYXMgbm8gY2hpbGRyZW5cclxuICAgICAgICAgIGVsc2UgcG9zID0gMC41ICogKG5leHQueTAgKyBuZXh0LnkxKTtcclxuICAgICAgICAgIHJlZk5leHRJZCA9IC0yOyAvLyBzZXR0aW5nIElEIGJyZWFrcyB0aGUgbG9vcFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBpdCBsaWVzIG91dHNpZGUsIGZpbmQgdHdvIG5vZGVzIHRvIHB1dCBpdCBpbmJldHdlZW5cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmIChtaWQgPD0gMC41ICogKG5leHQueTAgKyBuZXh0LnkxKSkgcmVmTmV4dElkID0gbjsgLy8gc2V0dGluZyBJRCBicmVha3MgdGhlIGxvb3BcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWZOZXh0SWQgIT0gLTIpIHtcclxuICAgICAgICAvLyBpZiAtMiwgdGhlbiBwb3Mgd2FzIGFscmVhZHkgc2V0XHJcbiAgICAgICAgbGV0IG5vZGU7IC8vIGRlZmluZSB0aGUgbm9kZSB0byBkcmF3IGluc2lkZVxyXG4gICAgICAgIGxldCBmaXJzdDsgLy8gYm9vbGVhbiB0byBkZWZpbmUgaWYgaXQgc2hvdWxkIGJlIGRyYXduIGJlZm9yZSB0aGUgZmlyc3Qgb3IgYWZ0ZXIgdGhlIGxhc3QgY2hpbGRcclxuICAgICAgICBpZiAocmVmTmV4dElkID09IDApIHtcclxuICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBjaGlsZFxyXG4gICAgICAgICAgbm9kZSA9IHAubmV4dFswXTtcclxuICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJlZk5leHRJZCA9PSAtMSkge1xyXG4gICAgICAgICAgLy8gYWZ0ZXIgbGFzdCBjaGlsZFxyXG4gICAgICAgICAgbm9kZSA9IHAubmV4dFtwLm5leHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBmaW5kIHdoaWNoIG5vZGUgaXMgY2xvc2VyXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIE1hdGguYWJzKHAubmV4dFtyZWZOZXh0SWRdLnkwIC0gbWlkKSA8XHJcbiAgICAgICAgICAgIE1hdGguYWJzKHAubmV4dFtyZWZOZXh0SWQgLSAxXS55MSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBub2RlID0gcC5uZXh0W3JlZk5leHRJZF07XHJcbiAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBwLm5leHRbcmVmTmV4dElkIC0gMV07XHJcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoISFub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgaWYgKGZpcnN0KSBwb3MgPSAwLjUgKiAobm9kZS55MCArIG5vZGUuY2hpbGRyZW5bMF0ueTApO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBwb3MgPSAwLjUgKiAobm9kZS55MSArIG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS55MSk7XHJcbiAgICAgICAgfSBlbHNlIHBvcyA9IDAuNSAqIChub2RlLnkwICsgbm9kZS55MSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB0ZGlmZiA9IHAubmV4dFswXS54IC0gbm9kZS54O1xyXG4gICAgICBsZXQgdDAgPSBub2RlLnggKyAwLjUgKiAoMSAtIHByb3ApICogdGRpZmY7XHJcbiAgICAgIGxldCB0MSA9IHQwICsgMC41ICogcHJvcCAqIHRkaWZmO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnbGluZWFyJykge1xyXG4gICAgICAgIGQubGluZSh4KHAubmV4dFswXS54KSwgeShwb3MpKTtcclxuICAgICAgICBkLmxpbmUoeCh0MCksIHkobm9kZS55MSkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnYmV6aWVyJykge1xyXG4gICAgICAgIGQuYmV6aWVyKHgodDEpLCB5KG5vZGUueTApLCB4KHQxKSwgeShwb3MpLCB4KHAubmV4dFswXS54KSwgeShwb3MpKTtcclxuICAgICAgICBkLmJlemllcih4KHQxKSwgeShwb3MpLCB4KHQxKSwgeShub2RlLnkxKSwgeCh0MCksIHkobm9kZS55MSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfZHJhd1N0YXJ0Q2lyY2xlKHBhdGgsIG5vZGUpIHtcclxuICAgIGNvbnN0IGQgPSBwYXRoLFxyXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcclxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcclxuICAgICAgeSA9IHRoaXMuX3lTY2FsZTtcclxuXHJcbiAgICBsZXQgaGVpZ2h0ID0gbm9kZS55MSAtIG5vZGUueTA7XHJcbiAgICBsZXQgdCA9IG5vZGUueCAtIDAuNSAqICgxIC0gcHJvcCk7XHJcbiAgICBkLm1vdmUoeCh0KSwgeShub2RlLnkxKSk7XHJcbiAgICAvL2QuYXJjKE1hdGgubG9nKGhlaWdodCksIDEsIDAsIDAsIDAsIHgobm9kZS54KSwgeShub2RlLnkwKSk7XHJcbiAgICBkLmFyYyhwcm9wLCAxLCAwLCAwLCAwLCB4KHQpLCB5KG5vZGUueTApKTtcclxuICB9XHJcblxyXG4gIF9kcmF3RW5kQ2lyY2xlKHBhdGgsIG5vZGUpIHtcclxuICAgIGNvbnN0IGQgPSBwYXRoLFxyXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcclxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcclxuICAgICAgeSA9IHRoaXMuX3lTY2FsZTtcclxuXHJcbiAgICBsZXQgaGVpZ2h0ID0gbm9kZS55MSAtIG5vZGUueTA7XHJcbiAgICBsZXQgdCA9IG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCk7XHJcbiAgICAvL2QuYXJjKE1hdGgubG9nKGhlaWdodCksIDEsIDAsIDAsIDAsIHgobm9kZS54KSwgeShub2RlLnkxKSk7XHJcbiAgICBkLmFyYyhwcm9wLCAxLCAwLCAwLCAwLCB4KHQpLCB5KG5vZGUueTEpKTtcclxuICB9XHJcblxyXG4gIF9kcmF3U3RhcnRQbHVnKHBhdGgsIG5vZGUpIHtcclxuICAgIGNvbnN0IGQgPSBwYXRoLFxyXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcclxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcclxuICAgICAgeSA9IHRoaXMuX3lTY2FsZTtcclxuXHJcbiAgICBsZXQgdCA9IG5vZGUueCAtIDAuNSAqICgxIC0gcHJvcCk7XHJcbiAgICBsZXQgaGVpZ2h0ID0gbm9kZS55MSAtIG5vZGUueTA7XHJcbiAgICBkLmJlemllcihcclxuICAgICAgeCh0IC0gcHJvcCAqIHRoaXMuX3N0YXJ0RW5kLnggKiBNYXRoLnNxcnQoaGVpZ2h0KSksXHJcbiAgICAgIHkobm9kZS55MSArIHRoaXMuX3N0YXJ0RW5kLnkgKiBoZWlnaHQpLFxyXG4gICAgICB4KHQgLSBwcm9wICogdGhpcy5fc3RhcnRFbmQueCAqIE1hdGguc3FydChoZWlnaHQpKSxcclxuICAgICAgeShub2RlLnkwIC0gdGhpcy5fc3RhcnRFbmQueSAqIGhlaWdodCksXHJcbiAgICAgIHgodCksXHJcbiAgICAgIHkobm9kZS55MClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBfZHJhd0VuZFBsdWcocGF0aCwgbm9kZSkge1xyXG4gICAgY29uc3QgZCA9IHBhdGgsXHJcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxyXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxyXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xyXG5cclxuICAgIGxldCB0ID0gbm9kZS54ICsgMC41ICogKDEgLSBwcm9wKTtcclxuICAgIGxldCBoZWlnaHQgPSBub2RlLnkxIC0gbm9kZS55MDtcclxuICAgIGQuYmV6aWVyKFxyXG4gICAgICB4KHQgKyBwcm9wICogdGhpcy5fc3RhcnRFbmQueCAqIE1hdGguc3FydChoZWlnaHQpKSxcclxuICAgICAgeShub2RlLnkwIC0gdGhpcy5fc3RhcnRFbmQueSAqIGhlaWdodCksXHJcbiAgICAgIHgodCArIHByb3AgKiB0aGlzLl9zdGFydEVuZC54ICogTWF0aC5zcXJ0KGhlaWdodCkpLFxyXG4gICAgICB5KG5vZGUueTEgKyB0aGlzLl9zdGFydEVuZC55ICogaGVpZ2h0KSxcclxuICAgICAgeCh0KSxcclxuICAgICAgeShub2RlLnkxKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNhbGN1bGF0ZVBhdGhzKCkge1xyXG4gICAgLy90aGlzLl9jaGVja0Zvck51bGxTdHJlYW1zKCk7XHJcblxyXG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb24sXHJcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXHJcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XHJcbiAgICBsZXQgZCwgbGFzdFRpbWVwb2ludCwgZGVlcGVzdERlcHRoLCBsYXJnZXN0U2l6ZTsgLy8gZmluZCB0aGUgZGVlcGVzdCBkZXB0aCBlYWNoIHN0cmVhbSBoYXMgb3ZlciB0aGUgd2hvbGUgdGltZXNlcmllc1xyXG5cclxuICAgIGxldCBkcmF3TGluZSA9ICh0MSwgdDIsIHQzLCB5U291cmNlLCB5RGVzdCkgPT4ge1xyXG4gICAgICBsZXQgdDEyID0gMC41ICogKHQxICsgdDIpOyAvLyBtaWQgYmV0d2VlbiB0MSBhbmQgdDJcclxuICAgICAgZC5ob3Jpem9udGFsKHQxKTtcclxuICAgICAgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnbGluZWFyJykge1xyXG4gICAgICAgIGQubGluZSh0MiwgeSh5RGVzdCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnYmV6aWVyJykge1xyXG4gICAgICAgIGQuYmV6aWVyKHQxMiwgeSh5U291cmNlKSwgdDEyLCB5KHlEZXN0KSwgdDIsIHkoeURlc3QpKTtcclxuICAgICAgfVxyXG4gICAgICBkLmhvcml6b250YWwodDMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgdHJhdmVyc2UgPSBub2RlID0+IHtcclxuICAgICAgaWYgKG5vZGUueCA+IGxhc3RUaW1lcG9pbnQpIGxhc3RUaW1lcG9pbnQgPSBub2RlLng7XHJcblxyXG4gICAgICBpZiAobm9kZS5kZXB0aCA+IGRlZXBlc3REZXB0aCkgZGVlcGVzdERlcHRoID0gbm9kZS5kZXB0aDtcclxuICAgICAgaWYgKG5vZGUuc2l6ZSA+IGxhcmdlc3RTaXplKSBsYXJnZXN0U2l6ZSA9IG5vZGUuc2l6ZTtcclxuXHJcbiAgICAgIGlmICghIW5vZGUubmV4dCkge1xyXG4gICAgICAgIGxldCBkdCA9IG5vZGUubmV4dFswXS54IC0gbm9kZS54O1xyXG4gICAgICAgIGxldCB0MCA9IHgobm9kZS54KTtcclxuICAgICAgICBsZXQgdDEgPSB4KG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCkgKiBkdCk7XHJcbiAgICAgICAgbGV0IHQyID0geChub2RlLm5leHRbMF0ueCAtIDAuNSAqICgxIC0gcHJvcCkgKiBkdCk7XHJcbiAgICAgICAgbGV0IHQzID0geChub2RlLm5leHRbMF0ueCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5uZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgeTAgPSBub2RlLnkwO1xyXG4gICAgICAgICAgbGV0IHkxID0gbm9kZS55MTtcclxuICAgICAgICAgIGxldCBkZXN0ID0gbm9kZS5uZXh0W2ldO1xyXG5cclxuICAgICAgICAgIC8vIGRvbid0IGRyYXcgYW55dGhpbmcgZm9yIHN0cmVhbXMgd2l0aCB6ZXJvIGhlaWdodFxyXG4gICAgICAgICAgaWYgKHkxIC0geTAgPD0gMCAmJiBkZXN0LnkxIC0gZGVzdC55MCA8PSAwKSB7XHJcbiAgICAgICAgICAgIGQubW92ZSh0MywgeShkZXN0LnkwKSk7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKGRlc3QpO1xyXG4gICAgICAgICAgICBkLm1vdmUodDAsIHkoeTApKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRyYXdMaW5lKHQxLCB0MiwgdDMsIHkwLCBkZXN0LnkwKTsgLy8gYm90dG9tIGxpbmUgKGZvcndhcmRzKVxyXG4gICAgICAgICAgICB0cmF2ZXJzZShkZXN0KTtcclxuICAgICAgICAgICAgZHJhd0xpbmUodDIsIHQxLCB0MCwgZGVzdC55MSwgeTEpOyAvLyB0b3AgbGluZSAoYmFja3dhcmRzKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHRoaXMuX2RyYXdFbmQoZCwgbm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IHN0cmVhbSBvZiB0aGlzLl9zdHJlYW1Ob2Rlcykge1xyXG4gICAgICBkID0gbmV3IFN2Z1BhdGgoKTtcclxuICAgICAgLy8gcmVzZXQgYmVmb3JlIG5ldyB2YWx1ZXMgYXJlIGZvdW5kIGJ5IHRyYXZlcnNlXHJcbiAgICAgIGxhc3RUaW1lcG9pbnQgPSAwO1xyXG4gICAgICBkZWVwZXN0RGVwdGggPSAwO1xyXG4gICAgICBsYXJnZXN0U2l6ZSA9IDA7XHJcblxyXG4gICAgICB0aGlzLl9kcmF3U3RhcnQoZCwgc3RyZWFtKTtcclxuICAgICAgdHJhdmVyc2Uoc3RyZWFtKTtcclxuICAgICAgLy9kLmNsb3NlKCk7XHJcblxyXG4gICAgICAvLyBhZGQgc3BsaXRzXHJcblxyXG4gICAgICBsZXQgY2xpcFBhdGggPSBuZXcgU3ZnUGF0aCgpO1xyXG4gICAgICBsZXQgc3BsaXRzID0gdGhpcy5fZmluZFNwbGl0cyhzdHJlYW0ueCAtIDAuNSwgbGFzdFRpbWVwb2ludCArIDAuNSk7XHJcblxyXG4gICAgICBsZXQgY2xpcFN0YXJ0ID0geCgtMSk7XHJcbiAgICAgIGxldCB5MCA9IHkoMCk7XHJcbiAgICAgIGxldCB5MSA9IHkoMSk7XHJcbiAgICAgIGZvciAobGV0IHNwbGl0IG9mIHNwbGl0cykge1xyXG4gICAgICAgIC8vIHdlIG1vdmUgYnkgMC4wMDAxIHRvIGF2b2lkIGNhc2VzIGluIHdoaWNoIHRoZSBzcGxpdCBpcyBpbiB0aGUgbWlkZGxlIG9mIDIgbm9kZXNcclxuICAgICAgICBsZXQgY2xpcEVuZCA9IHgoXHJcbiAgICAgICAgICBzcGxpdCAtIDAuNSAqIHRoaXMuX2ZpbmRDbG9zZXN0Tm9kZShzdHJlYW0sIHNwbGl0IC0gMC4wMDAxKS5tYXJnaW5YXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKGNsaXBFbmQgLSBjbGlwU3RhcnQgPiAwKSB7XHJcbiAgICAgICAgICBjbGlwUGF0aC5tb3ZlKGNsaXBTdGFydCwgeTApO1xyXG4gICAgICAgICAgY2xpcFBhdGguaG9yaXpvbnRhbChjbGlwRW5kKTtcclxuICAgICAgICAgIGNsaXBQYXRoLnZlcnRpY2FsKHkxKTtcclxuICAgICAgICAgIC8qbGV0IGRpc3QgPSB5MS15MDtcclxuICAgICAgICAgIGxldCB6aWd6YWdzID0gMzAwO1xyXG4gICAgICAgICAgbGV0IHppZ3phZ1dpZHRoID0gNTtcclxuICAgICAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgemlnemFnczsgeisrKSB7XHJcbiAgICAgICAgICAgICAgbGV0IGRpciA9ICh6ICUgMiAqIDIgLSAxKTtcclxuICAgICAgICAgICAgICBjbGlwUGF0aC5saW5lRChkaXIgKiB6aWd6YWdXaWR0aCwgZGlzdC96aWd6YWdzKVxyXG4gICAgICAgICAgfSovXHJcblxyXG4gICAgICAgICAgY2xpcFBhdGguaG9yaXpvbnRhbChjbGlwU3RhcnQpO1xyXG4gICAgICAgICAgY2xpcFBhdGgudmVydGljYWwoeTApO1xyXG4gICAgICAgICAgLypmb3IgKGxldCB6ID0gMDsgeiA8IHppZ3phZ3M7IHorKykge1xyXG4gICAgICAgICAgICAgIGxldCBkaXIgPSAoeiAlIDIgKiAyIC0gMSk7XHJcbiAgICAgICAgICAgICAgY2xpcFBhdGgubGluZUQoZGlyICogemlnemFnV2lkdGgsIC1kaXN0L3ppZ3phZ3MpXHJcbiAgICAgICAgICB9Ki9cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xpcFN0YXJ0ID0geChcclxuICAgICAgICAgIHNwbGl0ICsgMC41ICogdGhpcy5fZmluZENsb3Nlc3ROb2RlKHN0cmVhbSwgc3BsaXQgKyAwLjAwMDEpLm1hcmdpblhcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGNsaXBQYXRoLm1vdmUoY2xpcFN0YXJ0LCB5MCk7XHJcbiAgICAgIGNsaXBQYXRoLmhvcml6b250YWwoeChsYXN0VGltZXBvaW50ICsgMSkpO1xyXG4gICAgICBjbGlwUGF0aC52ZXJ0aWNhbCh5MSk7XHJcbiAgICAgIGNsaXBQYXRoLmhvcml6b250YWwoY2xpcFN0YXJ0KTtcclxuICAgICAgY2xpcFBhdGgudmVydGljYWwoeTApO1xyXG5cclxuICAgICAgdGhpcy5fY2xpcFBhdGhzLnB1c2goe1xyXG4gICAgICAgIGlkOiBzdHJlYW0uc3RyZWFtSWQsXHJcbiAgICAgICAgcGF0aDogY2xpcFBhdGguZ2V0KClcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBmaW5kIHBvc2l0aW9uIHRvIHB1dCBhIHRleHQgbGFiZWxcclxuICAgICAgbGV0IHRleHRQb3M7XHJcbiAgICAgIGlmIChNYXRoLmFicyh5KHN0cmVhbS55MSkgLSB5KHN0cmVhbS55MCkpIDwgMjUpIHRleHRQb3MgPSAtMTtcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHkoc3RyZWFtLnkxKSA+IHkoc3RyZWFtLnkwKSkgdGV4dFBvcyA9IHkoc3RyZWFtLnkwKSArIDE1O1xyXG4gICAgICAgIGVsc2UgdGV4dFBvcyA9IHkoc3RyZWFtLnkxKSArIDE1O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc3RyZWFtT2JqID0ge1xyXG4gICAgICAgIHBhdGg6IGQuZ2V0KCksXHJcbiAgICAgICAgZGVwdGg6IHN0cmVhbS5kZXB0aCxcclxuICAgICAgICBkZWVwZXN0RGVwdGg6IGRlZXBlc3REZXB0aCxcclxuICAgICAgICBsYXJnZXN0U2l6ZTogbGFyZ2VzdFNpemUsXHJcbiAgICAgICAgaWQ6IHN0cmVhbS5zdHJlYW1JZCxcclxuICAgICAgICBkYXRhOiBzdHJlYW0uZGF0YSxcclxuICAgICAgICB0ZXh0UG9zOiB7XHJcbiAgICAgICAgICB4OiB4KHN0cmVhbS54IC0gMC41ICogKDEgLSB0aGlzLl9wcm9wb3J0aW9uKSArIDAuNSAqIHN0cmVhbS5tYXJnaW5YKSxcclxuICAgICAgICAgIHk6IHRleHRQb3NcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLl9zdHJlYW1zLnB1c2goc3RyZWFtT2JqKTtcclxuICAgICAgLy8gaWYgKCF0aGlzLl9zdHJlYW1zW3N0cmVhbS5kZXB0aF0pXHJcbiAgICAgIC8vICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5kZXB0aF0gPSBbXTtcclxuICAgICAgLy8gdGhpcy5fc3RyZWFtc1tzdHJlYW0uZGVwdGhdLnB1c2goc3RyZWFtT2JqKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXQVJOSU5HOiBUaGlzIHdhcyBhIGZpeCBmb3I6IFwiaWYgc3RyZWFtIElEcyBhcmUgc3RyaW5ncywgdGhlIGNsaXBQYXRoIGFycmF5IGhhcyBhbiBlbXB0eSB2YWx1ZSBpbiB0aGUgYmVnaW5uaW5nIC0tPiByZW1vdmVcIlxyXG4gICAgLy8gQnV0IGluc3RlYWQgaXQganVzdCByZW1vdmVzIGFsbCBjbGlwUGF0aHMgd2hpY2ggaGF2ZSBzdHJpbmcgYXMgYW4gSURcclxuICAgIC8vdGhpcy5fY2xpcFBhdGhzID0gdGhpcy5fY2xpcFBhdGhzLmZpbHRlcihkID0+IGQpO1xyXG5cclxuICAgIC8vIFRPRE86IGFwcGx5IGFuIG9yZGVyIGluIHdoaWNoIGNoaWxkcmVuIGFyZSBkcmF3biBjb3JyZWN0bHlcclxuICAgIC8vIHRoaXMuX3N0cmVhbXMuc29ydCgoYSxiKSA9PiAoYS5kZXB0aCA8IGIuZGVwdGgpID8gLTEgOiAxKVxyXG4gICAgdGhpcy5fc3RyZWFtcy5zb3J0KChhLCBiKSA9PiAoYS5kZWVwZXN0RGVwdGggPCBiLmRlZXBlc3REZXB0aCA/IC0xIDogMSkpO1xyXG4gICAgLy90aGlzLl9zdHJlYW1zLnNvcnQoKGEsYikgPT4gYS5pZCA8IGIuaWQgPyAtMTogMSlcclxuICAgIC8vdGhpcy5fc3RyZWFtcy5yZXZlcnNlKCk7XHJcbiAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SplitStreamData.js\n"
          );

          /***/
        },

      /***/ './src/SplitStreamFilter.js':
        /*!**********************************!*\
  !*** ./src/SplitStreamFilter.js ***!
  \**********************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SplitStreamFilter; });\n/* harmony import */ var flatted_esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatted/esm */ "./node_modules/flatted/esm/index.js");\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SplitStreamInputData.js */ "./src/SplitStreamInputData.js");\n\r\n\r\n\r\nclass SplitStreamFilter {\r\n  // expects SplitStreamInputData.data as input\r\n  constructor(inputData, options = {}) {\r\n    this._opts = {\r\n      ...options // overwrite default settings with user settings\r\n    };\r\n    if (!inputData instanceof _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_1__["default"])\r\n      throw Exeption(\'Added data is not an instance of SplitStreamData\');\r\n    this.__inputData = inputData;\r\n    this._filteredData;\r\n    this._lastMaxDepth = 0;\r\n    this._reset();\r\n  }\r\n\r\n  get data() {\r\n    return this._filteredData;\r\n  }\r\n\r\n  _reset() {\r\n    let json = Object(flatted_esm__WEBPACK_IMPORTED_MODULE_0__["stringify"])(this.__inputData.data);\r\n    this._filteredData = Object(flatted_esm__WEBPACK_IMPORTED_MODULE_0__["parse"])(json);\r\n    this._filteredData.timesteps = this._filteredData.timesteps.filter(d => d);\r\n    return this;\r\n  }\r\n\r\n  maxDepth(maxDepth) {\r\n    // if (maxDepth > this._lastMaxDepth) this._reset();\r\n\r\n    let traverse = node => {\r\n      if (node.depth >= maxDepth) {\r\n        node.children = [];\r\n      } else {\r\n        if (!!node.children) for (let child of node.children) traverse(child);\r\n      }\r\n    };\r\n\r\n    for (let time of this._filteredData.timesteps) {\r\n      if (!!time)\r\n        // TODO: Check why some entries are empty\r\n        traverse(time.tree);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  branch(branchNr) {\r\n    branchNr = +branchNr;\r\n    // this._reset();\r\n    for (let time of this._filteredData.timesteps) {\r\n      if (!!time) {\r\n        // TODO: Check why some entries are empty\r\n        let branches = time.tree.children;\r\n        // remove branches after branchNr\r\n        if (branchNr < branches.length - 1) branches.splice(branchNr + 1);\r\n        // remove branches before branchNr\r\n        if (branchNr > 0) branches.splice(0, branchNr);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  select(nodeId) {}\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1GaWx0ZXIuanM/ZTJkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNjOztBQUU5QztBQUNmO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnRUFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsNkRBQVM7QUFDeEIseUJBQXlCLHlEQUFLO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3BsaXRTdHJlYW1GaWx0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSwgc3RyaW5naWZ5IH0gZnJvbSAnZmxhdHRlZC9lc20nO1xyXG5pbXBvcnQgU3BsaXRTdHJlYW1JbnB1dERhdGEgZnJvbSAnLi9TcGxpdFN0cmVhbUlucHV0RGF0YS5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdFN0cmVhbUZpbHRlciB7XHJcbiAgLy8gZXhwZWN0cyBTcGxpdFN0cmVhbUlucHV0RGF0YS5kYXRhIGFzIGlucHV0XHJcbiAgY29uc3RydWN0b3IoaW5wdXREYXRhLCBvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMuX29wdHMgPSB7XHJcbiAgICAgIC4uLm9wdGlvbnMgLy8gb3ZlcndyaXRlIGRlZmF1bHQgc2V0dGluZ3Mgd2l0aCB1c2VyIHNldHRpbmdzXHJcbiAgICB9O1xyXG4gICAgaWYgKCFpbnB1dERhdGEgaW5zdGFuY2VvZiBTcGxpdFN0cmVhbUlucHV0RGF0YSlcclxuICAgICAgdGhyb3cgRXhlcHRpb24oJ0FkZGVkIGRhdGEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFNwbGl0U3RyZWFtRGF0YScpO1xyXG4gICAgdGhpcy5fX2lucHV0RGF0YSA9IGlucHV0RGF0YTtcclxuICAgIHRoaXMuX2ZpbHRlcmVkRGF0YTtcclxuICAgIHRoaXMuX2xhc3RNYXhEZXB0aCA9IDA7XHJcbiAgICB0aGlzLl9yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWREYXRhO1xyXG4gIH1cclxuXHJcbiAgX3Jlc2V0KCkge1xyXG4gICAgbGV0IGpzb24gPSBzdHJpbmdpZnkodGhpcy5fX2lucHV0RGF0YS5kYXRhKTtcclxuICAgIHRoaXMuX2ZpbHRlcmVkRGF0YSA9IHBhcnNlKGpzb24pO1xyXG4gICAgdGhpcy5fZmlsdGVyZWREYXRhLnRpbWVzdGVwcyA9IHRoaXMuX2ZpbHRlcmVkRGF0YS50aW1lc3RlcHMuZmlsdGVyKGQgPT4gZCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIG1heERlcHRoKG1heERlcHRoKSB7XHJcbiAgICAvLyBpZiAobWF4RGVwdGggPiB0aGlzLl9sYXN0TWF4RGVwdGgpIHRoaXMuX3Jlc2V0KCk7XHJcblxyXG4gICAgbGV0IHRyYXZlcnNlID0gbm9kZSA9PiB7XHJcbiAgICAgIGlmIChub2RlLmRlcHRoID49IG1heERlcHRoKSB7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghIW5vZGUuY2hpbGRyZW4pIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHRyYXZlcnNlKGNoaWxkKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmb3IgKGxldCB0aW1lIG9mIHRoaXMuX2ZpbHRlcmVkRGF0YS50aW1lc3RlcHMpIHtcclxuICAgICAgaWYgKCEhdGltZSlcclxuICAgICAgICAvLyBUT0RPOiBDaGVjayB3aHkgc29tZSBlbnRyaWVzIGFyZSBlbXB0eVxyXG4gICAgICAgIHRyYXZlcnNlKHRpbWUudHJlZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGJyYW5jaChicmFuY2hOcikge1xyXG4gICAgYnJhbmNoTnIgPSArYnJhbmNoTnI7XHJcbiAgICAvLyB0aGlzLl9yZXNldCgpO1xyXG4gICAgZm9yIChsZXQgdGltZSBvZiB0aGlzLl9maWx0ZXJlZERhdGEudGltZXN0ZXBzKSB7XHJcbiAgICAgIGlmICghIXRpbWUpIHtcclxuICAgICAgICAvLyBUT0RPOiBDaGVjayB3aHkgc29tZSBlbnRyaWVzIGFyZSBlbXB0eVxyXG4gICAgICAgIGxldCBicmFuY2hlcyA9IHRpbWUudHJlZS5jaGlsZHJlbjtcclxuICAgICAgICAvLyByZW1vdmUgYnJhbmNoZXMgYWZ0ZXIgYnJhbmNoTnJcclxuICAgICAgICBpZiAoYnJhbmNoTnIgPCBicmFuY2hlcy5sZW5ndGggLSAxKSBicmFuY2hlcy5zcGxpY2UoYnJhbmNoTnIgKyAxKTtcclxuICAgICAgICAvLyByZW1vdmUgYnJhbmNoZXMgYmVmb3JlIGJyYW5jaE5yXHJcbiAgICAgICAgaWYgKGJyYW5jaE5yID4gMCkgYnJhbmNoZXMuc3BsaWNlKDAsIGJyYW5jaE5yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBzZWxlY3Qobm9kZUlkKSB7fVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SplitStreamFilter.js\n'
          );

          /***/
        },

      /***/ './src/SplitStreamInputData.js':
        /*!*************************************!*\
  !*** ./src/SplitStreamInputData.js ***!
  \*************************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStreamInputData; });\nclass SplitStreamInputData {\r\n  constructor(options = {}) {\r\n    this._opts = {\r\n      forceFakeRoot: false,\r\n      ...options // overwrite default settings with user settings\r\n    };\r\n    // hold a tree (root node) for each timestep\r\n    // hold a reference array which includes all nodes present in a single timestep\r\n    this._timesteps = [];\r\n    this._numNodes = 0;\r\n  }\r\n\r\n  get data() {\r\n    return { timesteps: this._timesteps, numNodes: this._numNodes };\r\n  }\r\n\r\n  addNode(t, id, size = undefined, pos = undefined, data = undefined) {\r\n    if (!this._timesteps[t]) this._createTimestep(t);\r\n\r\n    if (!this._timesteps[t].references[id]) {\r\n      let dataSize = +size;\r\n      let dataPos = +pos;\r\n      id = String(id);\r\n      // size = +size;\r\n      // pos = +pos;\r\n      this._timesteps[t].references[id] = {\r\n        id,\r\n        dataSize,\r\n        dataPos,\r\n        size,\r\n        pos,\r\n        data\r\n      };\r\n      this._numNodes++;\r\n    } else; // console.log(`Warning AddNode: Node ${id} at timestep ${t} exists already.`);\r\n  }\r\n\r\n  addParent(t, id, pId) {\r\n    if (!pId) return;\r\n    let nodes = this._timesteps[t].references;\r\n    let node = nodes[id];\r\n    let parent = nodes[pId];\r\n    if (!node) {\r\n      // console.log(`Error 'addParent': Node '${id}' does not exist.`);\r\n      return;\r\n    }\r\n    if (!parent) {\r\n      // console.log(`Error 'addParent': Parent node '${pId}' does not exist.`);\r\n      return;\r\n    }\r\n    node.parent = parent;\r\n    if (!parent.children) parent.children = [];\r\n    parent.children.push(node);\r\n  }\r\n\r\n  addNext(t, id, nextId) {\r\n    let time1 = this._timesteps[t];\r\n    let time2 = this._timesteps[+t + 1];\r\n    if (!time1 || !time2) {\r\n      // console.log(`Error 'addNext': Timestep '${+t + 1}' does not exist.`);\r\n      return false;\r\n    }\r\n\r\n    let node = time1.references[id];\r\n    let nextNode = time2.references[nextId];\r\n    if (!node || !nextNode) {\r\n      // console.log(`Error 'addNext': Node '${id}' does not exist.`);\r\n      return false;\r\n    }\r\n\r\n    // console.log(`Change timestep ${t}: ${id} to ${nextId}`);\r\n    if (!node.next) node.next = [];\r\n    node.next.push(nextNode);\r\n    if (!nextNode.prev) nextNode.prev = [];\r\n    nextNode.prev.push(node);\r\n    return true;\r\n  }\r\n\r\n  finalize() {\r\n    this._checkParents();\r\n\r\n    this.__forEachNodeDepthFirst((node, depth) => {\r\n      this._setSizeAndAggregate(node);\r\n      node.depth = depth;\r\n      this._checkSize(node);\r\n      this._checkPositions(node);\r\n    });\r\n  }\r\n\r\n  // check if all nodes except the root have a parent\r\n  // if multiple roots exist, create a fake root\r\n  _checkParents() {\r\n    let nodesWithoutParents = {};\r\n    for (let t in this._timesteps) {\r\n      let nodes = this._timesteps[t].references;\r\n      for (let id in nodes) {\r\n        let node = nodes[id];\r\n        if (!node.parent) {\r\n          if (!nodesWithoutParents[t]) nodesWithoutParents[t] = [];\r\n          nodesWithoutParents[t].push(node);\r\n        }\r\n      }\r\n    }\r\n\r\n    let fakeRootNeeded = false;\r\n    for (let t in nodesWithoutParents) {\r\n      if (nodesWithoutParents[t].length > 1) {\r\n        fakeRootNeeded = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (fakeRootNeeded || this._opts.forceFakeRoot) {\r\n      let prevT;\r\n      for (let t in nodesWithoutParents) {\r\n        this.addNode(t, 'fakeRoot');\r\n        nodesWithoutParents[t].forEach(node => {\r\n          this.addParent(t, node.id, 'fakeRoot');\r\n          this._timesteps[t].tree = this._timesteps[t].references['fakeRoot'];\r\n        });\r\n        // connect fake roots\r\n        if (!!prevT) {\r\n          this.addNext(prevT, 'fakeRoot', 'fakeRoot');\r\n        }\r\n        prevT = t;\r\n      }\r\n    } else {\r\n      // every timepoint has a single root node\r\n      for (let t in nodesWithoutParents) {\r\n        this._timesteps[t].tree = nodesWithoutParents[t][0];\r\n      }\r\n    }\r\n  }\r\n\r\n  _setSizeAndAggregate(node) {\r\n    if (!!node.children) {\r\n      node.aggregate = 0;\r\n      for (let child of node.children) node.aggregate += child.dataSize;\r\n      if (Number.isNaN(node.dataSize)) node.dataSize = node.aggregate;\r\n    } else {\r\n      if (Number.isNaN(node.dataSize)) node.dataSize = 1;\r\n      node.aggregate = node.dataSize;\r\n    }\r\n  }\r\n\r\n  _checkSize(node) {\r\n    if (node.dataSize < node.aggregate) {\r\n      // console.log('Error: Node has a smaller size than its children.');\r\n      // console.log(node);\r\n    }\r\n  }\r\n\r\n  // check if size of parent elements is bigger than the aggregate of the sizes of its children\r\n  _checkPositions(node) {\r\n    if (!!node.children) {\r\n      let minPos = 0;\r\n      for (let child of node.children) {\r\n        if (child.pos >= 0) {\r\n          if (minPos > child.pos) {\r\n            // console.log('Error: Children positions overlap each other.');\r\n            // console.log(node);\r\n          }\r\n          minPos = child.pos + child.dataSize;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  __forEachNodeDepthFirst(callback) {\r\n    let traverse = function(node, depth) {\r\n      if (!!node.children)\r\n        node.children.forEach(child => traverse(child, depth + 1));\r\n      callback(node, depth);\r\n    };\r\n\r\n    for (let t in this._timesteps) traverse(this._timesteps[t].tree, 0);\r\n  }\r\n\r\n  _createTimestep(t) {\r\n    this._timesteps[t] = {\r\n      references: {},\r\n      tree: null\r\n    };\r\n  }\r\n\r\n  // connect nodes which have the same ID in consecutive timesteps\r\n  buildTimeConnections() {\r\n    for (let t in this._timesteps) {\r\n      if (!!this._timesteps[+t + 1]) {\r\n        let nodes = this._timesteps[t].references;\r\n        let nodes2 = this._timesteps[+t + 1].references;\r\n        for (let id in nodes) {\r\n          if (!!nodes2[id]) {\r\n            // do not build connections if the nodes next elements were manually set\r\n            if (!nodes[id].next) nodes[id].next = [nodes2[id]];\r\n            if (!nodes2[id].prev) nodes2[id].prev = [nodes[id]];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1JbnB1dERhdGEuanM/ZGZkOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQWU7QUFDZiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxNQUFNLHlDQUF5QyxHQUFHLGVBQWUsRUFBRTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHO0FBQ2xEO0FBQ0E7O0FBRUEsc0NBQXNDLEVBQUUsSUFBSSxHQUFHLE1BQU0sT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9TcGxpdFN0cmVhbUlucHV0RGF0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0U3RyZWFtSW5wdXREYXRhIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMuX29wdHMgPSB7XHJcbiAgICAgIGZvcmNlRmFrZVJvb3Q6IGZhbHNlLFxyXG4gICAgICAuLi5vcHRpb25zIC8vIG92ZXJ3cml0ZSBkZWZhdWx0IHNldHRpbmdzIHdpdGggdXNlciBzZXR0aW5nc1xyXG4gICAgfTtcclxuICAgIC8vIGhvbGQgYSB0cmVlIChyb290IG5vZGUpIGZvciBlYWNoIHRpbWVzdGVwXHJcbiAgICAvLyBob2xkIGEgcmVmZXJlbmNlIGFycmF5IHdoaWNoIGluY2x1ZGVzIGFsbCBub2RlcyBwcmVzZW50IGluIGEgc2luZ2xlIHRpbWVzdGVwXHJcbiAgICB0aGlzLl90aW1lc3RlcHMgPSBbXTtcclxuICAgIHRoaXMuX251bU5vZGVzID0gMDtcclxuICB9XHJcblxyXG4gIGdldCBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHsgdGltZXN0ZXBzOiB0aGlzLl90aW1lc3RlcHMsIG51bU5vZGVzOiB0aGlzLl9udW1Ob2RlcyB9O1xyXG4gIH1cclxuXHJcbiAgYWRkTm9kZSh0LCBpZCwgc2l6ZSA9IHVuZGVmaW5lZCwgcG9zID0gdW5kZWZpbmVkLCBkYXRhID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAoIXRoaXMuX3RpbWVzdGVwc1t0XSkgdGhpcy5fY3JlYXRlVGltZXN0ZXAodCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlc1tpZF0pIHtcclxuICAgICAgbGV0IGRhdGFTaXplID0gK3NpemU7XHJcbiAgICAgIGxldCBkYXRhUG9zID0gK3BvcztcclxuICAgICAgaWQgPSBTdHJpbmcoaWQpO1xyXG4gICAgICAvLyBzaXplID0gK3NpemU7XHJcbiAgICAgIC8vIHBvcyA9ICtwb3M7XHJcbiAgICAgIHRoaXMuX3RpbWVzdGVwc1t0XS5yZWZlcmVuY2VzW2lkXSA9IHtcclxuICAgICAgICBpZCxcclxuICAgICAgICBkYXRhU2l6ZSxcclxuICAgICAgICBkYXRhUG9zLFxyXG4gICAgICAgIHNpemUsXHJcbiAgICAgICAgcG9zLFxyXG4gICAgICAgIGRhdGFcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fbnVtTm9kZXMrKztcclxuICAgIH0gZWxzZTsgLy8gY29uc29sZS5sb2coYFdhcm5pbmcgQWRkTm9kZTogTm9kZSAke2lkfSBhdCB0aW1lc3RlcCAke3R9IGV4aXN0cyBhbHJlYWR5LmApO1xyXG4gIH1cclxuXHJcbiAgYWRkUGFyZW50KHQsIGlkLCBwSWQpIHtcclxuICAgIGlmICghcElkKSByZXR1cm47XHJcbiAgICBsZXQgbm9kZXMgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlcztcclxuICAgIGxldCBub2RlID0gbm9kZXNbaWRdO1xyXG4gICAgbGV0IHBhcmVudCA9IG5vZGVzW3BJZF07XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coYEVycm9yICdhZGRQYXJlbnQnOiBOb2RlICcke2lkfScgZG9lcyBub3QgZXhpc3QuYCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghcGFyZW50KSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBFcnJvciAnYWRkUGFyZW50JzogUGFyZW50IG5vZGUgJyR7cElkfScgZG9lcyBub3QgZXhpc3QuYCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xyXG4gICAgaWYgKCFwYXJlbnQuY2hpbGRyZW4pIHBhcmVudC5jaGlsZHJlbiA9IFtdO1xyXG4gICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XHJcbiAgfVxyXG5cclxuICBhZGROZXh0KHQsIGlkLCBuZXh0SWQpIHtcclxuICAgIGxldCB0aW1lMSA9IHRoaXMuX3RpbWVzdGVwc1t0XTtcclxuICAgIGxldCB0aW1lMiA9IHRoaXMuX3RpbWVzdGVwc1srdCArIDFdO1xyXG4gICAgaWYgKCF0aW1lMSB8fCAhdGltZTIpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coYEVycm9yICdhZGROZXh0JzogVGltZXN0ZXAgJyR7K3QgKyAxfScgZG9lcyBub3QgZXhpc3QuYCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbm9kZSA9IHRpbWUxLnJlZmVyZW5jZXNbaWRdO1xyXG4gICAgbGV0IG5leHROb2RlID0gdGltZTIucmVmZXJlbmNlc1tuZXh0SWRdO1xyXG4gICAgaWYgKCFub2RlIHx8ICFuZXh0Tm9kZSkge1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhgRXJyb3IgJ2FkZE5leHQnOiBOb2RlICcke2lkfScgZG9lcyBub3QgZXhpc3QuYCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyhgQ2hhbmdlIHRpbWVzdGVwICR7dH06ICR7aWR9IHRvICR7bmV4dElkfWApO1xyXG4gICAgaWYgKCFub2RlLm5leHQpIG5vZGUubmV4dCA9IFtdO1xyXG4gICAgbm9kZS5uZXh0LnB1c2gobmV4dE5vZGUpO1xyXG4gICAgaWYgKCFuZXh0Tm9kZS5wcmV2KSBuZXh0Tm9kZS5wcmV2ID0gW107XHJcbiAgICBuZXh0Tm9kZS5wcmV2LnB1c2gobm9kZSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGZpbmFsaXplKCkge1xyXG4gICAgdGhpcy5fY2hlY2tQYXJlbnRzKCk7XHJcblxyXG4gICAgdGhpcy5fX2ZvckVhY2hOb2RlRGVwdGhGaXJzdCgobm9kZSwgZGVwdGgpID0+IHtcclxuICAgICAgdGhpcy5fc2V0U2l6ZUFuZEFnZ3JlZ2F0ZShub2RlKTtcclxuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoO1xyXG4gICAgICB0aGlzLl9jaGVja1NpemUobm9kZSk7XHJcbiAgICAgIHRoaXMuX2NoZWNrUG9zaXRpb25zKG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBpZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSByb290IGhhdmUgYSBwYXJlbnRcclxuICAvLyBpZiBtdWx0aXBsZSByb290cyBleGlzdCwgY3JlYXRlIGEgZmFrZSByb290XHJcbiAgX2NoZWNrUGFyZW50cygpIHtcclxuICAgIGxldCBub2Rlc1dpdGhvdXRQYXJlbnRzID0ge307XHJcbiAgICBmb3IgKGxldCB0IGluIHRoaXMuX3RpbWVzdGVwcykge1xyXG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlcztcclxuICAgICAgZm9yIChsZXQgaWQgaW4gbm9kZXMpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2lkXTtcclxuICAgICAgICBpZiAoIW5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICBpZiAoIW5vZGVzV2l0aG91dFBhcmVudHNbdF0pIG5vZGVzV2l0aG91dFBhcmVudHNbdF0gPSBbXTtcclxuICAgICAgICAgIG5vZGVzV2l0aG91dFBhcmVudHNbdF0ucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgZmFrZVJvb3ROZWVkZWQgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IHQgaW4gbm9kZXNXaXRob3V0UGFyZW50cykge1xyXG4gICAgICBpZiAobm9kZXNXaXRob3V0UGFyZW50c1t0XS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZmFrZVJvb3ROZWVkZWQgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZha2VSb290TmVlZGVkIHx8IHRoaXMuX29wdHMuZm9yY2VGYWtlUm9vdCkge1xyXG4gICAgICBsZXQgcHJldlQ7XHJcbiAgICAgIGZvciAobGV0IHQgaW4gbm9kZXNXaXRob3V0UGFyZW50cykge1xyXG4gICAgICAgIHRoaXMuYWRkTm9kZSh0LCAnZmFrZVJvb3QnKTtcclxuICAgICAgICBub2Rlc1dpdGhvdXRQYXJlbnRzW3RdLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmFkZFBhcmVudCh0LCBub2RlLmlkLCAnZmFrZVJvb3QnKTtcclxuICAgICAgICAgIHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlID0gdGhpcy5fdGltZXN0ZXBzW3RdLnJlZmVyZW5jZXNbJ2Zha2VSb290J107XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY29ubmVjdCBmYWtlIHJvb3RzXHJcbiAgICAgICAgaWYgKCEhcHJldlQpIHtcclxuICAgICAgICAgIHRoaXMuYWRkTmV4dChwcmV2VCwgJ2Zha2VSb290JywgJ2Zha2VSb290Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZUID0gdDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZXZlcnkgdGltZXBvaW50IGhhcyBhIHNpbmdsZSByb290IG5vZGVcclxuICAgICAgZm9yIChsZXQgdCBpbiBub2Rlc1dpdGhvdXRQYXJlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5fdGltZXN0ZXBzW3RdLnRyZWUgPSBub2Rlc1dpdGhvdXRQYXJlbnRzW3RdWzBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfc2V0U2l6ZUFuZEFnZ3JlZ2F0ZShub2RlKSB7XHJcbiAgICBpZiAoISFub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgIG5vZGUuYWdncmVnYXRlID0gMDtcclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikgbm9kZS5hZ2dyZWdhdGUgKz0gY2hpbGQuZGF0YVNpemU7XHJcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4obm9kZS5kYXRhU2l6ZSkpIG5vZGUuZGF0YVNpemUgPSBub2RlLmFnZ3JlZ2F0ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4obm9kZS5kYXRhU2l6ZSkpIG5vZGUuZGF0YVNpemUgPSAxO1xyXG4gICAgICBub2RlLmFnZ3JlZ2F0ZSA9IG5vZGUuZGF0YVNpemU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfY2hlY2tTaXplKG5vZGUpIHtcclxuICAgIGlmIChub2RlLmRhdGFTaXplIDwgbm9kZS5hZ2dyZWdhdGUpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coJ0Vycm9yOiBOb2RlIGhhcyBhIHNtYWxsZXIgc2l6ZSB0aGFuIGl0cyBjaGlsZHJlbi4nKTtcclxuICAgICAgLy8gY29uc29sZS5sb2cobm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBpZiBzaXplIG9mIHBhcmVudCBlbGVtZW50cyBpcyBiaWdnZXIgdGhhbiB0aGUgYWdncmVnYXRlIG9mIHRoZSBzaXplcyBvZiBpdHMgY2hpbGRyZW5cclxuICBfY2hlY2tQb3NpdGlvbnMobm9kZSkge1xyXG4gICAgaWYgKCEhbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICBsZXQgbWluUG9zID0gMDtcclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChjaGlsZC5wb3MgPj0gMCkge1xyXG4gICAgICAgICAgaWYgKG1pblBvcyA+IGNoaWxkLnBvcykge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRXJyb3I6IENoaWxkcmVuIHBvc2l0aW9ucyBvdmVybGFwIGVhY2ggb3RoZXIuJyk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbWluUG9zID0gY2hpbGQucG9zICsgY2hpbGQuZGF0YVNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX2ZvckVhY2hOb2RlRGVwdGhGaXJzdChjYWxsYmFjaykge1xyXG4gICAgbGV0IHRyYXZlcnNlID0gZnVuY3Rpb24obm9kZSwgZGVwdGgpIHtcclxuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbilcclxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdHJhdmVyc2UoY2hpbGQsIGRlcHRoICsgMSkpO1xyXG4gICAgICBjYWxsYmFjayhub2RlLCBkZXB0aCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IHQgaW4gdGhpcy5fdGltZXN0ZXBzKSB0cmF2ZXJzZSh0aGlzLl90aW1lc3RlcHNbdF0udHJlZSwgMCk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlVGltZXN0ZXAodCkge1xyXG4gICAgdGhpcy5fdGltZXN0ZXBzW3RdID0ge1xyXG4gICAgICByZWZlcmVuY2VzOiB7fSxcclxuICAgICAgdHJlZTogbnVsbFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIGNvbm5lY3Qgbm9kZXMgd2hpY2ggaGF2ZSB0aGUgc2FtZSBJRCBpbiBjb25zZWN1dGl2ZSB0aW1lc3RlcHNcclxuICBidWlsZFRpbWVDb25uZWN0aW9ucygpIHtcclxuICAgIGZvciAobGV0IHQgaW4gdGhpcy5fdGltZXN0ZXBzKSB7XHJcbiAgICAgIGlmICghIXRoaXMuX3RpbWVzdGVwc1srdCArIDFdKSB7XHJcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5fdGltZXN0ZXBzW3RdLnJlZmVyZW5jZXM7XHJcbiAgICAgICAgbGV0IG5vZGVzMiA9IHRoaXMuX3RpbWVzdGVwc1srdCArIDFdLnJlZmVyZW5jZXM7XHJcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gbm9kZXMpIHtcclxuICAgICAgICAgIGlmICghIW5vZGVzMltpZF0pIHtcclxuICAgICAgICAgICAgLy8gZG8gbm90IGJ1aWxkIGNvbm5lY3Rpb25zIGlmIHRoZSBub2RlcyBuZXh0IGVsZW1lbnRzIHdlcmUgbWFudWFsbHkgc2V0XHJcbiAgICAgICAgICAgIGlmICghbm9kZXNbaWRdLm5leHQpIG5vZGVzW2lkXS5uZXh0ID0gW25vZGVzMltpZF1dO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVzMltpZF0ucHJldikgbm9kZXMyW2lkXS5wcmV2ID0gW25vZGVzW2lkXV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SplitStreamInputData.js\n"
          );

          /***/
        },

      /***/ './src/SvgPath.js':
        /*!************************!*\
  !*** ./src/SvgPath.js ***!
  \************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SvgPath; });\nconst ACTION = {\r\n  MOVE: 0,\r\n  MOVE_D: 1,\r\n  LINE: 2,\r\n  LINE_D: 3,\r\n  HORIZONTAL: 4,\r\n  HORIZONTAL_D: 5,\r\n  VERTICAL: 6,\r\n  VERTICAL_D: 7,\r\n  BEZIER: 8,\r\n  BEZIER_D: 9,\r\n  ARC: 10\r\n};\r\n\r\nclass SvgPath {\r\n  constructor() {\r\n    this._path = '';\r\n    this._x;\r\n    this._y;\r\n    this._precision = 2;\r\n    this._lastAction;\r\n  }\r\n\r\n  // ignore a change, if its end coordinate is the same as its current position\r\n  _pathWillChange(x, y) {\r\n    if (Number.isNaN(x) || Number.isNaN(y)); //debugger;\r\n    if (x !== this._x || y !== this._y) {\r\n      this._x = x;\r\n      this._y = y;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  _applyPrecision(...numbers) {\r\n    return numbers.map(d => +d.toFixed(this._precision));\r\n  }\r\n\r\n  get() {\r\n    return this._path;\r\n  }\r\n\r\n  move(x, y) {\r\n    [x, y] = this._applyPrecision(x, y);\r\n    if (this._pathWillChange(x, y)) {\r\n      if (this._lastAction == ACTION.MOVE)\r\n        // remove last move from string\r\n        this._path = this._path.slice(0, this._path.lastIndexOf('M'));\r\n      this._path += 'M ' + x + ' ' + y + ' ';\r\n      this._lastAction = ACTION.MOVE;\r\n    }\r\n  }\r\n\r\n  moveD(dx, dy) {\r\n    [dx, dy] = this._applyPrecision(dx, dy);\r\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\r\n      this._path += 'm ' + dx + ' ' + dy + ' ';\r\n      this._lastAction = ACTION.MOVE_D;\r\n    }\r\n  }\r\n\r\n  line(x, y) {\r\n    [x, y] = this._applyPrecision(x, y);\r\n    if (this._pathWillChange(x, y)) {\r\n      this._path += 'L ' + x + ' ' + y + ' ';\r\n      this._lastAction = ACTION.LINE;\r\n    }\r\n  }\r\n\r\n  lineD(dx, dy) {\r\n    [dx, dy] = this._applyPrecision(dx, dy);\r\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\r\n      this._path += 'l ' + dx + ' ' + dy + ' ';\r\n      this._lastAction = ACTION.LINE_D;\r\n    }\r\n  }\r\n\r\n  horizontal(x) {\r\n    [x] = this._applyPrecision(x);\r\n    if (this._pathWillChange(x, this._y)) {\r\n      if (this._lastAction == ACTION.HORIZONTAL)\r\n        // remove last move from string\r\n        this._path = this._path.slice(0, this._path.lastIndexOf('H'));\r\n      this._path += 'H ' + x + ' ';\r\n      this._lastAction = ACTION.HORIZONTAL;\r\n    }\r\n  }\r\n\r\n  horizontalD(dx) {\r\n    [dx] = this._applyPrecision(dx);\r\n    if (this._pathWillChange(this._x + dx, this._y)) {\r\n      this._path += 'h ' + dx + ' ';\r\n      this._lastAction = ACTION.HORIZONTAL_D;\r\n    }\r\n  }\r\n\r\n  vertical(y) {\r\n    [y] = this._applyPrecision(y);\r\n    if (this._pathWillChange(this._x, y)) {\r\n      if (this._lastAction == ACTION.VERTICAL)\r\n        // remove last move from string\r\n        this._path = this._path.slice(0, this._path.lastIndexOf('V'));\r\n      this._path += 'V ' + y + ' ';\r\n      this._lastAction = ACTION.VERTICAL;\r\n    }\r\n  }\r\n\r\n  verticalD(dy) {\r\n    [dy] = this._applyPrecision(dy);\r\n    if (this._pathWillChange(this._x, this._y + dy)) {\r\n      this._path += 'v ' + dy + ' ';\r\n      this._lastAction = ACTION.VERTICAL_D;\r\n    }\r\n  }\r\n\r\n  bezier(x1, y1, x2, y2, x, y) {\r\n    [x1, y1, x2, y2, x, y] = this._applyPrecision(x1, y1, x2, y2, x, y);\r\n    if (this._pathWillChange(x, y)) {\r\n      this._path +=\r\n        'C ' + x1 + ' ' + y1 + ', ' + x2 + ' ' + y2 + ', ' + x + ' ' + y + ' ';\r\n      this._lastAction = ACTION.BEZIER;\r\n    }\r\n  }\r\n\r\n  bezierD(dx1, dy1, dx2, dy2, dx, dy) {\r\n    [dx1, dy1, dx2, dy2, dx, dy] = this._applyPrecision(\r\n      dx1,\r\n      dy1,\r\n      dx2,\r\n      dy2,\r\n      dx,\r\n      dy\r\n    );\r\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\r\n      this._path +=\r\n        'c ' +\r\n        dx1 +\r\n        ' ' +\r\n        dy1 +\r\n        ', ' +\r\n        dx2 +\r\n        ' ' +\r\n        dy2 +\r\n        ', ' +\r\n        dx +\r\n        ' ' +\r\n        dy +\r\n        ' ';\r\n      this._lastAction = ACTION.BEZIER_D;\r\n    }\r\n  }\r\n\r\n  arc(rx, ry, rot, largeArcFlag, sweepFlag, x, y) {\r\n    [rx, ry, rot, largeArcFlag, sweepFlag, x, y] = this._applyPrecision(\r\n      rx,\r\n      ry,\r\n      rot,\r\n      largeArcFlag,\r\n      sweepFlag,\r\n      x,\r\n      y\r\n    );\r\n    if (this._pathWillChange(x, y)) {\r\n      this._path +=\r\n        'A ' +\r\n        rx +\r\n        ' ' +\r\n        ry +\r\n        ' ' +\r\n        rot +\r\n        ' ' +\r\n        largeArcFlag +\r\n        ' ' +\r\n        sweepFlag +\r\n        ' ' +\r\n        x +\r\n        ' ' +\r\n        y +\r\n        ' ';\r\n      this._lastAction = ACTION.ARC;\r\n    }\r\n  }\r\n\r\n  close() {\r\n    this._path += 'Z';\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3ZnUGF0aC5qcz9jYzc1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3ZnUGF0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEFDVElPTiA9IHtcclxuICBNT1ZFOiAwLFxyXG4gIE1PVkVfRDogMSxcclxuICBMSU5FOiAyLFxyXG4gIExJTkVfRDogMyxcclxuICBIT1JJWk9OVEFMOiA0LFxyXG4gIEhPUklaT05UQUxfRDogNSxcclxuICBWRVJUSUNBTDogNixcclxuICBWRVJUSUNBTF9EOiA3LFxyXG4gIEJFWklFUjogOCxcclxuICBCRVpJRVJfRDogOSxcclxuICBBUkM6IDEwXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdmdQYXRoIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX3BhdGggPSAnJztcclxuICAgIHRoaXMuX3g7XHJcbiAgICB0aGlzLl95O1xyXG4gICAgdGhpcy5fcHJlY2lzaW9uID0gMjtcclxuICAgIHRoaXMuX2xhc3RBY3Rpb247XHJcbiAgfVxyXG5cclxuICAvLyBpZ25vcmUgYSBjaGFuZ2UsIGlmIGl0cyBlbmQgY29vcmRpbmF0ZSBpcyB0aGUgc2FtZSBhcyBpdHMgY3VycmVudCBwb3NpdGlvblxyXG4gIF9wYXRoV2lsbENoYW5nZSh4LCB5KSB7XHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHgpIHx8IE51bWJlci5pc05hTih5KSk7IC8vZGVidWdnZXI7XHJcbiAgICBpZiAoeCAhPT0gdGhpcy5feCB8fCB5ICE9PSB0aGlzLl95KSB7XHJcbiAgICAgIHRoaXMuX3ggPSB4O1xyXG4gICAgICB0aGlzLl95ID0geTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBfYXBwbHlQcmVjaXNpb24oLi4ubnVtYmVycykge1xyXG4gICAgcmV0dXJuIG51bWJlcnMubWFwKGQgPT4gK2QudG9GaXhlZCh0aGlzLl9wcmVjaXNpb24pKTtcclxuICB9XHJcblxyXG4gIGdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXRoO1xyXG4gIH1cclxuXHJcbiAgbW92ZSh4LCB5KSB7XHJcbiAgICBbeCwgeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbih4LCB5KTtcclxuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh4LCB5KSkge1xyXG4gICAgICBpZiAodGhpcy5fbGFzdEFjdGlvbiA9PSBBQ1RJT04uTU9WRSlcclxuICAgICAgICAvLyByZW1vdmUgbGFzdCBtb3ZlIGZyb20gc3RyaW5nXHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IHRoaXMuX3BhdGguc2xpY2UoMCwgdGhpcy5fcGF0aC5sYXN0SW5kZXhPZignTScpKTtcclxuICAgICAgdGhpcy5fcGF0aCArPSAnTSAnICsgeCArICcgJyArIHkgKyAnICc7XHJcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uTU9WRTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG1vdmVEKGR4LCBkeSkge1xyXG4gICAgW2R4LCBkeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihkeCwgZHkpO1xyXG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHRoaXMuX3ggKyBkeCwgdGhpcy5feSArIGR5KSkge1xyXG4gICAgICB0aGlzLl9wYXRoICs9ICdtICcgKyBkeCArICcgJyArIGR5ICsgJyAnO1xyXG4gICAgICB0aGlzLl9sYXN0QWN0aW9uID0gQUNUSU9OLk1PVkVfRDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxpbmUoeCwgeSkge1xyXG4gICAgW3gsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeCwgeSk7XHJcbiAgICBpZiAodGhpcy5fcGF0aFdpbGxDaGFuZ2UoeCwgeSkpIHtcclxuICAgICAgdGhpcy5fcGF0aCArPSAnTCAnICsgeCArICcgJyArIHkgKyAnICc7XHJcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uTElORTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxpbmVEKGR4LCBkeSkge1xyXG4gICAgW2R4LCBkeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihkeCwgZHkpO1xyXG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHRoaXMuX3ggKyBkeCwgdGhpcy5feSArIGR5KSkge1xyXG4gICAgICB0aGlzLl9wYXRoICs9ICdsICcgKyBkeCArICcgJyArIGR5ICsgJyAnO1xyXG4gICAgICB0aGlzLl9sYXN0QWN0aW9uID0gQUNUSU9OLkxJTkVfRDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhvcml6b250YWwoeCkge1xyXG4gICAgW3hdID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeCk7XHJcbiAgICBpZiAodGhpcy5fcGF0aFdpbGxDaGFuZ2UoeCwgdGhpcy5feSkpIHtcclxuICAgICAgaWYgKHRoaXMuX2xhc3RBY3Rpb24gPT0gQUNUSU9OLkhPUklaT05UQUwpXHJcbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgbW92ZSBmcm9tIHN0cmluZ1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSB0aGlzLl9wYXRoLnNsaWNlKDAsIHRoaXMuX3BhdGgubGFzdEluZGV4T2YoJ0gnKSk7XHJcbiAgICAgIHRoaXMuX3BhdGggKz0gJ0ggJyArIHggKyAnICc7XHJcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uSE9SSVpPTlRBTDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGhvcml6b250YWxEKGR4KSB7XHJcbiAgICBbZHhdID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oZHgpO1xyXG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHRoaXMuX3ggKyBkeCwgdGhpcy5feSkpIHtcclxuICAgICAgdGhpcy5fcGF0aCArPSAnaCAnICsgZHggKyAnICc7XHJcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uSE9SSVpPTlRBTF9EO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmVydGljYWwoeSkge1xyXG4gICAgW3ldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeSk7XHJcbiAgICBpZiAodGhpcy5fcGF0aFdpbGxDaGFuZ2UodGhpcy5feCwgeSkpIHtcclxuICAgICAgaWYgKHRoaXMuX2xhc3RBY3Rpb24gPT0gQUNUSU9OLlZFUlRJQ0FMKVxyXG4gICAgICAgIC8vIHJlbW92ZSBsYXN0IG1vdmUgZnJvbSBzdHJpbmdcclxuICAgICAgICB0aGlzLl9wYXRoID0gdGhpcy5fcGF0aC5zbGljZSgwLCB0aGlzLl9wYXRoLmxhc3RJbmRleE9mKCdWJykpO1xyXG4gICAgICB0aGlzLl9wYXRoICs9ICdWICcgKyB5ICsgJyAnO1xyXG4gICAgICB0aGlzLl9sYXN0QWN0aW9uID0gQUNUSU9OLlZFUlRJQ0FMO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmVydGljYWxEKGR5KSB7XHJcbiAgICBbZHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oZHkpO1xyXG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHRoaXMuX3gsIHRoaXMuX3kgKyBkeSkpIHtcclxuICAgICAgdGhpcy5fcGF0aCArPSAndiAnICsgZHkgKyAnICc7XHJcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uVkVSVElDQUxfRDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGJlemllcih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xyXG4gICAgW3gxLCB5MSwgeDIsIHkyLCB4LCB5XSA9IHRoaXMuX2FwcGx5UHJlY2lzaW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KTtcclxuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh4LCB5KSkge1xyXG4gICAgICB0aGlzLl9wYXRoICs9XHJcbiAgICAgICAgJ0MgJyArIHgxICsgJyAnICsgeTEgKyAnLCAnICsgeDIgKyAnICcgKyB5MiArICcsICcgKyB4ICsgJyAnICsgeSArICcgJztcclxuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5CRVpJRVI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBiZXppZXJEKGR4MSwgZHkxLCBkeDIsIGR5MiwgZHgsIGR5KSB7XHJcbiAgICBbZHgxLCBkeTEsIGR4MiwgZHkyLCBkeCwgZHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oXHJcbiAgICAgIGR4MSxcclxuICAgICAgZHkxLFxyXG4gICAgICBkeDIsXHJcbiAgICAgIGR5MixcclxuICAgICAgZHgsXHJcbiAgICAgIGR5XHJcbiAgICApO1xyXG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHRoaXMuX3ggKyBkeCwgdGhpcy5feSArIGR5KSkge1xyXG4gICAgICB0aGlzLl9wYXRoICs9XHJcbiAgICAgICAgJ2MgJyArXHJcbiAgICAgICAgZHgxICtcclxuICAgICAgICAnICcgK1xyXG4gICAgICAgIGR5MSArXHJcbiAgICAgICAgJywgJyArXHJcbiAgICAgICAgZHgyICtcclxuICAgICAgICAnICcgK1xyXG4gICAgICAgIGR5MiArXHJcbiAgICAgICAgJywgJyArXHJcbiAgICAgICAgZHggK1xyXG4gICAgICAgICcgJyArXHJcbiAgICAgICAgZHkgK1xyXG4gICAgICAgICcgJztcclxuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5CRVpJRVJfRDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFyYyhyeCwgcnksIHJvdCwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcclxuICAgIFtyeCwgcnksIHJvdCwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oXHJcbiAgICAgIHJ4LFxyXG4gICAgICByeSxcclxuICAgICAgcm90LFxyXG4gICAgICBsYXJnZUFyY0ZsYWcsXHJcbiAgICAgIHN3ZWVwRmxhZyxcclxuICAgICAgeCxcclxuICAgICAgeVxyXG4gICAgKTtcclxuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh4LCB5KSkge1xyXG4gICAgICB0aGlzLl9wYXRoICs9XHJcbiAgICAgICAgJ0EgJyArXHJcbiAgICAgICAgcnggK1xyXG4gICAgICAgICcgJyArXHJcbiAgICAgICAgcnkgK1xyXG4gICAgICAgICcgJyArXHJcbiAgICAgICAgcm90ICtcclxuICAgICAgICAnICcgK1xyXG4gICAgICAgIGxhcmdlQXJjRmxhZyArXHJcbiAgICAgICAgJyAnICtcclxuICAgICAgICBzd2VlcEZsYWcgK1xyXG4gICAgICAgICcgJyArXHJcbiAgICAgICAgeCArXHJcbiAgICAgICAgJyAnICtcclxuICAgICAgICB5ICtcclxuICAgICAgICAnICc7XHJcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uQVJDO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2xvc2UoKSB7XHJcbiAgICB0aGlzLl9wYXRoICs9ICdaJztcclxuICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/SvgPath.js\n"
          );

          /***/
        },

      /***/ './src/TransformData.js':
        /*!******************************!*\
  !*** ./src/TransformData.js ***!
  \******************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SplitStreamInputData.js */ \"./src/SplitStreamInputData.js\");\n\r\n\r\nconst TransformData = {\r\n  viscous: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    // add nodes\r\n    for (let id in data.N) {\r\n      let node = data.N[id];\r\n      format.addNode(node.t, id, node.w);\r\n    }\r\n    // add tree structure\r\n    for (let t in data.EN) {\r\n      for (let id in data.EN[t]) {\r\n        let childArray = data.EN[t][id];\r\n        for (let childId of childArray) {\r\n          format.addParent(t, childId, id);\r\n        }\r\n      }\r\n    }\r\n    // add timeline\r\n    for (let stream in data.ET) {\r\n      for (let nodeId in data.ET[stream]) {\r\n        let t = data.N[nodeId].t;\r\n        for (let nextId of data.ET[stream][nodeId]) {\r\n          format.addNext(t, nodeId, nextId);\r\n        }\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  gumtree: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    let idx = 0;\r\n\r\n    // follow the data format's post-order DFS approach\r\n    let traverse = (t, node) => {\r\n      if (!!node.children)\r\n        for (let i = 0; i < node.children.length; i++)\r\n          traverse(t, node.children[i]);\r\n\r\n      node.id = idx++;\r\n      format.addNode(t, node.id, node.length, node.pos, {\r\n        label: node.label,\r\n        type: node.type,\r\n        typeLabel: node.typeLabel\r\n      });\r\n\r\n      // children need to be added in a second step, becaues ID is not known beforehand\r\n      if (!!node.children)\r\n        for (let i = 0; i < node.children.length; i++)\r\n          format.addParent(t, node.children[i].id, node.id);\r\n    };\r\n\r\n    for (let t in data.timesteps) {\r\n      idx = 0;\r\n      // add nodes and tree structure\r\n      traverse(t, data.timesteps[t].root);\r\n\r\n      // add timeline (start with second, because data needs to be written before being modified)\r\n      if (t > 0) {\r\n        if (!!data.changes[t - 1].matches)\r\n          for (let match of data.changes[t - 1].matches) {\r\n            format.addNext(t - 1, match.src, match.dest);\r\n          }\r\n\r\n        // find added, deleted nodes\r\n        // if (!!data.changes[t-1].actions)\r\n        // \tfor (let action of data.changes[t-1].actions) {\r\n        // \t\tif (action.action == \"delete\")\r\n        // \t\t\tcurrentTimestep.deleted[action.tree] = previousTimestep.references[action.tree];\r\n\r\n        // \t\t/*if (action.action == \"insert\") {\r\n        // \t\t\tcurrentTimestep.references[action.tree].insertAt = action.at;\r\n        // \t\t}*/\r\n        //     }\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  titan: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    let t = -1;\r\n    let lastDate;\r\n    for (let entry of data) {\r\n      // when timestamp changes, create a new timestep\r\n      if (entry['observation_time'] != lastDate) {\r\n        lastDate = entry['observation_time'];\r\n        t++;\r\n      }\r\n      format.addNode(t, entry.id, +entry['cell_volume (km3)']);\r\n    }\r\n\r\n    t = -1;\r\n    for (let entry of data) {\r\n      if (entry['observation_time'] != lastDate) {\r\n        lastDate = entry['observation_time'];\r\n        t++;\r\n      }\r\n      let children = entry['IDs of children '];\r\n      if (!!children) {\r\n        if (typeof children == 'string') {\r\n          let next = children.split(', ');\r\n          if (next[0] != '')\r\n            next.forEach(nextId => format.addNext(t, entry.id, nextId));\r\n        } // single ID as number\r\n        else format.addNext(t, entry.id, children);\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  allen: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](/*{forceFakeRoot: true}*/);\r\n    let timesteps = {\r\n      '2': 0,\r\n      '3': 1,\r\n      '5': 2,\r\n      '6': 3,\r\n      '7': 4,\r\n      '8': 5\r\n    };\r\n    let time = t => timesteps[t];\r\n\r\n    for (let structureId in data) {\r\n      let structure = data[structureId];\r\n      for (let step in structure.timesteps) {\r\n        let { id, timesteps, name, acronym, color, parent } = structure;\r\n        format.addNode(time(step), id, timesteps[step], undefined, {\r\n          name,\r\n          acronym,\r\n          color\r\n        });\r\n      }\r\n    }\r\n\r\n    for (let structureId in data) {\r\n      let structure = data[structureId];\r\n      for (let step in structure.timesteps) {\r\n        let { id, timesteps, name, acronym, color, parent } = structure;\r\n        format.addParent(time(step), id, parent);\r\n      }\r\n    }\r\n\r\n    format.buildTimeConnections();\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  storyline: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const characters = [];\r\n    const locations = [];\r\n    for (let char of data.characters)\r\n      characters[char.id] = char.name.replace(/\\s+/g, '');\r\n    for (let loc of data.locations)\r\n      locations[loc.id] = loc.name.replace(/\\s+/g, '');\r\n\r\n    for (let session of data.sessions) {\r\n      for (let t = session.start; t < session.end; t++) {\r\n        format.addNode(\r\n          t,\r\n          locations[session.location],\r\n          undefined,\r\n          undefined,\r\n          locations[session.location]\r\n        );\r\n        for (let member of session.members) {\r\n          format.addNode(\r\n            t,\r\n            characters[member],\r\n            undefined,\r\n            undefined,\r\n            characters[member]\r\n          );\r\n          format.addParent(t, characters[member], locations[session.location]);\r\n        }\r\n      }\r\n    }\r\n\r\n    format.buildTimeConnections();\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  treemap: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    for (let entry of data) {\r\n      let id = entry[0];\r\n      let parentId = entry[1];\r\n      for (let t = 2; t < entry.length; t++) {\r\n        if (entry[t] > 0) {\r\n          format.addNode(t, id, entry[t]);\r\n          format.addNode(t, parentId);\r\n          format.addParent(t, id, parentId);\r\n        }\r\n      }\r\n    }\r\n    format.buildTimeConnections();\r\n    format.finalize();\r\n    return format;\r\n  }\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TransformData);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvVHJhbnNmb3JtRGF0YS5qcz9lNDk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBNkQ7O0FBRTdEO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixnRUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixnRUFBb0IsSUFBSSxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixnRUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsNEVBQWEsRUFBQyIsImZpbGUiOiIuL3NyYy9UcmFuc2Zvcm1EYXRhLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNwbGl0U3RyZWFtSW5wdXREYXRhIGZyb20gJy4vU3BsaXRTdHJlYW1JbnB1dERhdGEuanMnO1xyXG5cclxuY29uc3QgVHJhbnNmb3JtRGF0YSA9IHtcclxuICB2aXNjb3VzOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICAvLyBhZGQgbm9kZXNcclxuICAgIGZvciAobGV0IGlkIGluIGRhdGEuTikge1xyXG4gICAgICBsZXQgbm9kZSA9IGRhdGEuTltpZF07XHJcbiAgICAgIGZvcm1hdC5hZGROb2RlKG5vZGUudCwgaWQsIG5vZGUudyk7XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgdHJlZSBzdHJ1Y3R1cmVcclxuICAgIGZvciAobGV0IHQgaW4gZGF0YS5FTikge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiBkYXRhLkVOW3RdKSB7XHJcbiAgICAgICAgbGV0IGNoaWxkQXJyYXkgPSBkYXRhLkVOW3RdW2lkXTtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZElkIG9mIGNoaWxkQXJyYXkpIHtcclxuICAgICAgICAgIGZvcm1hdC5hZGRQYXJlbnQodCwgY2hpbGRJZCwgaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIHRpbWVsaW5lXHJcbiAgICBmb3IgKGxldCBzdHJlYW0gaW4gZGF0YS5FVCkge1xyXG4gICAgICBmb3IgKGxldCBub2RlSWQgaW4gZGF0YS5FVFtzdHJlYW1dKSB7XHJcbiAgICAgICAgbGV0IHQgPSBkYXRhLk5bbm9kZUlkXS50O1xyXG4gICAgICAgIGZvciAobGV0IG5leHRJZCBvZiBkYXRhLkVUW3N0cmVhbV1bbm9kZUlkXSkge1xyXG4gICAgICAgICAgZm9ybWF0LmFkZE5leHQodCwgbm9kZUlkLCBuZXh0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9LFxyXG5cclxuICBndW10cmVlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICBsZXQgaWR4ID0gMDtcclxuXHJcbiAgICAvLyBmb2xsb3cgdGhlIGRhdGEgZm9ybWF0J3MgcG9zdC1vcmRlciBERlMgYXBwcm9hY2hcclxuICAgIGxldCB0cmF2ZXJzZSA9ICh0LCBub2RlKSA9PiB7XHJcbiAgICAgIGlmICghIW5vZGUuY2hpbGRyZW4pXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgdHJhdmVyc2UodCwgbm9kZS5jaGlsZHJlbltpXSk7XHJcblxyXG4gICAgICBub2RlLmlkID0gaWR4Kys7XHJcbiAgICAgIGZvcm1hdC5hZGROb2RlKHQsIG5vZGUuaWQsIG5vZGUubGVuZ3RoLCBub2RlLnBvcywge1xyXG4gICAgICAgIGxhYmVsOiBub2RlLmxhYmVsLFxyXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcclxuICAgICAgICB0eXBlTGFiZWw6IG5vZGUudHlwZUxhYmVsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gY2hpbGRyZW4gbmVlZCB0byBiZSBhZGRlZCBpbiBhIHNlY29uZCBzdGVwLCBiZWNhdWVzIElEIGlzIG5vdCBrbm93biBiZWZvcmVoYW5kXHJcbiAgICAgIGlmICghIW5vZGUuY2hpbGRyZW4pXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgZm9ybWF0LmFkZFBhcmVudCh0LCBub2RlLmNoaWxkcmVuW2ldLmlkLCBub2RlLmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgZm9yIChsZXQgdCBpbiBkYXRhLnRpbWVzdGVwcykge1xyXG4gICAgICBpZHggPSAwO1xyXG4gICAgICAvLyBhZGQgbm9kZXMgYW5kIHRyZWUgc3RydWN0dXJlXHJcbiAgICAgIHRyYXZlcnNlKHQsIGRhdGEudGltZXN0ZXBzW3RdLnJvb3QpO1xyXG5cclxuICAgICAgLy8gYWRkIHRpbWVsaW5lIChzdGFydCB3aXRoIHNlY29uZCwgYmVjYXVzZSBkYXRhIG5lZWRzIHRvIGJlIHdyaXR0ZW4gYmVmb3JlIGJlaW5nIG1vZGlmaWVkKVxyXG4gICAgICBpZiAodCA+IDApIHtcclxuICAgICAgICBpZiAoISFkYXRhLmNoYW5nZXNbdCAtIDFdLm1hdGNoZXMpXHJcbiAgICAgICAgICBmb3IgKGxldCBtYXRjaCBvZiBkYXRhLmNoYW5nZXNbdCAtIDFdLm1hdGNoZXMpIHtcclxuICAgICAgICAgICAgZm9ybWF0LmFkZE5leHQodCAtIDEsIG1hdGNoLnNyYywgbWF0Y2guZGVzdCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmQgYWRkZWQsIGRlbGV0ZWQgbm9kZXNcclxuICAgICAgICAvLyBpZiAoISFkYXRhLmNoYW5nZXNbdC0xXS5hY3Rpb25zKVxyXG4gICAgICAgIC8vIFx0Zm9yIChsZXQgYWN0aW9uIG9mIGRhdGEuY2hhbmdlc1t0LTFdLmFjdGlvbnMpIHtcclxuICAgICAgICAvLyBcdFx0aWYgKGFjdGlvbi5hY3Rpb24gPT0gXCJkZWxldGVcIilcclxuICAgICAgICAvLyBcdFx0XHRjdXJyZW50VGltZXN0ZXAuZGVsZXRlZFthY3Rpb24udHJlZV0gPSBwcmV2aW91c1RpbWVzdGVwLnJlZmVyZW5jZXNbYWN0aW9uLnRyZWVdO1xyXG5cclxuICAgICAgICAvLyBcdFx0LyppZiAoYWN0aW9uLmFjdGlvbiA9PSBcImluc2VydFwiKSB7XHJcbiAgICAgICAgLy8gXHRcdFx0Y3VycmVudFRpbWVzdGVwLnJlZmVyZW5jZXNbYWN0aW9uLnRyZWVdLmluc2VydEF0ID0gYWN0aW9uLmF0O1xyXG4gICAgICAgIC8vIFx0XHR9Ki9cclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0LmZpbmFsaXplKCk7XHJcbiAgICByZXR1cm4gZm9ybWF0O1xyXG4gIH0sXHJcblxyXG4gIHRpdGFuOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICBsZXQgdCA9IC0xO1xyXG4gICAgbGV0IGxhc3REYXRlO1xyXG4gICAgZm9yIChsZXQgZW50cnkgb2YgZGF0YSkge1xyXG4gICAgICAvLyB3aGVuIHRpbWVzdGFtcCBjaGFuZ2VzLCBjcmVhdGUgYSBuZXcgdGltZXN0ZXBcclxuICAgICAgaWYgKGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ10gIT0gbGFzdERhdGUpIHtcclxuICAgICAgICBsYXN0RGF0ZSA9IGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ107XHJcbiAgICAgICAgdCsrO1xyXG4gICAgICB9XHJcbiAgICAgIGZvcm1hdC5hZGROb2RlKHQsIGVudHJ5LmlkLCArZW50cnlbJ2NlbGxfdm9sdW1lIChrbTMpJ10pO1xyXG4gICAgfVxyXG5cclxuICAgIHQgPSAtMTtcclxuICAgIGZvciAobGV0IGVudHJ5IG9mIGRhdGEpIHtcclxuICAgICAgaWYgKGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ10gIT0gbGFzdERhdGUpIHtcclxuICAgICAgICBsYXN0RGF0ZSA9IGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ107XHJcbiAgICAgICAgdCsrO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBjaGlsZHJlbiA9IGVudHJ5WydJRHMgb2YgY2hpbGRyZW4gJ107XHJcbiAgICAgIGlmICghIWNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbi5zcGxpdCgnLCAnKTtcclxuICAgICAgICAgIGlmIChuZXh0WzBdICE9ICcnKVxyXG4gICAgICAgICAgICBuZXh0LmZvckVhY2gobmV4dElkID0+IGZvcm1hdC5hZGROZXh0KHQsIGVudHJ5LmlkLCBuZXh0SWQpKTtcclxuICAgICAgICB9IC8vIHNpbmdsZSBJRCBhcyBudW1iZXJcclxuICAgICAgICBlbHNlIGZvcm1hdC5hZGROZXh0KHQsIGVudHJ5LmlkLCBjaGlsZHJlbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3JtYXQuZmluYWxpemUoKTtcclxuICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgfSxcclxuXHJcbiAgYWxsZW46IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoLyp7Zm9yY2VGYWtlUm9vdDogdHJ1ZX0qLyk7XHJcbiAgICBsZXQgdGltZXN0ZXBzID0ge1xyXG4gICAgICAnMic6IDAsXHJcbiAgICAgICczJzogMSxcclxuICAgICAgJzUnOiAyLFxyXG4gICAgICAnNic6IDMsXHJcbiAgICAgICc3JzogNCxcclxuICAgICAgJzgnOiA1XHJcbiAgICB9O1xyXG4gICAgbGV0IHRpbWUgPSB0ID0+IHRpbWVzdGVwc1t0XTtcclxuXHJcbiAgICBmb3IgKGxldCBzdHJ1Y3R1cmVJZCBpbiBkYXRhKSB7XHJcbiAgICAgIGxldCBzdHJ1Y3R1cmUgPSBkYXRhW3N0cnVjdHVyZUlkXTtcclxuICAgICAgZm9yIChsZXQgc3RlcCBpbiBzdHJ1Y3R1cmUudGltZXN0ZXBzKSB7XHJcbiAgICAgICAgbGV0IHsgaWQsIHRpbWVzdGVwcywgbmFtZSwgYWNyb255bSwgY29sb3IsIHBhcmVudCB9ID0gc3RydWN0dXJlO1xyXG4gICAgICAgIGZvcm1hdC5hZGROb2RlKHRpbWUoc3RlcCksIGlkLCB0aW1lc3RlcHNbc3RlcF0sIHVuZGVmaW5lZCwge1xyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGFjcm9ueW0sXHJcbiAgICAgICAgICBjb2xvclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgc3RydWN0dXJlSWQgaW4gZGF0YSkge1xyXG4gICAgICBsZXQgc3RydWN0dXJlID0gZGF0YVtzdHJ1Y3R1cmVJZF07XHJcbiAgICAgIGZvciAobGV0IHN0ZXAgaW4gc3RydWN0dXJlLnRpbWVzdGVwcykge1xyXG4gICAgICAgIGxldCB7IGlkLCB0aW1lc3RlcHMsIG5hbWUsIGFjcm9ueW0sIGNvbG9yLCBwYXJlbnQgfSA9IHN0cnVjdHVyZTtcclxuICAgICAgICBmb3JtYXQuYWRkUGFyZW50KHRpbWUoc3RlcCksIGlkLCBwYXJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0LmJ1aWxkVGltZUNvbm5lY3Rpb25zKCk7XHJcbiAgICBmb3JtYXQuZmluYWxpemUoKTtcclxuICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgfSxcclxuXHJcbiAgc3RvcnlsaW5lOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICBjb25zdCBjaGFyYWN0ZXJzID0gW107XHJcbiAgICBjb25zdCBsb2NhdGlvbnMgPSBbXTtcclxuICAgIGZvciAobGV0IGNoYXIgb2YgZGF0YS5jaGFyYWN0ZXJzKVxyXG4gICAgICBjaGFyYWN0ZXJzW2NoYXIuaWRdID0gY2hhci5uYW1lLnJlcGxhY2UoL1xccysvZywgJycpO1xyXG4gICAgZm9yIChsZXQgbG9jIG9mIGRhdGEubG9jYXRpb25zKVxyXG4gICAgICBsb2NhdGlvbnNbbG9jLmlkXSA9IGxvYy5uYW1lLnJlcGxhY2UoL1xccysvZywgJycpO1xyXG5cclxuICAgIGZvciAobGV0IHNlc3Npb24gb2YgZGF0YS5zZXNzaW9ucykge1xyXG4gICAgICBmb3IgKGxldCB0ID0gc2Vzc2lvbi5zdGFydDsgdCA8IHNlc3Npb24uZW5kOyB0KyspIHtcclxuICAgICAgICBmb3JtYXQuYWRkTm9kZShcclxuICAgICAgICAgIHQsXHJcbiAgICAgICAgICBsb2NhdGlvbnNbc2Vzc2lvbi5sb2NhdGlvbl0sXHJcbiAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICBsb2NhdGlvbnNbc2Vzc2lvbi5sb2NhdGlvbl1cclxuICAgICAgICApO1xyXG4gICAgICAgIGZvciAobGV0IG1lbWJlciBvZiBzZXNzaW9uLm1lbWJlcnMpIHtcclxuICAgICAgICAgIGZvcm1hdC5hZGROb2RlKFxyXG4gICAgICAgICAgICB0LFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJzW21lbWJlcl0sXHJcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjaGFyYWN0ZXJzW21lbWJlcl1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBmb3JtYXQuYWRkUGFyZW50KHQsIGNoYXJhY3RlcnNbbWVtYmVyXSwgbG9jYXRpb25zW3Nlc3Npb24ubG9jYXRpb25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3JtYXQuYnVpbGRUaW1lQ29ubmVjdGlvbnMoKTtcclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9LFxyXG5cclxuICB0cmVlbWFwOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhKSB7XHJcbiAgICAgIGxldCBpZCA9IGVudHJ5WzBdO1xyXG4gICAgICBsZXQgcGFyZW50SWQgPSBlbnRyeVsxXTtcclxuICAgICAgZm9yIChsZXQgdCA9IDI7IHQgPCBlbnRyeS5sZW5ndGg7IHQrKykge1xyXG4gICAgICAgIGlmIChlbnRyeVt0XSA+IDApIHtcclxuICAgICAgICAgIGZvcm1hdC5hZGROb2RlKHQsIGlkLCBlbnRyeVt0XSk7XHJcbiAgICAgICAgICBmb3JtYXQuYWRkTm9kZSh0LCBwYXJlbnRJZCk7XHJcbiAgICAgICAgICBmb3JtYXQuYWRkUGFyZW50KHQsIGlkLCBwYXJlbnRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JtYXQuYnVpbGRUaW1lQ29ubmVjdGlvbnMoKTtcclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm1EYXRhO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/TransformData.js\n"
          );

          /***/
        },

      /***/ './src/functions.js':
        /*!**************************!*\
  !*** ./src/functions.js ***!
  \**************************/
        /*! exports provided: loadJSON, getRandomColor, saveSvg, savePng, saveJson, addLoadingSpinner, removeLoadingSpinner */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJSON\", function() { return loadJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRandomColor\", function() { return getRandomColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveSvg\", function() { return saveSvg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"savePng\", function() { return savePng; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveJson\", function() { return saveJson; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLoadingSpinner\", function() { return addLoadingSpinner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeLoadingSpinner\", function() { return removeLoadingSpinner; });\n/* harmony import */ var save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! save-svg-as-png */ \"./node_modules/save-svg-as-png/lib/saveSvgAsPng.js\");\n/* harmony import */ var save_svg_as_png__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nfunction loadJSON(file, callback) {\r\n  var xobj = new XMLHttpRequest();\r\n  xobj.overrideMimeType('application/json');\r\n  xobj.open('GET', file, true); // Replace 'my_data' with the path to your file\r\n  xobj.onreadystatechange = function() {\r\n    if (xobj.readyState == 4 && xobj.status == '200') {\r\n      // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode\r\n      callback(xobj.responseText);\r\n    }\r\n  };\r\n  xobj.send(null);\r\n}\r\n\r\nfunction getRandomColor() {\r\n  var letters = '0123456789ABCDEF';\r\n  var color = '#';\r\n  for (var i = 0; i < 6; i++) {\r\n    color += letters[Math.floor(Math.random() * 16)];\r\n  }\r\n  return color;\r\n}\r\n\r\n/* Modified from https://stackoverflow.com/questions/23218174/how-do-i-save-export-an-svg-file-after-creating-an-svg-with-d3-js-ie-safari-an */\r\nfunction saveSvg(svgEl, name) {\r\n  svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\r\n  var svgData = svgEl.outerHTML;\r\n  var preface = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n';\r\n  var svgBlob = new Blob([preface, svgData], {\r\n    type: 'image/svg+xml;charset=utf-8'\r\n  });\r\n  var svgUrl = URL.createObjectURL(svgBlob);\r\n  var downloadLink = document.createElement('a');\r\n  downloadLink.href = svgUrl;\r\n  downloadLink.download = name + '.svg';\r\n  document.body.appendChild(downloadLink);\r\n  downloadLink.click();\r\n  document.body.removeChild(downloadLink);\r\n}\r\n\r\nasync function savePng(svgEl, name) {\r\n  // store image in 16K+ res\r\n  // this can take a lot of time\r\n  addLoadingSpinner(document.querySelector('#wrapper'));\r\n  let scaleFactor = Math.ceil(15360 / svgEl.clientWidth);\r\n  await save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__[\"saveSvgAsPng\"](svgEl, name + '.png', {\r\n    backgroundColor: 'white',\r\n    encoderOptions: 1,\r\n    scale: scaleFactor\r\n  });\r\n  removeLoadingSpinner(document.querySelector('#wrapper'));\r\n}\r\n\r\n/* Modified from https://stackoverflow.com/questions/19721439/download-json-object-as-a-file-from-browser */\r\nfunction saveJson(exportObj, exportName) {\r\n  var dataStr =\r\n    'data:text/json;charset=utf-8,' +\r\n    encodeURIComponent(JSON.stringify(exportObj));\r\n  var downloadAnchorNode = document.createElement('a');\r\n  downloadAnchorNode.setAttribute('href', dataStr);\r\n  downloadAnchorNode.setAttribute('download', exportName + '.json');\r\n  document.body.appendChild(downloadAnchorNode); // required for firefox\r\n  downloadAnchorNode.click();\r\n  downloadAnchorNode.remove();\r\n}\r\n\r\nfunction addLoadingSpinner(div) {\r\n  if (!div) {\r\n    console.log('addLoadingSpinner: div does not exist');\r\n    return;\r\n  }\r\n\r\n  if (!div.classList.contains('loading')) {\r\n    div.classList.add('loading');\r\n\r\n    let loader = document.createElement('div');\r\n    loader.classList = 'loader';\r\n    loader.style.top = div.scrollTop + 'px'; // position it correctly on scrollable divs\r\n    loader.onscroll = function(e) {\r\n      e.preventDefault();\r\n    };\r\n    div.appendChild(loader);\r\n\r\n    let spinner = document.createElement('div');\r\n    spinner.classList = 'spinner';\r\n    let size =\r\n      0.3 *\r\n      (loader.clientHeight > loader.clientWidth\r\n        ? loader.clientWidth\r\n        : loader.clientHeight);\r\n    spinner.style.width = size + 'px';\r\n    spinner.style.height = size + 'px';\r\n    spinner.style.borderWidth = 0.1 * size + 'px';\r\n    loader.appendChild(spinner);\r\n  }\r\n}\r\n\r\nfunction removeLoadingSpinner(div) {\r\n  if (!div) return;\r\n\r\n  let loader = div.querySelector('.loader');\r\n  if (!!loader) {\r\n    div.removeChild(loader);\r\n    div.classList.remove('loading');\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvZnVuY3Rpb25zLmpzPzlmMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7O0FBRWhDO0FBQ1A7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9mdW5jdGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzdmcgZnJvbSAnc2F2ZS1zdmctYXMtcG5nJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkSlNPTihmaWxlLCBjYWxsYmFjaykge1xyXG4gIHZhciB4b2JqID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgeG9iai5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi9qc29uJyk7XHJcbiAgeG9iai5vcGVuKCdHRVQnLCBmaWxlLCB0cnVlKTsgLy8gUmVwbGFjZSAnbXlfZGF0YScgd2l0aCB0aGUgcGF0aCB0byB5b3VyIGZpbGVcclxuICB4b2JqLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHhvYmoucmVhZHlTdGF0ZSA9PSA0ICYmIHhvYmouc3RhdHVzID09ICcyMDAnKSB7XHJcbiAgICAgIC8vIFJlcXVpcmVkIHVzZSBvZiBhbiBhbm9ueW1vdXMgY2FsbGJhY2sgYXMgLm9wZW4gd2lsbCBOT1QgcmV0dXJuIGEgdmFsdWUgYnV0IHNpbXBseSByZXR1cm5zIHVuZGVmaW5lZCBpbiBhc3luY2hyb25vdXMgbW9kZVxyXG4gICAgICBjYWxsYmFjayh4b2JqLnJlc3BvbnNlVGV4dCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICB4b2JqLnNlbmQobnVsbCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21Db2xvcigpIHtcclxuICB2YXIgbGV0dGVycyA9ICcwMTIzNDU2Nzg5QUJDREVGJztcclxuICB2YXIgY29sb3IgPSAnIyc7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgIGNvbG9yICs9IGxldHRlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpXTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbG9yO1xyXG59XHJcblxyXG4vKiBNb2RpZmllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIzMjE4MTc0L2hvdy1kby1pLXNhdmUtZXhwb3J0LWFuLXN2Zy1maWxlLWFmdGVyLWNyZWF0aW5nLWFuLXN2Zy13aXRoLWQzLWpzLWllLXNhZmFyaS1hbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVN2ZyhzdmdFbCwgbmFtZSkge1xyXG4gIHN2Z0VsLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcclxuICB2YXIgc3ZnRGF0YSA9IHN2Z0VsLm91dGVySFRNTDtcclxuICB2YXIgcHJlZmFjZSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgc3RhbmRhbG9uZT1cIm5vXCI/Plxcclxcbic7XHJcbiAgdmFyIHN2Z0Jsb2IgPSBuZXcgQmxvYihbcHJlZmFjZSwgc3ZnRGF0YV0sIHtcclxuICAgIHR5cGU6ICdpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgnXHJcbiAgfSk7XHJcbiAgdmFyIHN2Z1VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3ZnQmxvYik7XHJcbiAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICBkb3dubG9hZExpbmsuaHJlZiA9IHN2Z1VybDtcclxuICBkb3dubG9hZExpbmsuZG93bmxvYWQgPSBuYW1lICsgJy5zdmcnO1xyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcclxuICBkb3dubG9hZExpbmsuY2xpY2soKTtcclxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRvd25sb2FkTGluayk7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlUG5nKHN2Z0VsLCBuYW1lKSB7XHJcbiAgLy8gc3RvcmUgaW1hZ2UgaW4gMTZLKyByZXNcclxuICAvLyB0aGlzIGNhbiB0YWtlIGEgbG90IG9mIHRpbWVcclxuICBhZGRMb2FkaW5nU3Bpbm5lcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd3JhcHBlcicpKTtcclxuICBsZXQgc2NhbGVGYWN0b3IgPSBNYXRoLmNlaWwoMTUzNjAgLyBzdmdFbC5jbGllbnRXaWR0aCk7XHJcbiAgYXdhaXQgc3ZnLnNhdmVTdmdBc1BuZyhzdmdFbCwgbmFtZSArICcucG5nJywge1xyXG4gICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxyXG4gICAgZW5jb2Rlck9wdGlvbnM6IDEsXHJcbiAgICBzY2FsZTogc2NhbGVGYWN0b3JcclxuICB9KTtcclxuICByZW1vdmVMb2FkaW5nU3Bpbm5lcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd3JhcHBlcicpKTtcclxufVxyXG5cclxuLyogTW9kaWZpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMTQzOS9kb3dubG9hZC1qc29uLW9iamVjdC1hcy1hLWZpbGUtZnJvbS1icm93c2VyICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzYXZlSnNvbihleHBvcnRPYmosIGV4cG9ydE5hbWUpIHtcclxuICB2YXIgZGF0YVN0ciA9XHJcbiAgICAnZGF0YTp0ZXh0L2pzb247Y2hhcnNldD11dGYtOCwnICtcclxuICAgIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShleHBvcnRPYmopKTtcclxuICB2YXIgZG93bmxvYWRBbmNob3JOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gIGRvd25sb2FkQW5jaG9yTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBkYXRhU3RyKTtcclxuICBkb3dubG9hZEFuY2hvck5vZGUuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGV4cG9ydE5hbWUgKyAnLmpzb24nKTtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkQW5jaG9yTm9kZSk7IC8vIHJlcXVpcmVkIGZvciBmaXJlZm94XHJcbiAgZG93bmxvYWRBbmNob3JOb2RlLmNsaWNrKCk7XHJcbiAgZG93bmxvYWRBbmNob3JOb2RlLnJlbW92ZSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9hZGluZ1NwaW5uZXIoZGl2KSB7XHJcbiAgaWYgKCFkaXYpIHtcclxuICAgIGNvbnNvbGUubG9nKCdhZGRMb2FkaW5nU3Bpbm5lcjogZGl2IGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoIWRpdi5jbGFzc0xpc3QuY29udGFpbnMoJ2xvYWRpbmcnKSkge1xyXG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoJ2xvYWRpbmcnKTtcclxuXHJcbiAgICBsZXQgbG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBsb2FkZXIuY2xhc3NMaXN0ID0gJ2xvYWRlcic7XHJcbiAgICBsb2FkZXIuc3R5bGUudG9wID0gZGl2LnNjcm9sbFRvcCArICdweCc7IC8vIHBvc2l0aW9uIGl0IGNvcnJlY3RseSBvbiBzY3JvbGxhYmxlIGRpdnNcclxuICAgIGxvYWRlci5vbnNjcm9sbCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIGRpdi5hcHBlbmRDaGlsZChsb2FkZXIpO1xyXG5cclxuICAgIGxldCBzcGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBzcGlubmVyLmNsYXNzTGlzdCA9ICdzcGlubmVyJztcclxuICAgIGxldCBzaXplID1cclxuICAgICAgMC4zICpcclxuICAgICAgKGxvYWRlci5jbGllbnRIZWlnaHQgPiBsb2FkZXIuY2xpZW50V2lkdGhcclxuICAgICAgICA/IGxvYWRlci5jbGllbnRXaWR0aFxyXG4gICAgICAgIDogbG9hZGVyLmNsaWVudEhlaWdodCk7XHJcbiAgICBzcGlubmVyLnN0eWxlLndpZHRoID0gc2l6ZSArICdweCc7XHJcbiAgICBzcGlubmVyLnN0eWxlLmhlaWdodCA9IHNpemUgKyAncHgnO1xyXG4gICAgc3Bpbm5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IDAuMSAqIHNpemUgKyAncHgnO1xyXG4gICAgbG9hZGVyLmFwcGVuZENoaWxkKHNwaW5uZXIpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxvYWRpbmdTcGlubmVyKGRpdikge1xyXG4gIGlmICghZGl2KSByZXR1cm47XHJcblxyXG4gIGxldCBsb2FkZXIgPSBkaXYucXVlcnlTZWxlY3RvcignLmxvYWRlcicpO1xyXG4gIGlmICghIWxvYWRlcikge1xyXG4gICAgZGl2LnJlbW92ZUNoaWxkKGxvYWRlcik7XHJcbiAgICBkaXYuY2xhc3NMaXN0LnJlbW92ZSgnbG9hZGluZycpO1xyXG4gIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/functions.js\n"
          );

          /***/
        },

      /***/ './src/lib.js':
        /*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
        /*! exports provided: SplitStream, SplitStreamInputData, SplitStreamFilter, TransformData */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SplitStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SplitStream */ "./src/SplitStream.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStream", function() { return _SplitStream__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _SplitStreamInputData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SplitStreamInputData */ "./src/SplitStreamInputData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStreamInputData", function() { return _SplitStreamInputData__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _SplitStreamFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SplitStreamFilter */ "./src/SplitStreamFilter.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStreamFilter", function() { return _SplitStreamFilter__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _TransformData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TransformData */ "./src/TransformData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformData", function() { return _TransformData__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvbGliLmpzPzM0ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBd0M7QUFDa0I7QUFDTjtBQUNSOztBQUVtQyIsImZpbGUiOiIuL3NyYy9saWIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3BsaXRTdHJlYW0gZnJvbSBcIi4vU3BsaXRTdHJlYW1cIjtcclxuaW1wb3J0IFNwbGl0U3RyZWFtSW5wdXREYXRhIGZyb20gXCIuL1NwbGl0U3RyZWFtSW5wdXREYXRhXCI7XHJcbmltcG9ydCBTcGxpdFN0cmVhbUZpbHRlciBmcm9tIFwiLi9TcGxpdFN0cmVhbUZpbHRlclwiO1xyXG5pbXBvcnQgVHJhbnNmb3JtRGF0YSBmcm9tIFwiLi9UcmFuc2Zvcm1EYXRhXCI7XHJcblxyXG5leHBvcnQgeyBTcGxpdFN0cmVhbSwgU3BsaXRTdHJlYW1JbnB1dERhdGEsIFNwbGl0U3RyZWFtRmlsdGVyLCBUcmFuc2Zvcm1EYXRhIH07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib.js\n'
          );

          /***/
        },

      /***/ d3:
        /*!*********************!*\
  !*** external "d3" ***!
  \*********************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            'module.exports = __WEBPACK_EXTERNAL_MODULE_d3__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvZXh0ZXJuYWwgXCJkM1wiPzQzNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiZDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZDNfXzsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///d3\n'
          );

          /***/
        }

      /******/
    }
  );
});
