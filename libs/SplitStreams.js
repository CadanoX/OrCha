(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require('d3'));
  else if (typeof define === 'function' && define.amd) define(['d3'], factory);
  else if (typeof exports === 'object')
    exports['SplitStreams'] = factory(require('d3'));
  else root['SplitStreams'] = factory(root['d3']);
})(window, function(__WEBPACK_EXTERNAL_MODULE_d3__) {
  return /******/ (function(modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {}; // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports;
        /******/
      } // Create a new module (and put it into the cache)
      /******/ /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {}
        /******/
      }); // Execute the module function
      /******/
      /******/ /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      ); // Flag the module as loaded
      /******/
      /******/ /******/ module.l = true; // Return the exports of the module
      /******/
      /******/ /******/ return module.exports;
      /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules; // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter
        });
        /******/
      }
      /******/
    }; // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function(exports) {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
      value,
      mode
    ) {
      /******/ if (mode & 1) value = __webpack_require__(value);
      /******/ if (mode & 8) return value;
      /******/ if (
        mode & 4 &&
        typeof value === 'object' &&
        value &&
        value.__esModule
      )
        return value;
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ Object.defineProperty(ns, 'default', {
        enumerable: true,
        value: value
      });
      /******/ if (mode & 2 && typeof value != 'string')
        for (var key in value)
          __webpack_require__.d(
            ns,
            key,
            function(key) {
              return value[key];
            }.bind(null, key)
          );
      /******/ return ns;
      /******/
    }; // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function(module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module['default'];
            }
          : /******/ function getModuleExports() {
              return module;
            };
      /******/ __webpack_require__.d(getter, 'a', getter);
      /******/ return getter;
      /******/
    }; // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }; // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = ''; // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__(
      (__webpack_require__.s = './src/lib.js')
    );
    /******/
  })(
    /************************************************************************/
    /******/ {
      /***/ './css/SplitStream.css':
        /*!*****************************!*\
  !*** ./css/SplitStream.css ***!
  \*****************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./SplitStream.css */ "./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css");\n\nif (typeof content === \'string\') {\n  content = [[module.i, content, \'\']];\n}\n\nvar options = {}\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9jc3MvU3BsaXRTdHJlYW0uY3NzPzA3ZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDhIQUE0RDs7QUFFbEY7QUFDQSxjQUFjLFFBQVM7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsbUpBQXdFOztBQUU3RjtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9jc3MvU3BsaXRTdHJlYW0uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL1NwbGl0U3RyZWFtLmNzc1wiKTtcblxuaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG59XG5cbnZhciBvcHRpb25zID0ge31cblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/SplitStream.css\n'
          );

          /***/
        },

      /***/ './libs/d3svgfilters/src/d3-svg-filters.js':
        /*!*************************************************!*\
  !*** ./libs/d3svgfilters/src/d3-svg-filters.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            "const d3 =  true ? __webpack_require__(/*! d3 */ \"d3\") : undefined;\n\nclass SVGFilter {\n  constructor(spec) {}\n\n  set id(id) {\n    this._id = id;\n  }\n  get id() {\n    return this._id;\n  }\n}\n\nclass SVGFilterManagerLibrary {\n  constructor() {\n    this._library = {}; // name : { generate: (defs) => (args) => {  appends filter to defs }, signature: (args) => key}\n  }\n\n  static GenerateID() {\n    if (!this.__ID) this.__ID = 0;\n\n    return ++this.__ID;\n  }\n\n  addFilter(name, fns) {\n    this._library[name] = fns;\n  }\n\n  signature(filterName, args) {\n    return this._library[filterName]\n      .signature(args)\n      .replace(/\\:|\\,|\\.|\\;/g, '_')\n      .replace(/ /g, '')\n      .replace(/\\#/g, 'h')\n      .replace(/\\(/g, 'l')\n      .replace(/\\)/g, 'r');\n  }\n\n  generate(defs, filterName, args) {\n    const signature = this.signature(filterName, args);\n    const ctx = { signature, defs };\n    const theFilter = this._library[filterName].generate.call(ctx, {\n      ...args,\n      id: SVGFilterManagerLibrary.GenerateID()\n    });\n\n    defs.node().__filters__.push({ signature, filter: theFilter });\n  }\n\n  static Suffix() {\n    if (!this._suffix) this._suffix = 0;\n    return this._suffix++;\n  }\n\n  makeUnique(filterText) {\n    const varNames = /result=(.+?)/g.test(filterText);\n  }\n}\n\nconst GenSVGFilters = (...filters) => {};\n\nconst Lib = new SVGFilterManagerLibrary();\nLib.addFilter('drop-shadow', {\n  generate: function({ color, dx, dy, blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    const theDropShadow = this.defs.html(\n      this.defs.html() +\n        `\n            <feDropShadow\n                id='${key}'\n                dx='${dx}'\n                dy='${dy}'\n                stdDeviation='${blur}'\n                flood-color=${color} />\n        `\n    );\n\n    return theDropShadow;\n  },\n  signature: ({ color, dx, dy, blur }) => `ds_${color}_${blur}_${dx}_${dy}`\n});\n\nLib.addFilter('blur', {\n  generate: function({ blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    const theBlur = this.defs\n      .append('feGaussianBlur')\n      .attr('stdDeviation', blur);\n\n    return theBlur;\n  },\n  signature: ({ blur }) => `gbl_${blur}`\n});\n\nLib.addFilter('inner-shadow', {\n  generate: function({ id, color, dx, dy, blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    this.defs.html(\n      this.defs.html() +\n        `\n            <feGaussianBlur\n                in='SourceAlpha'\n                stdDeviation='${blur}'\n                result='blur${id}' />\n\n            <feOffset dx=${dx} dy=${dy} />\n\n            <feComposite\n                in2='SourceAlpha'\n                operator='arithmetic'\n                k2=-1\n                k3=1\n                result='shadowDiff${id}' />\n\n            <feFlood flood-color=${color} />\n\n            <feComposite\n                in2='shadowDiff${id}'\n                operator='in' />\n\n            <feComposite\n                in2='SourceGraphic'\n                operator='over'\n                result='firstFilter${id}' />\n\n            <feComposite\n                in2='shadowDiff${id}'\n                operator='in' />\n\n            <feComposite\n                in2='firstFilter${id}'\n                operator='over' />\n        `\n    );\n  },\n  signature: ({ color, dx, dy, blur }) => `ids_${color}_${blur}_${dx}_${dy}`\n});\n\nLib.addFilter('double-inner-shadow', {\n  generate: function({ id, color, dx, dy, blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    this.defs.html(\n      this.defs.html() +\n        `\n            <feComponentTransfer in=SourceAlpha result=\"invert${id}\">\n                <feFuncA type=\"table\" tableValues=\"1 0\" />\n            </feComponentTransfer>\n            <feGaussianBlur in=\"invert${id}\" stdDeviation=\"${blur}\" result=\"blur${id}\"/>\n            <feOffset in=\"blur${id}\" dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur1${id}\"/>\n            <feOffset in=\"blur${id}\" dy=\"${-dy}\" result=\"offsetblur2${id}\"/>\n            <feFlood flood-color=\"${color}\"/> \n            <feComposite in2=\"offsetblur1${id}\" operator=\"in\" result=\"offsetblur1cut${id}\"/>\n            <feFlood flood-color=\"${color}\"/> \n            <feComposite in2=\"offsetblur2${id}\" operator=\"in\" result=\"offsetblur2cut${id}\"/>\n            <feMerge>\n                <feMergeNode in=\"SourceGraphic\" />\n                <feMergeNode in=\"offsetblur1${id}\" />\n                <feMergeNode in=\"offsetblur2${id}\" />\n            </feMerge>\n            <feComposite in2=\"SourceAlpha\" operator=\"in\" />\n        `\n    );\n  },\n  signature: ({ color, dx, dy, blur }) => `dids_${color}_${blur}_${dx}_${dy}`\n});\n\nclass SVGFilterManager {\n  constructor(defs) {\n    this._filters = {\n      boxShadow: {}\n    }; // Type : filterKey : id\n\n    this._defs = defs;\n    this._ids = {};\n\n    this._bindings = {}; // id : [DOMNode]\n  }\n\n  _bind(selection, id) {\n    const bindings = this._bindings[id];\n\n    selection.each(function(d, i) {\n      bindings.push(this);\n    });\n  }\n\n  _unbind(selection, id) {\n    const bindings = this._bindings[id];\n\n    const toRemove = [];\n    selection.each(function(d, i) {\n      toRemove.push(this);\n    });\n\n    bindings[id] = bindings.filter(node => !toRemove.includes(node));\n\n    if (bindings[id].length === 0) this._deleteFilter(id);\n  }\n\n  _deleteFilter(id) {\n    let toDelete;\n    Object.entries(this._ids).forEach(([signature, theID]) => {\n      if (theID === id) {\n        toDelete = signature;\n        return false;\n      }\n    });\n\n    delete this._ids[toDelete];\n    delete this._bindings[id];\n    this._defs.select('#' + id).remove();\n  }\n\n  hasFilter(signature) {\n    return !!this._ids[signature];\n    // return !this._defs.select('#' + signature).empty();\n  }\n\n  signature(...args) {\n    // ['name', arg, 'name2', arg]\n    // ['', ]\n    return (\n      'F_' +\n      args\n        .map((arg, i) => (i % 2 === 0 ? '' : Lib.signature(args[i - 1], arg)))\n        .filter(v => v !== '')\n        .join('_')\n    );\n  }\n\n  /**\n   * Creates a filter from the list of filters in the format\n   * (filter-name-1, args1, filter-name-2, args2, ... , filter-name-N, argsN)\n   *\n   * @param {*} args\n   * @memberof SVGFilterManager\n   */\n  createFilter(...args) {\n    // 1. Compute signature and see if it already exists\n    const signature = this.signature(...args);\n\n    if (this.hasFilter(signature)) return this.getFilterID(signature);\n\n    const theID = (this._ids[signature] = SVGFilterManager._genID());\n    this._bindings[theID] = [];\n\n    const filterEntry = this._defs\n      .append('filter')\n      .attr('id', theID)\n      .attr('height', '300%')\n      .attr('width', '300%')\n      .attr('x', '-100%')\n      .attr('y', '-100%');\n\n    filterEntry.node().__filters__ = [];\n\n    args.forEach((arg, i) => {\n      if (i % 2 === 0) return Lib.generate(filterEntry, arg, args[i + 1]);\n    });\n\n    return theID;\n  }\n\n  static _genID() {\n    if (!this.__idc__) this.__idc__ = 0;\n    return `FILTER_${this.__idc__++}`;\n  }\n\n  // _genID() {\n  // }\n\n  getFilterID(signature) {\n    return this._ids[signature];\n  }\n}\n\nd3.selection.prototype.svgFilter = function(...filters) {\n  // name, args, name1, args1, ... ,nameN, argsN\n  // If no defs entry, generate one at the root and set it @ the svg filter manager\n  // create a new svg filter manager for that svg\n\n  // 1. Find topmost SVG\n  // let svg = d3.select(this.node().farthestViewportElement || this.node().closest('svg'));\n\n  // // 2. Ensure the defs entry exists\n  // let defs = svg.select(':scope>defs.svg-custom-filters');\n  // if (defs.empty()) {\n  //     defs = svg.append('defs').attr('class', 'svg-custom-filters');\n  //     defs.node()._svgFilterManager = new SVGFilterManager(defs);\n  // }\n\n  const defs = this.svgFilterDefs();\n\n  const filterManager = defs.node()._svgFilterManager;\n  const filterID = filterManager.createFilter(...filters);\n\n  this.each(function(d) {\n    const sel = d3.select(this);\n    if (filterID === sel.getFilterID()) return;\n    sel.clearFilter();\n\n    sel.attr('filter', `url(#${filterID})`);\n    filterManager._bind(sel, filterID);\n  });\n\n  // 3. Generate a filter manager if not existing\n\n  // TheFilterManager._defs;\n  // const ids = GenSVGFilters(filters);\n};\n\nd3.selection.prototype.svgFilterDefs = function() {\n  // 1. Find topmost SVG\n  let svg = d3.select(\n    this.node().farthestViewportElement || this.node().closest('svg')\n  );\n\n  // 2. Ensure the defs entry exists\n  let defs = svg.select(':scope>defs.svg-custom-filters');\n  if (defs.empty()) {\n    defs = svg.append('defs').attr('class', 'svg-custom-filters');\n    defs.node()._svgFilterManager = new SVGFilterManager(defs);\n  }\n\n  return defs;\n};\n\nd3.selection.prototype.getFilterID = function() {\n  const filterAttr = this.attr('filter');\n\n  let filterID;\n  if (!!filterAttr) filterID = /\\(\\#(.+)\\)/.exec(filterAttr)[1];\n\n  return filterID;\n};\n\nd3.selection.prototype.clearFilter = function() {\n  this.each(function(d, i) {\n    const sel = d3.select(this);\n    const filterID = sel.getFilterID();\n    if (!filterID) return;\n\n    const defs = sel.svgFilterDefs();\n    const filterManager = defs.node()._svgFilterManager;\n\n    sel.attr('filter', null);\n    filterManager._unbind(sel, filterID);\n  });\n\n  return this;\n};\n\nd3.svgFilterLib = Lib;\n\n// const originalRemove = d3.selection.prototype.remove;\n// d3.selection.prototype.remove = function () { // Add in clear filter to remove fn!\n//     this.selectAll('*').clearFilter();\n//     originalRemove.call(this, ...arguments);\n// }\n\n// d3.svgFilter = (name, args) => lib.filter(name)(args);\n\n// Example usage\nconst selection = {};\n\n// selection\n//     .svgFilter(\n//         d3.svgFilterBoxShadow({\n//             dx: '5%',\n//             dy: '5%',\n//             blur: '25%'\n//         }),\n//         d3.svgFilterBoxShadowInset({\n//             dx: '5%',\n//             dy: '5%',\n//             blur: '25%'\n//         })\n//     );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9saWJzL2Qzc3ZnZmlsdGVycy9zcmMvZDMtc3ZnLWZpbHRlcnMuanM/NDRkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLEtBQTZCLEdBQUcsbUJBQU8sQ0FBQyxjQUFJLElBQUksU0FBUzs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksZ0NBQWdDLDBCQUEwQjtBQUM3Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxrQ0FBa0MsK0JBQStCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUIsc0JBQXNCLEdBQUc7QUFDekIsc0JBQXNCLEdBQUc7QUFDekIsZ0NBQWdDLEtBQUs7QUFDckMsOEJBQThCLE1BQU07QUFDcEM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxlQUFlLHNCQUFzQixXQUFXLE1BQU0sR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDMUUsQ0FBQzs7QUFFRDtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxlQUFlLE9BQU8sWUFBWSxLQUFLO0FBQ3ZDLENBQUM7O0FBRUQ7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQyw4QkFBOEIsR0FBRzs7QUFFakMsMkJBQTJCLEdBQUcsTUFBTSxHQUFHOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUc7O0FBRXZDLG1DQUFtQyxNQUFNOztBQUV6QztBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxHQUFHOztBQUV4QztBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDOztBQUVBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCLFlBQVksTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztBQUMzRSxDQUFDOztBQUVEO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBLDBDQUEwQyxJQUFJOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRztBQUNuRTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUcsa0JBQWtCLEtBQUssZ0JBQWdCLEdBQUc7QUFDckYsZ0NBQWdDLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyx1QkFBdUIsR0FBRztBQUNuRixnQ0FBZ0MsR0FBRyxRQUFRLElBQUksdUJBQXVCLEdBQUc7QUFDekUsb0NBQW9DLE1BQU07QUFDMUMsMkNBQTJDLEdBQUcsd0NBQXdDLEdBQUc7QUFDekYsb0NBQW9DLE1BQU07QUFDMUMsMkNBQTJDLEdBQUcsd0NBQXdDLEdBQUc7QUFDekY7QUFDQTtBQUNBLDhDQUE4QyxHQUFHO0FBQ2pELDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCLGFBQWEsTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztBQUM1RSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJmaWxlIjoiLi9saWJzL2Qzc3ZnZmlsdGVycy9zcmMvZDMtc3ZnLWZpbHRlcnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkMyA9IHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gcmVxdWlyZSgnZDMnKSA6IHdpbmRvdy5kMztcblxuY2xhc3MgU1ZHRmlsdGVyIHtcbiAgY29uc3RydWN0b3Ioc3BlYykge31cblxuICBzZXQgaWQoaWQpIHtcbiAgICB0aGlzLl9pZCA9IGlkO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cbn1cblxuY2xhc3MgU1ZHRmlsdGVyTWFuYWdlckxpYnJhcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9saWJyYXJ5ID0ge307IC8vIG5hbWUgOiB7IGdlbmVyYXRlOiAoZGVmcykgPT4gKGFyZ3MpID0+IHsgIGFwcGVuZHMgZmlsdGVyIHRvIGRlZnMgfSwgc2lnbmF0dXJlOiAoYXJncykgPT4ga2V5fVxuICB9XG5cbiAgc3RhdGljIEdlbmVyYXRlSUQoKSB7XG4gICAgaWYgKCF0aGlzLl9fSUQpIHRoaXMuX19JRCA9IDA7XG5cbiAgICByZXR1cm4gKyt0aGlzLl9fSUQ7XG4gIH1cblxuICBhZGRGaWx0ZXIobmFtZSwgZm5zKSB7XG4gICAgdGhpcy5fbGlicmFyeVtuYW1lXSA9IGZucztcbiAgfVxuXG4gIHNpZ25hdHVyZShmaWx0ZXJOYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpYnJhcnlbZmlsdGVyTmFtZV1cbiAgICAgIC5zaWduYXR1cmUoYXJncylcbiAgICAgIC5yZXBsYWNlKC9cXDp8XFwsfFxcLnxcXDsvZywgJ18nKVxuICAgICAgLnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAucmVwbGFjZSgvXFwjL2csICdoJylcbiAgICAgIC5yZXBsYWNlKC9cXCgvZywgJ2wnKVxuICAgICAgLnJlcGxhY2UoL1xcKS9nLCAncicpO1xuICB9XG5cbiAgZ2VuZXJhdGUoZGVmcywgZmlsdGVyTmFtZSwgYXJncykge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbmF0dXJlKGZpbHRlck5hbWUsIGFyZ3MpO1xuICAgIGNvbnN0IGN0eCA9IHsgc2lnbmF0dXJlLCBkZWZzIH07XG4gICAgY29uc3QgdGhlRmlsdGVyID0gdGhpcy5fbGlicmFyeVtmaWx0ZXJOYW1lXS5nZW5lcmF0ZS5jYWxsKGN0eCwge1xuICAgICAgLi4uYXJncyxcbiAgICAgIGlkOiBTVkdGaWx0ZXJNYW5hZ2VyTGlicmFyeS5HZW5lcmF0ZUlEKClcbiAgICB9KTtcblxuICAgIGRlZnMubm9kZSgpLl9fZmlsdGVyc19fLnB1c2goeyBzaWduYXR1cmUsIGZpbHRlcjogdGhlRmlsdGVyIH0pO1xuICB9XG5cbiAgc3RhdGljIFN1ZmZpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3N1ZmZpeCkgdGhpcy5fc3VmZml4ID0gMDtcbiAgICByZXR1cm4gdGhpcy5fc3VmZml4Kys7XG4gIH1cblxuICBtYWtlVW5pcXVlKGZpbHRlclRleHQpIHtcbiAgICBjb25zdCB2YXJOYW1lcyA9IC9yZXN1bHQ9KC4rPykvZy50ZXN0KGZpbHRlclRleHQpO1xuICB9XG59XG5cbmNvbnN0IEdlblNWR0ZpbHRlcnMgPSAoLi4uZmlsdGVycykgPT4ge307XG5cbmNvbnN0IExpYiA9IG5ldyBTVkdGaWx0ZXJNYW5hZ2VyTGlicmFyeSgpO1xuTGliLmFkZEZpbHRlcignZHJvcC1zaGFkb3cnLCB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGNvbG9yLCBkeCwgZHksIGJsdXIgfSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5kZWZzLnNlbGVjdChgIyR7a2V5fWApO1xuXG4gICAgaWYgKCFleGlzdGluZy5lbXB0eSgpKSByZXR1cm4gZXhpc3Rpbmc7XG5cbiAgICBjb25zdCB0aGVEcm9wU2hhZG93ID0gdGhpcy5kZWZzLmh0bWwoXG4gICAgICB0aGlzLmRlZnMuaHRtbCgpICtcbiAgICAgICAgYFxuICAgICAgICAgICAgPGZlRHJvcFNoYWRvd1xuICAgICAgICAgICAgICAgIGlkPScke2tleX0nXG4gICAgICAgICAgICAgICAgZHg9JyR7ZHh9J1xuICAgICAgICAgICAgICAgIGR5PScke2R5fSdcbiAgICAgICAgICAgICAgICBzdGREZXZpYXRpb249JyR7Ymx1cn0nXG4gICAgICAgICAgICAgICAgZmxvb2QtY29sb3I9JHtjb2xvcn0gLz5cbiAgICAgICAgYFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhlRHJvcFNoYWRvdztcbiAgfSxcbiAgc2lnbmF0dXJlOiAoeyBjb2xvciwgZHgsIGR5LCBibHVyIH0pID0+IGBkc18ke2NvbG9yfV8ke2JsdXJ9XyR7ZHh9XyR7ZHl9YFxufSk7XG5cbkxpYi5hZGRGaWx0ZXIoJ2JsdXInLCB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGJsdXIgfSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5kZWZzLnNlbGVjdChgIyR7a2V5fWApO1xuXG4gICAgaWYgKCFleGlzdGluZy5lbXB0eSgpKSByZXR1cm4gZXhpc3Rpbmc7XG5cbiAgICBjb25zdCB0aGVCbHVyID0gdGhpcy5kZWZzXG4gICAgICAuYXBwZW5kKCdmZUdhdXNzaWFuQmx1cicpXG4gICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgYmx1cik7XG5cbiAgICByZXR1cm4gdGhlQmx1cjtcbiAgfSxcbiAgc2lnbmF0dXJlOiAoeyBibHVyIH0pID0+IGBnYmxfJHtibHVyfWBcbn0pO1xuXG5MaWIuYWRkRmlsdGVyKCdpbm5lci1zaGFkb3cnLCB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGlkLCBjb2xvciwgZHgsIGR5LCBibHVyIH0pIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnNpZ25hdHVyZTtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZGVmcy5zZWxlY3QoYCMke2tleX1gKTtcblxuICAgIGlmICghZXhpc3RpbmcuZW1wdHkoKSkgcmV0dXJuIGV4aXN0aW5nO1xuXG4gICAgdGhpcy5kZWZzLmh0bWwoXG4gICAgICB0aGlzLmRlZnMuaHRtbCgpICtcbiAgICAgICAgYFxuICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyXG4gICAgICAgICAgICAgICAgaW49J1NvdXJjZUFscGhhJ1xuICAgICAgICAgICAgICAgIHN0ZERldmlhdGlvbj0nJHtibHVyfSdcbiAgICAgICAgICAgICAgICByZXN1bHQ9J2JsdXIke2lkfScgLz5cblxuICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSR7ZHh9IGR5PSR7ZHl9IC8+XG5cbiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZVxuICAgICAgICAgICAgICAgIGluMj0nU291cmNlQWxwaGEnXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I9J2FyaXRobWV0aWMnXG4gICAgICAgICAgICAgICAgazI9LTFcbiAgICAgICAgICAgICAgICBrMz0xXG4gICAgICAgICAgICAgICAgcmVzdWx0PSdzaGFkb3dEaWZmJHtpZH0nIC8+XG5cbiAgICAgICAgICAgIDxmZUZsb29kIGZsb29kLWNvbG9yPSR7Y29sb3J9IC8+XG5cbiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZVxuICAgICAgICAgICAgICAgIGluMj0nc2hhZG93RGlmZiR7aWR9J1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yPSdpbicgLz5cblxuICAgICAgICAgICAgPGZlQ29tcG9zaXRlXG4gICAgICAgICAgICAgICAgaW4yPSdTb3VyY2VHcmFwaGljJ1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yPSdvdmVyJ1xuICAgICAgICAgICAgICAgIHJlc3VsdD0nZmlyc3RGaWx0ZXIke2lkfScgLz5cblxuICAgICAgICAgICAgPGZlQ29tcG9zaXRlXG4gICAgICAgICAgICAgICAgaW4yPSdzaGFkb3dEaWZmJHtpZH0nXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I9J2luJyAvPlxuXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGVcbiAgICAgICAgICAgICAgICBpbjI9J2ZpcnN0RmlsdGVyJHtpZH0nXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I9J292ZXInIC8+XG4gICAgICAgIGBcbiAgICApO1xuICB9LFxuICBzaWduYXR1cmU6ICh7IGNvbG9yLCBkeCwgZHksIGJsdXIgfSkgPT4gYGlkc18ke2NvbG9yfV8ke2JsdXJ9XyR7ZHh9XyR7ZHl9YFxufSk7XG5cbkxpYi5hZGRGaWx0ZXIoJ2RvdWJsZS1pbm5lci1zaGFkb3cnLCB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGlkLCBjb2xvciwgZHgsIGR5LCBibHVyIH0pIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnNpZ25hdHVyZTtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZGVmcy5zZWxlY3QoYCMke2tleX1gKTtcblxuICAgIGlmICghZXhpc3RpbmcuZW1wdHkoKSkgcmV0dXJuIGV4aXN0aW5nO1xuXG4gICAgdGhpcy5kZWZzLmh0bWwoXG4gICAgICB0aGlzLmRlZnMuaHRtbCgpICtcbiAgICAgICAgYFxuICAgICAgICAgICAgPGZlQ29tcG9uZW50VHJhbnNmZXIgaW49U291cmNlQWxwaGEgcmVzdWx0PVwiaW52ZXJ0JHtpZH1cIj5cbiAgICAgICAgICAgICAgICA8ZmVGdW5jQSB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cIjEgMFwiIC8+XG4gICAgICAgICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+XG4gICAgICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgaW49XCJpbnZlcnQke2lkfVwiIHN0ZERldmlhdGlvbj1cIiR7Ymx1cn1cIiByZXN1bHQ9XCJibHVyJHtpZH1cIi8+XG4gICAgICAgICAgICA8ZmVPZmZzZXQgaW49XCJibHVyJHtpZH1cIiBkeD1cIiR7ZHh9XCIgZHk9XCIke2R5fVwiIHJlc3VsdD1cIm9mZnNldGJsdXIxJHtpZH1cIi8+XG4gICAgICAgICAgICA8ZmVPZmZzZXQgaW49XCJibHVyJHtpZH1cIiBkeT1cIiR7LWR5fVwiIHJlc3VsdD1cIm9mZnNldGJsdXIyJHtpZH1cIi8+XG4gICAgICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiR7Y29sb3J9XCIvPiBcbiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJvZmZzZXRibHVyMSR7aWR9XCIgb3BlcmF0b3I9XCJpblwiIHJlc3VsdD1cIm9mZnNldGJsdXIxY3V0JHtpZH1cIi8+XG4gICAgICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiR7Y29sb3J9XCIvPiBcbiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJvZmZzZXRibHVyMiR7aWR9XCIgb3BlcmF0b3I9XCJpblwiIHJlc3VsdD1cIm9mZnNldGJsdXIyY3V0JHtpZH1cIi8+XG4gICAgICAgICAgICA8ZmVNZXJnZT5cbiAgICAgICAgICAgICAgICA8ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCIgLz5cbiAgICAgICAgICAgICAgICA8ZmVNZXJnZU5vZGUgaW49XCJvZmZzZXRibHVyMSR7aWR9XCIgLz5cbiAgICAgICAgICAgICAgICA8ZmVNZXJnZU5vZGUgaW49XCJvZmZzZXRibHVyMiR7aWR9XCIgLz5cbiAgICAgICAgICAgIDwvZmVNZXJnZT5cbiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJTb3VyY2VBbHBoYVwiIG9wZXJhdG9yPVwiaW5cIiAvPlxuICAgICAgICBgXG4gICAgKTtcbiAgfSxcbiAgc2lnbmF0dXJlOiAoeyBjb2xvciwgZHgsIGR5LCBibHVyIH0pID0+IGBkaWRzXyR7Y29sb3J9XyR7Ymx1cn1fJHtkeH1fJHtkeX1gXG59KTtcblxuY2xhc3MgU1ZHRmlsdGVyTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRlZnMpIHtcbiAgICB0aGlzLl9maWx0ZXJzID0ge1xuICAgICAgYm94U2hhZG93OiB7fVxuICAgIH07IC8vIFR5cGUgOiBmaWx0ZXJLZXkgOiBpZFxuXG4gICAgdGhpcy5fZGVmcyA9IGRlZnM7XG4gICAgdGhpcy5faWRzID0ge307XG5cbiAgICB0aGlzLl9iaW5kaW5ncyA9IHt9OyAvLyBpZCA6IFtET01Ob2RlXVxuICB9XG5cbiAgX2JpbmQoc2VsZWN0aW9uLCBpZCkge1xuICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3NbaWRdO1xuXG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgYmluZGluZ3MucHVzaCh0aGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIF91bmJpbmQoc2VsZWN0aW9uLCBpZCkge1xuICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3NbaWRdO1xuXG4gICAgY29uc3QgdG9SZW1vdmUgPSBbXTtcbiAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICB0b1JlbW92ZS5wdXNoKHRoaXMpO1xuICAgIH0pO1xuXG4gICAgYmluZGluZ3NbaWRdID0gYmluZGluZ3MuZmlsdGVyKG5vZGUgPT4gIXRvUmVtb3ZlLmluY2x1ZGVzKG5vZGUpKTtcblxuICAgIGlmIChiaW5kaW5nc1tpZF0ubGVuZ3RoID09PSAwKSB0aGlzLl9kZWxldGVGaWx0ZXIoaWQpO1xuICB9XG5cbiAgX2RlbGV0ZUZpbHRlcihpZCkge1xuICAgIGxldCB0b0RlbGV0ZTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9pZHMpLmZvckVhY2goKFtzaWduYXR1cmUsIHRoZUlEXSkgPT4ge1xuICAgICAgaWYgKHRoZUlEID09PSBpZCkge1xuICAgICAgICB0b0RlbGV0ZSA9IHNpZ25hdHVyZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVsZXRlIHRoaXMuX2lkc1t0b0RlbGV0ZV07XG4gICAgZGVsZXRlIHRoaXMuX2JpbmRpbmdzW2lkXTtcbiAgICB0aGlzLl9kZWZzLnNlbGVjdCgnIycgKyBpZCkucmVtb3ZlKCk7XG4gIH1cblxuICBoYXNGaWx0ZXIoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faWRzW3NpZ25hdHVyZV07XG4gICAgLy8gcmV0dXJuICF0aGlzLl9kZWZzLnNlbGVjdCgnIycgKyBzaWduYXR1cmUpLmVtcHR5KCk7XG4gIH1cblxuICBzaWduYXR1cmUoLi4uYXJncykge1xuICAgIC8vIFsnbmFtZScsIGFyZywgJ25hbWUyJywgYXJnXVxuICAgIC8vIFsnJywgXVxuICAgIHJldHVybiAoXG4gICAgICAnRl8nICtcbiAgICAgIGFyZ3NcbiAgICAgICAgLm1hcCgoYXJnLCBpKSA9PiAoaSAlIDIgPT09IDAgPyAnJyA6IExpYi5zaWduYXR1cmUoYXJnc1tpIC0gMV0sIGFyZykpKVxuICAgICAgICAuZmlsdGVyKHYgPT4gdiAhPT0gJycpXG4gICAgICAgIC5qb2luKCdfJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmaWx0ZXIgZnJvbSB0aGUgbGlzdCBvZiBmaWx0ZXJzIGluIHRoZSBmb3JtYXRcbiAgICogKGZpbHRlci1uYW1lLTEsIGFyZ3MxLCBmaWx0ZXItbmFtZS0yLCBhcmdzMiwgLi4uICwgZmlsdGVyLW5hbWUtTiwgYXJnc04pXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYXJnc1xuICAgKiBAbWVtYmVyb2YgU1ZHRmlsdGVyTWFuYWdlclxuICAgKi9cbiAgY3JlYXRlRmlsdGVyKC4uLmFyZ3MpIHtcbiAgICAvLyAxLiBDb21wdXRlIHNpZ25hdHVyZSBhbmQgc2VlIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5zaWduYXR1cmUoLi4uYXJncyk7XG5cbiAgICBpZiAodGhpcy5oYXNGaWx0ZXIoc2lnbmF0dXJlKSkgcmV0dXJuIHRoaXMuZ2V0RmlsdGVySUQoc2lnbmF0dXJlKTtcblxuICAgIGNvbnN0IHRoZUlEID0gKHRoaXMuX2lkc1tzaWduYXR1cmVdID0gU1ZHRmlsdGVyTWFuYWdlci5fZ2VuSUQoKSk7XG4gICAgdGhpcy5fYmluZGluZ3NbdGhlSURdID0gW107XG5cbiAgICBjb25zdCBmaWx0ZXJFbnRyeSA9IHRoaXMuX2RlZnNcbiAgICAgIC5hcHBlbmQoJ2ZpbHRlcicpXG4gICAgICAuYXR0cignaWQnLCB0aGVJRClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCAnMzAwJScpXG4gICAgICAuYXR0cignd2lkdGgnLCAnMzAwJScpXG4gICAgICAuYXR0cigneCcsICctMTAwJScpXG4gICAgICAuYXR0cigneScsICctMTAwJScpO1xuXG4gICAgZmlsdGVyRW50cnkubm9kZSgpLl9fZmlsdGVyc19fID0gW107XG5cbiAgICBhcmdzLmZvckVhY2goKGFyZywgaSkgPT4ge1xuICAgICAgaWYgKGkgJSAyID09PSAwKSByZXR1cm4gTGliLmdlbmVyYXRlKGZpbHRlckVudHJ5LCBhcmcsIGFyZ3NbaSArIDFdKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGVJRDtcbiAgfVxuXG4gIHN0YXRpYyBfZ2VuSUQoKSB7XG4gICAgaWYgKCF0aGlzLl9faWRjX18pIHRoaXMuX19pZGNfXyA9IDA7XG4gICAgcmV0dXJuIGBGSUxURVJfJHt0aGlzLl9faWRjX18rK31gO1xuICB9XG5cbiAgLy8gX2dlbklEKCkge1xuICAvLyB9XG5cbiAgZ2V0RmlsdGVySUQoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkc1tzaWduYXR1cmVdO1xuICB9XG59XG5cbmQzLnNlbGVjdGlvbi5wcm90b3R5cGUuc3ZnRmlsdGVyID0gZnVuY3Rpb24oLi4uZmlsdGVycykge1xuICAvLyBuYW1lLCBhcmdzLCBuYW1lMSwgYXJnczEsIC4uLiAsbmFtZU4sIGFyZ3NOXG4gIC8vIElmIG5vIGRlZnMgZW50cnksIGdlbmVyYXRlIG9uZSBhdCB0aGUgcm9vdCBhbmQgc2V0IGl0IEAgdGhlIHN2ZyBmaWx0ZXIgbWFuYWdlclxuICAvLyBjcmVhdGUgYSBuZXcgc3ZnIGZpbHRlciBtYW5hZ2VyIGZvciB0aGF0IHN2Z1xuXG4gIC8vIDEuIEZpbmQgdG9wbW9zdCBTVkdcbiAgLy8gbGV0IHN2ZyA9IGQzLnNlbGVjdCh0aGlzLm5vZGUoKS5mYXJ0aGVzdFZpZXdwb3J0RWxlbWVudCB8fCB0aGlzLm5vZGUoKS5jbG9zZXN0KCdzdmcnKSk7XG5cbiAgLy8gLy8gMi4gRW5zdXJlIHRoZSBkZWZzIGVudHJ5IGV4aXN0c1xuICAvLyBsZXQgZGVmcyA9IHN2Zy5zZWxlY3QoJzpzY29wZT5kZWZzLnN2Zy1jdXN0b20tZmlsdGVycycpO1xuICAvLyBpZiAoZGVmcy5lbXB0eSgpKSB7XG4gIC8vICAgICBkZWZzID0gc3ZnLmFwcGVuZCgnZGVmcycpLmF0dHIoJ2NsYXNzJywgJ3N2Zy1jdXN0b20tZmlsdGVycycpO1xuICAvLyAgICAgZGVmcy5ub2RlKCkuX3N2Z0ZpbHRlck1hbmFnZXIgPSBuZXcgU1ZHRmlsdGVyTWFuYWdlcihkZWZzKTtcbiAgLy8gfVxuXG4gIGNvbnN0IGRlZnMgPSB0aGlzLnN2Z0ZpbHRlckRlZnMoKTtcblxuICBjb25zdCBmaWx0ZXJNYW5hZ2VyID0gZGVmcy5ub2RlKCkuX3N2Z0ZpbHRlck1hbmFnZXI7XG4gIGNvbnN0IGZpbHRlcklEID0gZmlsdGVyTWFuYWdlci5jcmVhdGVGaWx0ZXIoLi4uZmlsdGVycyk7XG5cbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICBjb25zdCBzZWwgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgaWYgKGZpbHRlcklEID09PSBzZWwuZ2V0RmlsdGVySUQoKSkgcmV0dXJuO1xuICAgIHNlbC5jbGVhckZpbHRlcigpO1xuXG4gICAgc2VsLmF0dHIoJ2ZpbHRlcicsIGB1cmwoIyR7ZmlsdGVySUR9KWApO1xuICAgIGZpbHRlck1hbmFnZXIuX2JpbmQoc2VsLCBmaWx0ZXJJRCk7XG4gIH0pO1xuXG4gIC8vIDMuIEdlbmVyYXRlIGEgZmlsdGVyIG1hbmFnZXIgaWYgbm90IGV4aXN0aW5nXG5cbiAgLy8gVGhlRmlsdGVyTWFuYWdlci5fZGVmcztcbiAgLy8gY29uc3QgaWRzID0gR2VuU1ZHRmlsdGVycyhmaWx0ZXJzKTtcbn07XG5cbmQzLnNlbGVjdGlvbi5wcm90b3R5cGUuc3ZnRmlsdGVyRGVmcyA9IGZ1bmN0aW9uKCkge1xuICAvLyAxLiBGaW5kIHRvcG1vc3QgU1ZHXG4gIGxldCBzdmcgPSBkMy5zZWxlY3QoXG4gICAgdGhpcy5ub2RlKCkuZmFydGhlc3RWaWV3cG9ydEVsZW1lbnQgfHwgdGhpcy5ub2RlKCkuY2xvc2VzdCgnc3ZnJylcbiAgKTtcblxuICAvLyAyLiBFbnN1cmUgdGhlIGRlZnMgZW50cnkgZXhpc3RzXG4gIGxldCBkZWZzID0gc3ZnLnNlbGVjdCgnOnNjb3BlPmRlZnMuc3ZnLWN1c3RvbS1maWx0ZXJzJyk7XG4gIGlmIChkZWZzLmVtcHR5KCkpIHtcbiAgICBkZWZzID0gc3ZnLmFwcGVuZCgnZGVmcycpLmF0dHIoJ2NsYXNzJywgJ3N2Zy1jdXN0b20tZmlsdGVycycpO1xuICAgIGRlZnMubm9kZSgpLl9zdmdGaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR0ZpbHRlck1hbmFnZXIoZGVmcyk7XG4gIH1cblxuICByZXR1cm4gZGVmcztcbn07XG5cbmQzLnNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0RmlsdGVySUQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZmlsdGVyQXR0ciA9IHRoaXMuYXR0cignZmlsdGVyJyk7XG5cbiAgbGV0IGZpbHRlcklEO1xuICBpZiAoISFmaWx0ZXJBdHRyKSBmaWx0ZXJJRCA9IC9cXChcXCMoLispXFwpLy5leGVjKGZpbHRlckF0dHIpWzFdO1xuXG4gIHJldHVybiBmaWx0ZXJJRDtcbn07XG5cbmQzLnNlbGVjdGlvbi5wcm90b3R5cGUuY2xlYXJGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICBjb25zdCBzZWwgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgY29uc3QgZmlsdGVySUQgPSBzZWwuZ2V0RmlsdGVySUQoKTtcbiAgICBpZiAoIWZpbHRlcklEKSByZXR1cm47XG5cbiAgICBjb25zdCBkZWZzID0gc2VsLnN2Z0ZpbHRlckRlZnMoKTtcbiAgICBjb25zdCBmaWx0ZXJNYW5hZ2VyID0gZGVmcy5ub2RlKCkuX3N2Z0ZpbHRlck1hbmFnZXI7XG5cbiAgICBzZWwuYXR0cignZmlsdGVyJywgbnVsbCk7XG4gICAgZmlsdGVyTWFuYWdlci5fdW5iaW5kKHNlbCwgZmlsdGVySUQpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmQzLnN2Z0ZpbHRlckxpYiA9IExpYjtcblxuLy8gY29uc3Qgb3JpZ2luYWxSZW1vdmUgPSBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZTtcbi8vIGQzLnNlbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkgeyAvLyBBZGQgaW4gY2xlYXIgZmlsdGVyIHRvIHJlbW92ZSBmbiFcbi8vICAgICB0aGlzLnNlbGVjdEFsbCgnKicpLmNsZWFyRmlsdGVyKCk7XG4vLyAgICAgb3JpZ2luYWxSZW1vdmUuY2FsbCh0aGlzLCAuLi5hcmd1bWVudHMpO1xuLy8gfVxuXG4vLyBkMy5zdmdGaWx0ZXIgPSAobmFtZSwgYXJncykgPT4gbGliLmZpbHRlcihuYW1lKShhcmdzKTtcblxuLy8gRXhhbXBsZSB1c2FnZVxuY29uc3Qgc2VsZWN0aW9uID0ge307XG5cbi8vIHNlbGVjdGlvblxuLy8gICAgIC5zdmdGaWx0ZXIoXG4vLyAgICAgICAgIGQzLnN2Z0ZpbHRlckJveFNoYWRvdyh7XG4vLyAgICAgICAgICAgICBkeDogJzUlJyxcbi8vICAgICAgICAgICAgIGR5OiAnNSUnLFxuLy8gICAgICAgICAgICAgYmx1cjogJzI1JSdcbi8vICAgICAgICAgfSksXG4vLyAgICAgICAgIGQzLnN2Z0ZpbHRlckJveFNoYWRvd0luc2V0KHtcbi8vICAgICAgICAgICAgIGR4OiAnNSUnLFxuLy8gICAgICAgICAgICAgZHk6ICc1JScsXG4vLyAgICAgICAgICAgICBibHVyOiAnMjUlJ1xuLy8gICAgICAgICB9KVxuLy8gICAgICk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./libs/d3svgfilters/src/d3-svg-filters.js\n"
          );

          /***/
        },

      /***/ './node_modules/css-loader/dist/cjs.js!./css/SplitStream.css':
        /*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css ***!
  \*******************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);\n// Module\nexports.push([module.i, "", ""]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9jc3MvU3BsaXRTdHJlYW0uY3NzPzUxYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMscUdBQWdEO0FBQ25GO0FBQ0EsY0FBYyxRQUFTIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9jc3MvU3BsaXRTdHJlYW0uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css\n'
          );

          /***/
        },

      /***/ './node_modules/css-loader/dist/runtime/api.js':
        /*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            '\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], "{").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwie1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW19pXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCIoXCIuY29uY2F0KGl0ZW1bMl0sIFwiKSBhbmQgKFwiKS5jb25jYXQobWVkaWFRdWVyeSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n'
          );

          /***/
        },

      /***/ './node_modules/flatted/esm/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/flatted/esm/index.js ***!
  \*******************************************/
        /*! exports provided: default, parse, stringify */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\nvar Flatted = (function (Primitive, primitive) {\n\n  /*!\n   * ISC License\n   *\n   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection\n   *\n   * Permission to use, copy, modify, and/or distribute this software for any\n   * purpose with or without fee is hereby granted, provided that the above\n   * copyright notice and this permission notice appear in all copies.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n   * PERFORMANCE OF THIS SOFTWARE.\n   */\n\n  var Flatted = {\n\n    parse: function parse(text, reviver) {\n      var input = JSON.parse(text, Primitives).map(primitives);\n      var value = input[0];\n      var $ = reviver || noop;\n      var tmp = typeof value === 'object' && value ?\n                  revive(input, new Set, value, $) :\n                  value;\n      return $.call({'': tmp}, '', tmp);\n    },\n\n    stringify: function stringify(value, replacer, space) {\n      for (var\n        firstRun,\n        known = new Map,\n        input = [],\n        output = [],\n        $ = replacer && typeof replacer === typeof input ?\n              function (k, v) {\n                if (k === '' || -1 < replacer.indexOf(k)) return v;\n              } :\n              (replacer || noop),\n        i = +set(known, input, $.call({'': value}, '', value)),\n        replace = function (key, value) {\n          if (firstRun) {\n            firstRun = !firstRun;\n            return value;\n            // this was invoking twice each root object\n            // return i < 1 ? value : $.call(this, key, value);\n          }\n          var after = $.call(this, key, value);\n          switch (typeof after) {\n            case 'object':\n              if (after === null) return after;\n            case primitive:\n              return known.get(after) || set(known, input, after);\n          }\n          return after;\n        };\n        i < input.length; i++\n      ) {\n        firstRun = true;\n        output[i] = JSON.stringify(input[i], replace, space);\n      }\n      return '[' + output.join(',') + ']';\n    }\n\n  };\n\n  return Flatted;\n\n  function noop(key, value) {\n    return value;\n  }\n\n  function revive(input, parsed, output, $) {\n    return Object.keys(output).reduce(\n      function (output, key) {\n        var value = output[key];\n        if (value instanceof Primitive) {\n          var tmp = input[value];\n          if (typeof tmp === 'object' && !parsed.has(tmp)) {\n            parsed.add(tmp);\n            output[key] = $.call(output, key, revive(input, parsed, tmp, $));\n          } else {\n            output[key] = $.call(output, key, tmp);\n          }\n        } else\n          output[key] = $.call(output, key, value);\n        return output;\n      },\n      output\n    );\n  }\n\n  function set(known, input, value) {\n    var index = Primitive(input.push(value) - 1);\n    known.set(value, index);\n    return index;\n  }\n\n  // the two kinds of primitives\n  //  1. the real one\n  //  2. the wrapped one\n\n  function primitives(value) {\n    return value instanceof Primitive ? Primitive(value) : value;\n  }\n\n  function Primitives(key, value) {\n    return typeof value === primitive ? new Primitive(value) : value;\n  }\n\n}(String, 'string'));\n/* harmony default export */ __webpack_exports__[\"default\"] = (Flatted);\nvar parse = Flatted.parse;\nvar stringify = Flatted.stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvZmxhdHRlZC9lc20vaW5kZXguanM/NWJjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNjLHNFQUFPLEVBQUM7QUFDaEI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9mbGF0dGVkL2VzbS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBGbGF0dGVkID0gKGZ1bmN0aW9uIChQcmltaXRpdmUsIHByaW1pdGl2ZSkge1xuXG4gIC8qIVxuICAgKiBJU0MgTGljZW5zZVxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTgsIEFuZHJlYSBHaWFtbWFyY2hpLCBAV2ViUmVmbGVjdGlvblxuICAgKlxuICAgKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAgICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICAgKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICAgKlxuICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG4gICAqIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuICAgKiBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG4gICAqIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuICAgKiBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRVxuICAgKiBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG4gICAqIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gICAqL1xuXG4gIHZhciBGbGF0dGVkID0ge1xuXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRleHQsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnB1dCA9IEpTT04ucGFyc2UodGV4dCwgUHJpbWl0aXZlcykubWFwKHByaW1pdGl2ZXMpO1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbMF07XG4gICAgICB2YXIgJCA9IHJldml2ZXIgfHwgbm9vcDtcbiAgICAgIHZhciB0bXAgPSB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlID9cbiAgICAgICAgICAgICAgICAgIHJldml2ZShpbnB1dCwgbmV3IFNldCwgdmFsdWUsICQpIDpcbiAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgcmV0dXJuICQuY2FsbCh7Jyc6IHRtcH0sICcnLCB0bXApO1xuICAgIH0sXG5cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICBmb3IgKHZhclxuICAgICAgICBmaXJzdFJ1bixcbiAgICAgICAga25vd24gPSBuZXcgTWFwLFxuICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICBvdXRwdXQgPSBbXSxcbiAgICAgICAgJCA9IHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciA9PT0gdHlwZW9mIGlucHV0ID9cbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJycgfHwgLTEgPCByZXBsYWNlci5pbmRleE9mKGspKSByZXR1cm4gdjtcbiAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgIChyZXBsYWNlciB8fCBub29wKSxcbiAgICAgICAgaSA9ICtzZXQoa25vd24sIGlucHV0LCAkLmNhbGwoeycnOiB2YWx1ZX0sICcnLCB2YWx1ZSkpLFxuICAgICAgICByZXBsYWNlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoZmlyc3RSdW4pIHtcbiAgICAgICAgICAgIGZpcnN0UnVuID0gIWZpcnN0UnVuO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy8gdGhpcyB3YXMgaW52b2tpbmcgdHdpY2UgZWFjaCByb290IG9iamVjdFxuICAgICAgICAgICAgLy8gcmV0dXJuIGkgPCAxID8gdmFsdWUgOiAkLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhZnRlciA9ICQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhZnRlcikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgaWYgKGFmdGVyID09PSBudWxsKSByZXR1cm4gYWZ0ZXI7XG4gICAgICAgICAgICBjYXNlIHByaW1pdGl2ZTpcbiAgICAgICAgICAgICAgcmV0dXJuIGtub3duLmdldChhZnRlcikgfHwgc2V0KGtub3duLCBpbnB1dCwgYWZ0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGkgPCBpbnB1dC5sZW5ndGg7IGkrK1xuICAgICAgKSB7XG4gICAgICAgIGZpcnN0UnVuID0gdHJ1ZTtcbiAgICAgICAgb3V0cHV0W2ldID0gSlNPTi5zdHJpbmdpZnkoaW5wdXRbaV0sIHJlcGxhY2UsIHNwYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnWycgKyBvdXRwdXQuam9pbignLCcpICsgJ10nO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBGbGF0dGVkO1xuXG4gIGZ1bmN0aW9uIG5vb3Aoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldml2ZShpbnB1dCwgcGFyc2VkLCBvdXRwdXQsICQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3V0cHV0KS5yZWR1Y2UoXG4gICAgICBmdW5jdGlvbiAob3V0cHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3V0cHV0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByaW1pdGl2ZSkge1xuICAgICAgICAgIHZhciB0bXAgPSBpbnB1dFt2YWx1ZV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB0bXAgPT09ICdvYmplY3QnICYmICFwYXJzZWQuaGFzKHRtcCkpIHtcbiAgICAgICAgICAgIHBhcnNlZC5hZGQodG1wKTtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gJC5jYWxsKG91dHB1dCwga2V5LCByZXZpdmUoaW5wdXQsIHBhcnNlZCwgdG1wLCAkKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gJC5jYWxsKG91dHB1dCwga2V5LCB0bXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgb3V0cHV0W2tleV0gPSAkLmNhbGwob3V0cHV0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0sXG4gICAgICBvdXRwdXRcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KGtub3duLCBpbnB1dCwgdmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSBQcmltaXRpdmUoaW5wdXQucHVzaCh2YWx1ZSkgLSAxKTtcbiAgICBrbm93bi5zZXQodmFsdWUsIGluZGV4KTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvLyB0aGUgdHdvIGtpbmRzIG9mIHByaW1pdGl2ZXNcbiAgLy8gIDEuIHRoZSByZWFsIG9uZVxuICAvLyAgMi4gdGhlIHdyYXBwZWQgb25lXG5cbiAgZnVuY3Rpb24gcHJpbWl0aXZlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFByaW1pdGl2ZSA/IFByaW1pdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByaW1pdGl2ZXMoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHByaW1pdGl2ZSA/IG5ldyBQcmltaXRpdmUodmFsdWUpIDogdmFsdWU7XG4gIH1cblxufShTdHJpbmcsICdzdHJpbmcnKSk7XG5leHBvcnQgZGVmYXVsdCBGbGF0dGVkO1xuZXhwb3J0IHZhciBwYXJzZSA9IEZsYXR0ZWQucGFyc2U7XG5leHBvcnQgdmFyIHN0cmluZ2lmeSA9IEZsYXR0ZWQuc3RyaW5naWZ5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/flatted/esm/index.js\n"
          );

          /***/
        },

      /***/ './node_modules/save-svg-as-png/lib/saveSvgAsPng.js':
        /*!**********************************************************!*\
  !*** ./node_modules/save-svg-as-png/lib/saveSvgAsPng.js ***!
  \**********************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            "var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n(function () {\n  var out$ =  true && exports ||  true && {} || this || window;\n  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return out$;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  out$.default = out$;\n\n  var xmlNs = 'http://www.w3.org/2000/xmlns/';\n  var xhtmlNs = 'http://www.w3.org/1999/xhtml';\n  var svgNs = 'http://www.w3.org/2000/svg';\n  var doctype = '<?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [<!ENTITY nbsp \"&#160;\">]>';\n  var urlRegex = /url\\([\"']?(.+?)[\"']?\\)/;\n  var fontFormats = {\n    woff2: 'font/woff2',\n    woff: 'font/woff',\n    otf: 'application/x-font-opentype',\n    ttf: 'application/x-font-ttf',\n    eot: 'application/vnd.ms-fontobject',\n    sfnt: 'application/font-sfnt',\n    svg: 'image/svg+xml'\n  };\n\n  var isElement = function isElement(obj) {\n    return obj instanceof HTMLElement || obj instanceof SVGElement;\n  };\n  var requireDomNode = function requireDomNode(el) {\n    if (!isElement(el)) throw new Error('an HTMLElement or SVGElement is required; got ' + el);\n  };\n  var requireDomNodePromise = function requireDomNodePromise(el) {\n    return new Promise(function (resolve, reject) {\n      if (isElement(el)) resolve(el);else reject(new Error('an HTMLElement or SVGElement is required; got ' + el));\n    });\n  };\n  var isExternal = function isExternal(url) {\n    return url && url.lastIndexOf('http', 0) === 0 && url.lastIndexOf(window.location.host) === -1;\n  };\n\n  var getFontMimeTypeFromUrl = function getFontMimeTypeFromUrl(fontUrl) {\n    var formats = Object.keys(fontFormats).filter(function (extension) {\n      return fontUrl.indexOf('.' + extension) > 0;\n    }).map(function (extension) {\n      return fontFormats[extension];\n    });\n    if (formats) return formats[0];\n    console.error('Unknown font format for ' + fontUrl + '. Fonts may not be working correctly.');\n    return 'application/octet-stream';\n  };\n\n  var arrayBufferToBase64 = function arrayBufferToBase64(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }return window.btoa(binary);\n  };\n\n  var getDimension = function getDimension(el, clone, dim) {\n    var v = el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim] || clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim)) || el.getBoundingClientRect()[dim] || parseInt(clone.style[dim]) || parseInt(window.getComputedStyle(el).getPropertyValue(dim));\n    return typeof v === 'undefined' || v === null || isNaN(parseFloat(v)) ? 0 : v;\n  };\n\n  var getDimensions = function getDimensions(el, clone, width, height) {\n    if (el.tagName === 'svg') return {\n      width: width || getDimension(el, clone, 'width'),\n      height: height || getDimension(el, clone, 'height')\n    };else if (el.getBBox) {\n      var _el$getBBox = el.getBBox(),\n          x = _el$getBBox.x,\n          y = _el$getBBox.y,\n          _width = _el$getBBox.width,\n          _height = _el$getBBox.height;\n\n      return {\n        width: x + _width,\n        height: y + _height\n      };\n    }\n  };\n\n  var reEncode = function reEncode(data) {\n    return decodeURIComponent(encodeURIComponent(data).replace(/%([0-9A-F]{2})/g, function (match, p1) {\n      var c = String.fromCharCode('0x' + p1);\n      return c === '%' ? '%25' : c;\n    }));\n  };\n\n  var uriToBlob = function uriToBlob(uri) {\n    var byteString = window.atob(uri.split(',')[1]);\n    var mimeString = uri.split(',')[0].split(':')[1].split(';')[0];\n    var buffer = new ArrayBuffer(byteString.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < byteString.length; i++) {\n      intArray[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([buffer], { type: mimeString });\n  };\n\n  var query = function query(el, selector) {\n    if (!selector) return;\n    try {\n      return el.querySelector(selector) || el.parentNode && el.parentNode.querySelector(selector);\n    } catch (err) {\n      console.warn('Invalid CSS selector \"' + selector + '\"', err);\n    }\n  };\n\n  var detectCssFont = function detectCssFont(rule, href) {\n    // Match CSS font-face rules to external links.\n    // @font-face {\n    //   src: local('Abel'), url(https://fonts.gstatic.com/s/abel/v6/UzN-iejR1VoXU2Oc-7LsbvesZW2xOQ-xsNqO47m55DA.woff2);\n    // }\n    var match = rule.cssText.match(urlRegex);\n    var url = match && match[1] || '';\n    if (!url || url.match(/^data:/) || url === 'about:blank') return;\n    var fullUrl = url.startsWith('../') ? href + '/../' + url : url.startsWith('./') ? href + '/.' + url : url;\n    return {\n      text: rule.cssText,\n      format: getFontMimeTypeFromUrl(fullUrl),\n      url: fullUrl\n    };\n  };\n\n  var inlineImages = function inlineImages(el) {\n    return Promise.all(Array.from(el.querySelectorAll('image')).map(function (image) {\n      var href = image.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || image.getAttribute('href');\n      if (!href) return Promise.resolve(null);\n      if (isExternal(href)) {\n        href += (href.indexOf('?') === -1 ? '?' : '&') + 't=' + new Date().valueOf();\n      }\n      return new Promise(function (resolve, reject) {\n        var canvas = document.createElement('canvas');\n        var img = new Image();\n        img.crossOrigin = 'anonymous';\n        img.src = href;\n        img.onerror = function () {\n          return reject(new Error('Could not load ' + href));\n        };\n        img.onload = function () {\n          canvas.width = img.width;\n          canvas.height = img.height;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', canvas.toDataURL('image/png'));\n          resolve(true);\n        };\n      });\n    }));\n  };\n\n  var cachedFonts = {};\n  var inlineFonts = function inlineFonts(fonts) {\n    return Promise.all(fonts.map(function (font) {\n      return new Promise(function (resolve, reject) {\n        if (cachedFonts[font.url]) return resolve(cachedFonts[font.url]);\n\n        var req = new XMLHttpRequest();\n        req.addEventListener('load', function () {\n          // TODO: it may also be worth it to wait until fonts are fully loaded before\n          // attempting to rasterize them. (e.g. use https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet)\n          var fontInBase64 = arrayBufferToBase64(req.response);\n          var fontUri = font.text.replace(urlRegex, 'url(\"data:' + font.format + ';base64,' + fontInBase64 + '\")') + '\\n';\n          cachedFonts[font.url] = fontUri;\n          resolve(fontUri);\n        });\n        req.addEventListener('error', function (e) {\n          console.warn('Failed to load font from: ' + font.url, e);\n          cachedFonts[font.url] = null;\n          resolve(null);\n        });\n        req.addEventListener('abort', function (e) {\n          console.warn('Aborted loading font from: ' + font.url, e);\n          resolve(null);\n        });\n        req.open('GET', font.url);\n        req.responseType = 'arraybuffer';\n        req.send();\n      });\n    })).then(function (fontCss) {\n      return fontCss.filter(function (x) {\n        return x;\n      }).join('');\n    });\n  };\n\n  var cachedRules = null;\n  var styleSheetRules = function styleSheetRules() {\n    if (cachedRules) return cachedRules;\n    return cachedRules = Array.from(document.styleSheets).map(function (sheet) {\n      try {\n        return { rules: sheet.cssRules, href: sheet.href };\n      } catch (e) {\n        console.warn('Stylesheet could not be loaded: ' + sheet.href, e);\n        return {};\n      }\n    });\n  };\n\n  var inlineCss = function inlineCss(el, options) {\n    var _ref = options || {},\n        selectorRemap = _ref.selectorRemap,\n        modifyStyle = _ref.modifyStyle,\n        modifyCss = _ref.modifyCss,\n        fonts = _ref.fonts;\n\n    var generateCss = modifyCss || function (selector, properties) {\n      var sel = selectorRemap ? selectorRemap(selector) : selector;\n      var props = modifyStyle ? modifyStyle(properties) : properties;\n      return sel + '{' + props + '}\\n';\n    };\n    var css = [];\n    var detectFonts = typeof fonts === 'undefined';\n    var fontList = fonts || [];\n    styleSheetRules().forEach(function (_ref2) {\n      var rules = _ref2.rules,\n          href = _ref2.href;\n\n      if (!rules) return;\n      Array.from(rules).forEach(function (rule) {\n        if (typeof rule.style != 'undefined') {\n          if (query(el, rule.selectorText)) css.push(generateCss(rule.selectorText, rule.style.cssText));else if (detectFonts && rule.cssText.match(/^@font-face/)) {\n            var font = detectCssFont(rule, href);\n            if (font) fontList.push(font);\n          } else css.push(rule.cssText);\n        }\n      });\n    });\n\n    return inlineFonts(fontList).then(function (fontCss) {\n      return css.join('\\n') + fontCss;\n    });\n  };\n\n  var downloadOptions = function downloadOptions() {\n    if (!navigator.msSaveOrOpenBlob && !('download' in document.createElement('a'))) {\n      return { popup: window.open() };\n    }\n  };\n\n  out$.prepareSvg = function (el, options, done) {\n    requireDomNode(el);\n\n    var _ref3 = options || {},\n        _ref3$left = _ref3.left,\n        left = _ref3$left === undefined ? 0 : _ref3$left,\n        _ref3$top = _ref3.top,\n        top = _ref3$top === undefined ? 0 : _ref3$top,\n        w = _ref3.width,\n        h = _ref3.height,\n        _ref3$scale = _ref3.scale,\n        scale = _ref3$scale === undefined ? 1 : _ref3$scale,\n        _ref3$responsive = _ref3.responsive,\n        responsive = _ref3$responsive === undefined ? false : _ref3$responsive;\n\n    return inlineImages(el).then(function () {\n      var clone = el.cloneNode(true);\n      clone.style.backgroundColor = (options || {}).backgroundColor || el.style.backgroundColor;\n\n      var _getDimensions = getDimensions(el, clone, w, h),\n          width = _getDimensions.width,\n          height = _getDimensions.height;\n\n      if (el.tagName !== 'svg') {\n        if (el.getBBox) {\n          if (clone.getAttribute('transform') != null) {\n            clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\\(.*?\\)/, ''));\n          }\n          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n          svg.appendChild(clone);\n          clone = svg;\n        } else {\n          console.error('Attempted to render non-SVG element', el);\n          return;\n        }\n      }\n\n      clone.setAttribute('version', '1.1');\n      clone.setAttribute('viewBox', [left, top, width, height].join(' '));\n      if (!clone.getAttribute('xmlns')) clone.setAttributeNS(xmlNs, 'xmlns', svgNs);\n      if (!clone.getAttribute('xmlns:xlink')) clone.setAttributeNS(xmlNs, 'xmlns:xlink', 'http://www.w3.org/1999/xlink');\n\n      if (responsive) {\n        clone.removeAttribute('width');\n        clone.removeAttribute('height');\n        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n      } else {\n        clone.setAttribute('width', width * scale);\n        clone.setAttribute('height', height * scale);\n      }\n\n      Array.from(clone.querySelectorAll('foreignObject > *')).forEach(function (foreignObject) {\n        foreignObject.setAttributeNS(xmlNs, 'xmlns', foreignObject.tagName === 'svg' ? svgNs : xhtmlNs);\n      });\n\n      return inlineCss(el, options).then(function (css) {\n        var style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.innerHTML = '<![CDATA[\\n' + css + '\\n]]>';\n\n        var defs = document.createElement('defs');\n        defs.appendChild(style);\n        clone.insertBefore(defs, clone.firstChild);\n\n        var outer = document.createElement('div');\n        outer.appendChild(clone);\n        var src = outer.innerHTML.replace(/NS\\d+:href/gi, 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href');\n\n        if (typeof done === 'function') done(src, width, height);else return { src: src, width: width, height: height };\n      });\n    });\n  };\n\n  out$.svgAsDataUri = function (el, options, done) {\n    requireDomNode(el);\n    return out$.prepareSvg(el, options).then(function (_ref4) {\n      var src = _ref4.src,\n          width = _ref4.width,\n          height = _ref4.height;\n\n      var svgXml = 'data:image/svg+xml;base64,' + window.btoa(reEncode(doctype + src));\n      if (typeof done === 'function') {\n        done(svgXml, width, height);\n      }\n      return svgXml;\n    });\n  };\n\n  out$.svgAsPngUri = function (el, options, done) {\n    requireDomNode(el);\n\n    var _ref5 = options || {},\n        _ref5$encoderType = _ref5.encoderType,\n        encoderType = _ref5$encoderType === undefined ? 'image/png' : _ref5$encoderType,\n        _ref5$encoderOptions = _ref5.encoderOptions,\n        encoderOptions = _ref5$encoderOptions === undefined ? 0.8 : _ref5$encoderOptions,\n        canvg = _ref5.canvg;\n\n    var convertToPng = function convertToPng(_ref6) {\n      var src = _ref6.src,\n          width = _ref6.width,\n          height = _ref6.height;\n\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      var pixelRatio = window.devicePixelRatio || 1;\n\n      canvas.width = width * pixelRatio;\n      canvas.height = height * pixelRatio;\n      canvas.style.width = canvas.width + 'px';\n      canvas.style.height = canvas.height + 'px';\n      context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n      if (canvg) canvg(canvas, src);else context.drawImage(src, 0, 0);\n\n      var png = void 0;\n      try {\n        png = canvas.toDataURL(encoderType, encoderOptions);\n      } catch (e) {\n        if (typeof SecurityError !== 'undefined' && e instanceof SecurityError || e.name === 'SecurityError') {\n          console.error('Rendered SVG images cannot be downloaded in this browser.');\n          return;\n        } else throw e;\n      }\n      if (typeof done === 'function') done(png, canvas.width, canvas.height);\n      return Promise.resolve(png);\n    };\n\n    if (canvg) return out$.prepareSvg(el, options).then(convertToPng);else return out$.svgAsDataUri(el, options).then(function (uri) {\n      return new Promise(function (resolve, reject) {\n        var image = new Image();\n        image.onload = function () {\n          return resolve(convertToPng({\n            src: image,\n            width: image.width,\n            height: image.height\n          }));\n        };\n        image.onerror = function () {\n          reject('There was an error loading the data URI as an image on the following SVG\\n' + window.atob(uri.slice(26)) + 'Open the following link to see browser\\'s diagnosis\\n' + uri);\n        };\n        image.src = uri;\n      });\n    });\n  };\n\n  out$.download = function (name, uri, options) {\n    if (navigator.msSaveOrOpenBlob) navigator.msSaveOrOpenBlob(uriToBlob(uri), name);else {\n      var saveLink = document.createElement('a');\n      if ('download' in saveLink) {\n        saveLink.download = name;\n        saveLink.style.display = 'none';\n        document.body.appendChild(saveLink);\n        try {\n          var blob = uriToBlob(uri);\n          var url = URL.createObjectURL(blob);\n          saveLink.href = url;\n          saveLink.onclick = function () {\n            return requestAnimationFrame(function () {\n              return URL.revokeObjectURL(url);\n            });\n          };\n        } catch (e) {\n          console.error(e);\n          console.warn('Error while getting object URL. Falling back to string URL.');\n          saveLink.href = uri;\n        }\n        saveLink.click();\n        document.body.removeChild(saveLink);\n      } else if (options && options.popup) {\n        options.popup.document.title = name;\n        options.popup.location.replace(uri);\n      }\n    }\n  };\n\n  out$.saveSvg = function (el, name, options) {\n    var downloadOpts = downloadOptions(); // don't inline, can't be async\n    return requireDomNodePromise(el).then(function (el) {\n      return out$.svgAsDataUri(el, options || {});\n    }).then(function (uri) {\n      return out$.download(name, uri, downloadOpts);\n    });\n  };\n\n  out$.saveSvgAsPng = function (el, name, options) {\n    var downloadOpts = downloadOptions(); // don't inline, can't be async\n    return requireDomNodePromise(el).then(function (el) {\n      return out$.svgAsPngUri(el, options || {});\n    }).then(function (uri) {\n      return out$.download(name, uri, downloadOpts);\n    });\n  };\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvc2F2ZS1zdmctYXMtcG5nL2xpYi9zYXZlU3ZnQXNQbmcuanM/YmMwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnRUFBYTs7QUFFYjtBQUNBLGFBQWEsS0FBNkIsZUFBZSxLQUE0QixNQUFNO0FBQzNGLE1BQU0sSUFBNkIsRUFBRSxpQ0FBMEIsRUFBRSxtQ0FBRTtBQUNuRTtBQUNBLEdBQUc7QUFBQSxvR0FBQztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhLQUE4SztBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0VBQWdFO0FBQ3JHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxFQUFFO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUUsYUFBYTtBQUM5RSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGdEQUFnRDtBQUNoRCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSwrQ0FBK0M7QUFDL0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zYXZlLXN2Zy1hcy1wbmcvbGliL3NhdmVTdmdBc1BuZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYge30gfHwgdGhpcyB8fCB3aW5kb3c7XG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJykgZGVmaW5lKCdzYXZlLXN2Zy1hcy1wbmcnLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvdXQkO1xuICB9KTtcbiAgb3V0JC5kZWZhdWx0ID0gb3V0JDtcblxuICB2YXIgeG1sTnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuICB2YXIgeGh0bWxOcyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgdmFyIHN2Z05zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIGRvY3R5cGUgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIHN0YW5kYWxvbmU9XCJub1wiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIiBbPCFFTlRJVFkgbmJzcCBcIiYjMTYwO1wiPl0+JztcbiAgdmFyIHVybFJlZ2V4ID0gL3VybFxcKFtcIiddPyguKz8pW1wiJ10/XFwpLztcbiAgdmFyIGZvbnRGb3JtYXRzID0ge1xuICAgIHdvZmYyOiAnZm9udC93b2ZmMicsXG4gICAgd29mZjogJ2ZvbnQvd29mZicsXG4gICAgb3RmOiAnYXBwbGljYXRpb24veC1mb250LW9wZW50eXBlJyxcbiAgICB0dGY6ICdhcHBsaWNhdGlvbi94LWZvbnQtdHRmJyxcbiAgICBlb3Q6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgc2ZudDogJ2FwcGxpY2F0aW9uL2ZvbnQtc2ZudCcsXG4gICAgc3ZnOiAnaW1hZ2Uvc3ZnK3htbCdcbiAgfTtcblxuICB2YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBvYmogaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICB9O1xuICB2YXIgcmVxdWlyZURvbU5vZGUgPSBmdW5jdGlvbiByZXF1aXJlRG9tTm9kZShlbCkge1xuICAgIGlmICghaXNFbGVtZW50KGVsKSkgdGhyb3cgbmV3IEVycm9yKCdhbiBIVE1MRWxlbWVudCBvciBTVkdFbGVtZW50IGlzIHJlcXVpcmVkOyBnb3QgJyArIGVsKTtcbiAgfTtcbiAgdmFyIHJlcXVpcmVEb21Ob2RlUHJvbWlzZSA9IGZ1bmN0aW9uIHJlcXVpcmVEb21Ob2RlUHJvbWlzZShlbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsKSkgcmVzb2x2ZShlbCk7ZWxzZSByZWplY3QobmV3IEVycm9yKCdhbiBIVE1MRWxlbWVudCBvciBTVkdFbGVtZW50IGlzIHJlcXVpcmVkOyBnb3QgJyArIGVsKSk7XG4gICAgfSk7XG4gIH07XG4gIHZhciBpc0V4dGVybmFsID0gZnVuY3Rpb24gaXNFeHRlcm5hbCh1cmwpIHtcbiAgICByZXR1cm4gdXJsICYmIHVybC5sYXN0SW5kZXhPZignaHR0cCcsIDApID09PSAwICYmIHVybC5sYXN0SW5kZXhPZih3aW5kb3cubG9jYXRpb24uaG9zdCkgPT09IC0xO1xuICB9O1xuXG4gIHZhciBnZXRGb250TWltZVR5cGVGcm9tVXJsID0gZnVuY3Rpb24gZ2V0Rm9udE1pbWVUeXBlRnJvbVVybChmb250VXJsKSB7XG4gICAgdmFyIGZvcm1hdHMgPSBPYmplY3Qua2V5cyhmb250Rm9ybWF0cykuZmlsdGVyKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBmb250VXJsLmluZGV4T2YoJy4nICsgZXh0ZW5zaW9uKSA+IDA7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBmb250Rm9ybWF0c1tleHRlbnNpb25dO1xuICAgIH0pO1xuICAgIGlmIChmb3JtYXRzKSByZXR1cm4gZm9ybWF0c1swXTtcbiAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIGZvbnQgZm9ybWF0IGZvciAnICsgZm9udFVybCArICcuIEZvbnRzIG1heSBub3QgYmUgd29ya2luZyBjb3JyZWN0bHkuJyk7XG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICB9O1xuXG4gIHZhciBhcnJheUJ1ZmZlclRvQmFzZTY0ID0gZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICB2YXIgYmluYXJ5ID0gJyc7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1yZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbiAgfTtcblxuICB2YXIgZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uKGVsLCBjbG9uZSwgZGltKSB7XG4gICAgdmFyIHYgPSBlbC52aWV3Qm94ICYmIGVsLnZpZXdCb3guYmFzZVZhbCAmJiBlbC52aWV3Qm94LmJhc2VWYWxbZGltXSB8fCBjbG9uZS5nZXRBdHRyaWJ1dGUoZGltKSAhPT0gbnVsbCAmJiAhY2xvbmUuZ2V0QXR0cmlidXRlKGRpbSkubWF0Y2goLyUkLykgJiYgcGFyc2VJbnQoY2xvbmUuZ2V0QXR0cmlidXRlKGRpbSkpIHx8IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbV0gfHwgcGFyc2VJbnQoY2xvbmUuc3R5bGVbZGltXSkgfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoZGltKSk7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyB8fCB2ID09PSBudWxsIHx8IGlzTmFOKHBhcnNlRmxvYXQodikpID8gMCA6IHY7XG4gIH07XG5cbiAgdmFyIGdldERpbWVuc2lvbnMgPSBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsLCBjbG9uZSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmIChlbC50YWdOYW1lID09PSAnc3ZnJykgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCB8fCBnZXREaW1lbnNpb24oZWwsIGNsb25lLCAnd2lkdGgnKSxcbiAgICAgIGhlaWdodDogaGVpZ2h0IHx8IGdldERpbWVuc2lvbihlbCwgY2xvbmUsICdoZWlnaHQnKVxuICAgIH07ZWxzZSBpZiAoZWwuZ2V0QkJveCkge1xuICAgICAgdmFyIF9lbCRnZXRCQm94ID0gZWwuZ2V0QkJveCgpLFxuICAgICAgICAgIHggPSBfZWwkZ2V0QkJveC54LFxuICAgICAgICAgIHkgPSBfZWwkZ2V0QkJveC55LFxuICAgICAgICAgIF93aWR0aCA9IF9lbCRnZXRCQm94LndpZHRoLFxuICAgICAgICAgIF9oZWlnaHQgPSBfZWwkZ2V0QkJveC5oZWlnaHQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB4ICsgX3dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHkgKyBfaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVFbmNvZGUgPSBmdW5jdGlvbiByZUVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBwMSkge1xuICAgICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCcweCcgKyBwMSk7XG4gICAgICByZXR1cm4gYyA9PT0gJyUnID8gJyUyNScgOiBjO1xuICAgIH0pKTtcbiAgfTtcblxuICB2YXIgdXJpVG9CbG9iID0gZnVuY3Rpb24gdXJpVG9CbG9iKHVyaSkge1xuICAgIHZhciBieXRlU3RyaW5nID0gd2luZG93LmF0b2IodXJpLnNwbGl0KCcsJylbMV0pO1xuICAgIHZhciBtaW1lU3RyaW5nID0gdXJpLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRBcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6IG1pbWVTdHJpbmcgfSk7XG4gIH07XG5cbiAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgfHwgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIENTUyBzZWxlY3RvciBcIicgKyBzZWxlY3RvciArICdcIicsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZXRlY3RDc3NGb250ID0gZnVuY3Rpb24gZGV0ZWN0Q3NzRm9udChydWxlLCBocmVmKSB7XG4gICAgLy8gTWF0Y2ggQ1NTIGZvbnQtZmFjZSBydWxlcyB0byBleHRlcm5hbCBsaW5rcy5cbiAgICAvLyBAZm9udC1mYWNlIHtcbiAgICAvLyAgIHNyYzogbG9jYWwoJ0FiZWwnKSwgdXJsKGh0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb20vcy9hYmVsL3Y2L1V6Ti1pZWpSMVZvWFUyT2MtN0xzYnZlc1pXMnhPUS14c05xTzQ3bTU1REEud29mZjIpO1xuICAgIC8vIH1cbiAgICB2YXIgbWF0Y2ggPSBydWxlLmNzc1RleHQubWF0Y2godXJsUmVnZXgpO1xuICAgIHZhciB1cmwgPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICBpZiAoIXVybCB8fCB1cmwubWF0Y2goL15kYXRhOi8pIHx8IHVybCA9PT0gJ2Fib3V0OmJsYW5rJykgcmV0dXJuO1xuICAgIHZhciBmdWxsVXJsID0gdXJsLnN0YXJ0c1dpdGgoJy4uLycpID8gaHJlZiArICcvLi4vJyArIHVybCA6IHVybC5zdGFydHNXaXRoKCcuLycpID8gaHJlZiArICcvLicgKyB1cmwgOiB1cmw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHJ1bGUuY3NzVGV4dCxcbiAgICAgIGZvcm1hdDogZ2V0Rm9udE1pbWVUeXBlRnJvbVVybChmdWxsVXJsKSxcbiAgICAgIHVybDogZnVsbFVybFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGlubGluZUltYWdlcyA9IGZ1bmN0aW9uIGlubGluZUltYWdlcyhlbCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltYWdlJykpLm1hcChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHZhciBocmVmID0gaW1hZ2UuZ2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicpIHx8IGltYWdlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgaWYgKCFocmVmKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgaWYgKGlzRXh0ZXJuYWwoaHJlZikpIHtcbiAgICAgICAgaHJlZiArPSAoaHJlZi5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArICd0PScgKyBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgaW1nLnNyYyA9IGhyZWY7XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgaHJlZikpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH07XG5cbiAgdmFyIGNhY2hlZEZvbnRzID0ge307XG4gIHZhciBpbmxpbmVGb250cyA9IGZ1bmN0aW9uIGlubGluZUZvbnRzKGZvbnRzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZvbnRzLm1hcChmdW5jdGlvbiAoZm9udCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKGNhY2hlZEZvbnRzW2ZvbnQudXJsXSkgcmV0dXJuIHJlc29sdmUoY2FjaGVkRm9udHNbZm9udC51cmxdKTtcblxuICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRPRE86IGl0IG1heSBhbHNvIGJlIHdvcnRoIGl0IHRvIHdhaXQgdW50aWwgZm9udHMgYXJlIGZ1bGx5IGxvYWRlZCBiZWZvcmVcbiAgICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHJhc3Rlcml6ZSB0aGVtLiAoZS5nLiB1c2UgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZvbnRGYWNlU2V0KVxuICAgICAgICAgIHZhciBmb250SW5CYXNlNjQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGZvbnRVcmkgPSBmb250LnRleHQucmVwbGFjZSh1cmxSZWdleCwgJ3VybChcImRhdGE6JyArIGZvbnQuZm9ybWF0ICsgJztiYXNlNjQsJyArIGZvbnRJbkJhc2U2NCArICdcIiknKSArICdcXG4nO1xuICAgICAgICAgIGNhY2hlZEZvbnRzW2ZvbnQudXJsXSA9IGZvbnRVcmk7XG4gICAgICAgICAgcmVzb2x2ZShmb250VXJpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBmb250IGZyb206ICcgKyBmb250LnVybCwgZSk7XG4gICAgICAgICAgY2FjaGVkRm9udHNbZm9udC51cmxdID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Fib3J0ZWQgbG9hZGluZyBmb250IGZyb206ICcgKyBmb250LnVybCwgZSk7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vcGVuKCdHRVQnLCBmb250LnVybCk7XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgfSk7XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKGZvbnRDc3MpIHtcbiAgICAgIHJldHVybiBmb250Q3NzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjYWNoZWRSdWxlcyA9IG51bGw7XG4gIHZhciBzdHlsZVNoZWV0UnVsZXMgPSBmdW5jdGlvbiBzdHlsZVNoZWV0UnVsZXMoKSB7XG4gICAgaWYgKGNhY2hlZFJ1bGVzKSByZXR1cm4gY2FjaGVkUnVsZXM7XG4gICAgcmV0dXJuIGNhY2hlZFJ1bGVzID0gQXJyYXkuZnJvbShkb2N1bWVudC5zdHlsZVNoZWV0cykubWFwKGZ1bmN0aW9uIChzaGVldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgcnVsZXM6IHNoZWV0LmNzc1J1bGVzLCBocmVmOiBzaGVldC5ocmVmIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU3R5bGVzaGVldCBjb3VsZCBub3QgYmUgbG9hZGVkOiAnICsgc2hlZXQuaHJlZiwgZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgaW5saW5lQ3NzID0gZnVuY3Rpb24gaW5saW5lQ3NzKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBzZWxlY3RvclJlbWFwID0gX3JlZi5zZWxlY3RvclJlbWFwLFxuICAgICAgICBtb2RpZnlTdHlsZSA9IF9yZWYubW9kaWZ5U3R5bGUsXG4gICAgICAgIG1vZGlmeUNzcyA9IF9yZWYubW9kaWZ5Q3NzLFxuICAgICAgICBmb250cyA9IF9yZWYuZm9udHM7XG5cbiAgICB2YXIgZ2VuZXJhdGVDc3MgPSBtb2RpZnlDc3MgfHwgZnVuY3Rpb24gKHNlbGVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgc2VsID0gc2VsZWN0b3JSZW1hcCA/IHNlbGVjdG9yUmVtYXAoc2VsZWN0b3IpIDogc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBtb2RpZnlTdHlsZSA/IG1vZGlmeVN0eWxlKHByb3BlcnRpZXMpIDogcHJvcGVydGllcztcbiAgICAgIHJldHVybiBzZWwgKyAneycgKyBwcm9wcyArICd9XFxuJztcbiAgICB9O1xuICAgIHZhciBjc3MgPSBbXTtcbiAgICB2YXIgZGV0ZWN0Rm9udHMgPSB0eXBlb2YgZm9udHMgPT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBmb250TGlzdCA9IGZvbnRzIHx8IFtdO1xuICAgIHN0eWxlU2hlZXRSdWxlcygpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgcnVsZXMgPSBfcmVmMi5ydWxlcyxcbiAgICAgICAgICBocmVmID0gX3JlZjIuaHJlZjtcblxuICAgICAgaWYgKCFydWxlcykgcmV0dXJuO1xuICAgICAgQXJyYXkuZnJvbShydWxlcykuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUuc3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAocXVlcnkoZWwsIHJ1bGUuc2VsZWN0b3JUZXh0KSkgY3NzLnB1c2goZ2VuZXJhdGVDc3MocnVsZS5zZWxlY3RvclRleHQsIHJ1bGUuc3R5bGUuY3NzVGV4dCkpO2Vsc2UgaWYgKGRldGVjdEZvbnRzICYmIHJ1bGUuY3NzVGV4dC5tYXRjaCgvXkBmb250LWZhY2UvKSkge1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBkZXRlY3RDc3NGb250KHJ1bGUsIGhyZWYpO1xuICAgICAgICAgICAgaWYgKGZvbnQpIGZvbnRMaXN0LnB1c2goZm9udCk7XG4gICAgICAgICAgfSBlbHNlIGNzcy5wdXNoKHJ1bGUuY3NzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlubGluZUZvbnRzKGZvbnRMaXN0KS50aGVuKGZ1bmN0aW9uIChmb250Q3NzKSB7XG4gICAgICByZXR1cm4gY3NzLmpvaW4oJ1xcbicpICsgZm9udENzcztcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZG93bmxvYWRPcHRpb25zID0gZnVuY3Rpb24gZG93bmxvYWRPcHRpb25zKCkge1xuICAgIGlmICghbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IgJiYgISgnZG93bmxvYWQnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSkpIHtcbiAgICAgIHJldHVybiB7IHBvcHVwOiB3aW5kb3cub3BlbigpIH07XG4gICAgfVxuICB9O1xuXG4gIG91dCQucHJlcGFyZVN2ZyA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgZG9uZSkge1xuICAgIHJlcXVpcmVEb21Ob2RlKGVsKTtcblxuICAgIHZhciBfcmVmMyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgIF9yZWYzJGxlZnQgPSBfcmVmMy5sZWZ0LFxuICAgICAgICBsZWZ0ID0gX3JlZjMkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYzJGxlZnQsXG4gICAgICAgIF9yZWYzJHRvcCA9IF9yZWYzLnRvcCxcbiAgICAgICAgdG9wID0gX3JlZjMkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkdG9wLFxuICAgICAgICB3ID0gX3JlZjMud2lkdGgsXG4gICAgICAgIGggPSBfcmVmMy5oZWlnaHQsXG4gICAgICAgIF9yZWYzJHNjYWxlID0gX3JlZjMuc2NhbGUsXG4gICAgICAgIHNjYWxlID0gX3JlZjMkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmMyRzY2FsZSxcbiAgICAgICAgX3JlZjMkcmVzcG9uc2l2ZSA9IF9yZWYzLnJlc3BvbnNpdmUsXG4gICAgICAgIHJlc3BvbnNpdmUgPSBfcmVmMyRyZXNwb25zaXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYzJHJlc3BvbnNpdmU7XG5cbiAgICByZXR1cm4gaW5saW5lSW1hZ2VzKGVsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGNsb25lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IChvcHRpb25zIHx8IHt9KS5iYWNrZ3JvdW5kQ29sb3IgfHwgZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICB2YXIgX2dldERpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKGVsLCBjbG9uZSwgdywgaCksXG4gICAgICAgICAgd2lkdGggPSBfZ2V0RGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0RGltZW5zaW9ucy5oZWlnaHQ7XG5cbiAgICAgIGlmIChlbC50YWdOYW1lICE9PSAnc3ZnJykge1xuICAgICAgICBpZiAoZWwuZ2V0QkJveCkge1xuICAgICAgICAgIGlmIChjbG9uZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgY2xvbmUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKC90cmFuc2xhdGVcXCguKj9cXCkvLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgIGNsb25lID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byByZW5kZXIgbm9uLVNWRyBlbGVtZW50JywgZWwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCAnMS4xJyk7XG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0XS5qb2luKCcgJykpO1xuICAgICAgaWYgKCFjbG9uZS5nZXRBdHRyaWJ1dGUoJ3htbG5zJykpIGNsb25lLnNldEF0dHJpYnV0ZU5TKHhtbE5zLCAneG1sbnMnLCBzdmdOcyk7XG4gICAgICBpZiAoIWNsb25lLmdldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnKSkgY2xvbmUuc2V0QXR0cmlidXRlTlMoeG1sTnMsICd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG5cbiAgICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICAgIGNsb25lLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgY2xvbmUucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaW5ZTWluIG1lZXQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCAqIHNjYWxlKTtcbiAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQgKiBzY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIEFycmF5LmZyb20oY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnZm9yZWlnbk9iamVjdCA+IConKSkuZm9yRWFjaChmdW5jdGlvbiAoZm9yZWlnbk9iamVjdCkge1xuICAgICAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKHhtbE5zLCAneG1sbnMnLCBmb3JlaWduT2JqZWN0LnRhZ05hbWUgPT09ICdzdmcnID8gc3ZnTnMgOiB4aHRtbE5zKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaW5saW5lQ3NzKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChjc3MpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgIHN0eWxlLmlubmVySFRNTCA9ICc8IVtDREFUQVtcXG4nICsgY3NzICsgJ1xcbl1dPic7XG5cbiAgICAgICAgdmFyIGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkZWZzJyk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICBjbG9uZS5pbnNlcnRCZWZvcmUoZGVmcywgY2xvbmUuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG91dGVyLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgdmFyIHNyYyA9IG91dGVyLmlubmVySFRNTC5yZXBsYWNlKC9OU1xcZCs6aHJlZi9naSwgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhsaW5rOmhyZWYnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGRvbmUgPT09ICdmdW5jdGlvbicpIGRvbmUoc3JjLCB3aWR0aCwgaGVpZ2h0KTtlbHNlIHJldHVybiB7IHNyYzogc3JjLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBvdXQkLnN2Z0FzRGF0YVVyaSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgZG9uZSkge1xuICAgIHJlcXVpcmVEb21Ob2RlKGVsKTtcbiAgICByZXR1cm4gb3V0JC5wcmVwYXJlU3ZnKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgdmFyIHNyYyA9IF9yZWY0LnNyYyxcbiAgICAgICAgICB3aWR0aCA9IF9yZWY0LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWY0LmhlaWdodDtcblxuICAgICAgdmFyIHN2Z1htbCA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCcgKyB3aW5kb3cuYnRvYShyZUVuY29kZShkb2N0eXBlICsgc3JjKSk7XG4gICAgICBpZiAodHlwZW9mIGRvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9uZShzdmdYbWwsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1htbDtcbiAgICB9KTtcbiAgfTtcblxuICBvdXQkLnN2Z0FzUG5nVXJpID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zLCBkb25lKSB7XG4gICAgcmVxdWlyZURvbU5vZGUoZWwpO1xuXG4gICAgdmFyIF9yZWY1ID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgX3JlZjUkZW5jb2RlclR5cGUgPSBfcmVmNS5lbmNvZGVyVHlwZSxcbiAgICAgICAgZW5jb2RlclR5cGUgPSBfcmVmNSRlbmNvZGVyVHlwZSA9PT0gdW5kZWZpbmVkID8gJ2ltYWdlL3BuZycgOiBfcmVmNSRlbmNvZGVyVHlwZSxcbiAgICAgICAgX3JlZjUkZW5jb2Rlck9wdGlvbnMgPSBfcmVmNS5lbmNvZGVyT3B0aW9ucyxcbiAgICAgICAgZW5jb2Rlck9wdGlvbnMgPSBfcmVmNSRlbmNvZGVyT3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gMC44IDogX3JlZjUkZW5jb2Rlck9wdGlvbnMsXG4gICAgICAgIGNhbnZnID0gX3JlZjUuY2Fudmc7XG5cbiAgICB2YXIgY29udmVydFRvUG5nID0gZnVuY3Rpb24gY29udmVydFRvUG5nKF9yZWY2KSB7XG4gICAgICB2YXIgc3JjID0gX3JlZjYuc3JjLFxuICAgICAgICAgIHdpZHRoID0gX3JlZjYud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0O1xuXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCArICdweCc7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgaWYgKGNhbnZnKSBjYW52ZyhjYW52YXMsIHNyYyk7ZWxzZSBjb250ZXh0LmRyYXdJbWFnZShzcmMsIDAsIDApO1xuXG4gICAgICB2YXIgcG5nID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcG5nID0gY2FudmFzLnRvRGF0YVVSTChlbmNvZGVyVHlwZSwgZW5jb2Rlck9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIFNlY3VyaXR5RXJyb3IgIT09ICd1bmRlZmluZWQnICYmIGUgaW5zdGFuY2VvZiBTZWN1cml0eUVycm9yIHx8IGUubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUmVuZGVyZWQgU1ZHIGltYWdlcyBjYW5ub3QgYmUgZG93bmxvYWRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZG9uZSA9PT0gJ2Z1bmN0aW9uJykgZG9uZShwbmcsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBuZyk7XG4gICAgfTtcblxuICAgIGlmIChjYW52ZykgcmV0dXJuIG91dCQucHJlcGFyZVN2ZyhlbCwgb3B0aW9ucykudGhlbihjb252ZXJ0VG9QbmcpO2Vsc2UgcmV0dXJuIG91dCQuc3ZnQXNEYXRhVXJpKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29udmVydFRvUG5nKHtcbiAgICAgICAgICAgIHNyYzogaW1hZ2UsXG4gICAgICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGltYWdlLmhlaWdodFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoJ1RoZXJlIHdhcyBhbiBlcnJvciBsb2FkaW5nIHRoZSBkYXRhIFVSSSBhcyBhbiBpbWFnZSBvbiB0aGUgZm9sbG93aW5nIFNWR1xcbicgKyB3aW5kb3cuYXRvYih1cmkuc2xpY2UoMjYpKSArICdPcGVuIHRoZSBmb2xsb3dpbmcgbGluayB0byBzZWUgYnJvd3NlclxcJ3MgZGlhZ25vc2lzXFxuJyArIHVyaSk7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLnNyYyA9IHVyaTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIG91dCQuZG93bmxvYWQgPSBmdW5jdGlvbiAobmFtZSwgdXJpLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYih1cmlUb0Jsb2IodXJpKSwgbmFtZSk7ZWxzZSB7XG4gICAgICB2YXIgc2F2ZUxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBpZiAoJ2Rvd25sb2FkJyBpbiBzYXZlTGluaykge1xuICAgICAgICBzYXZlTGluay5kb3dubG9hZCA9IG5hbWU7XG4gICAgICAgIHNhdmVMaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2F2ZUxpbmspO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBibG9iID0gdXJpVG9CbG9iKHVyaSk7XG4gICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgc2F2ZUxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgICBzYXZlTGluay5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHdoaWxlIGdldHRpbmcgb2JqZWN0IFVSTC4gRmFsbGluZyBiYWNrIHRvIHN0cmluZyBVUkwuJyk7XG4gICAgICAgICAgc2F2ZUxpbmsuaHJlZiA9IHVyaTtcbiAgICAgICAgfVxuICAgICAgICBzYXZlTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNhdmVMaW5rKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBvcHVwKSB7XG4gICAgICAgIG9wdGlvbnMucG9wdXAuZG9jdW1lbnQudGl0bGUgPSBuYW1lO1xuICAgICAgICBvcHRpb25zLnBvcHVwLmxvY2F0aW9uLnJlcGxhY2UodXJpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb3V0JC5zYXZlU3ZnID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvd25sb2FkT3B0cyA9IGRvd25sb2FkT3B0aW9ucygpOyAvLyBkb24ndCBpbmxpbmUsIGNhbid0IGJlIGFzeW5jXG4gICAgcmV0dXJuIHJlcXVpcmVEb21Ob2RlUHJvbWlzZShlbCkudGhlbihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBvdXQkLnN2Z0FzRGF0YVVyaShlbCwgb3B0aW9ucyB8fCB7fSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodXJpKSB7XG4gICAgICByZXR1cm4gb3V0JC5kb3dubG9hZChuYW1lLCB1cmksIGRvd25sb2FkT3B0cyk7XG4gICAgfSk7XG4gIH07XG5cbiAgb3V0JC5zYXZlU3ZnQXNQbmcgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG93bmxvYWRPcHRzID0gZG93bmxvYWRPcHRpb25zKCk7IC8vIGRvbid0IGlubGluZSwgY2FuJ3QgYmUgYXN5bmNcbiAgICByZXR1cm4gcmVxdWlyZURvbU5vZGVQcm9taXNlKGVsKS50aGVuKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIG91dCQuc3ZnQXNQbmdVcmkoZWwsIG9wdGlvbnMgfHwge30pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVyaSkge1xuICAgICAgcmV0dXJuIG91dCQuZG93bmxvYWQobmFtZSwgdXJpLCBkb3dubG9hZE9wdHMpO1xuICAgIH0pO1xuICB9O1xufSkoKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/save-svg-as-png/lib/saveSvgAsPng.js\n"
          );

          /***/
        },

      /***/ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js':
        /*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            "\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBOztBQUVBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxTQUFJOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsR0FBRzs7QUFFSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDOztBQUVBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucykge1xuICB2YXIgc3R5bGVzID0gW107XG4gIHZhciBuZXdTdHlsZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNzcyA9IGl0ZW1bMV07XG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXTtcbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXTtcbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9O1xuXG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHBhcnRzOiBbcGFydF1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG4gICAgdmFyIGogPSAwO1xuXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKys7XG5cbiAgICAgIGZvciAoOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmF0dHJpYnV0ZXMgOiB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuICAgICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICAgIGRvbVN0eWxlLnJlZnMtLTtcbiAgICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICB2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgYWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbWF5UmVtb3ZlLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kb21TdHlsZSA9IG1heVJlbW92ZVtfaV07XG5cbiAgICAgIGlmIChfZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9kb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIF9kb21TdHlsZS5wYXJ0c1tqXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW19kb21TdHlsZS5pZF07XG4gICAgICB9XG4gICAgfVxuICB9O1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n"
          );

          /***/
        },

      /***/ './src/SplitStream.js':
        /*!****************************!*\
  !*** ./src/SplitStream.js ***!
  \****************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStream; });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"d3\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/d3svgfilters/src/d3-svg-filters.js */ \"./libs/d3svgfilters/src/d3-svg-filters.js\");\n/* harmony import */ var _libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SplitStreamInputData.js */ \"./src/SplitStreamInputData.js\");\n/* harmony import */ var _SplitStreamFilter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SplitStreamFilter.js */ \"./src/SplitStreamFilter.js\");\n/* harmony import */ var _SplitStreamData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SplitStreamData.js */ \"./src/SplitStreamData.js\");\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functions.js */ \"./src/functions.js\");\n/* harmony import */ var _css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../css/SplitStream.css */ \"./css/SplitStream.css\");\n/* harmony import */ var _css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\n\nclass SplitStream {\n  constructor(container, opts = {}) {\n    this._opts = {\n      axes: [\n        // {\n        //   position: 'left',\n        //   ticks: 10,\n        //   subticks: 2,\n        //   size: 30\n        // },\n        {\n          position: 'bottom',\n          ticks: 5,\n          tickSize: 'full',\n          textPos: [0, 0],\n          textSize: '2em',\n          textAnchor: 'middle',\n          textBase: 'none' // dominant-baseline\n        }\n      ],\n      transparentRoot: false,\n      margin: { top: 20, right: 20, bottom: 20, left: 20 },\n      height: container.clientHeight,\n      width: container.clientWidth,\n      automaticUpdate: true,\n      minSizeThreshold: 0,\n      //separationXMethod: \"\",\n      xMargin: 0,\n      //separationYMethod: \"\",\n      yMargin: 0,\n      yPadding: 0,\n      zoomTimeFactor: 1,\n      unifySize: false,\n      unifyPosition: false,\n      drawStroke: false,\n      showLabels: false,\n      mirror: false,\n      splitRoot: false,\n      shapeRendering: 'geometricPrecision',\n      offset: 'silhouette', // zero, expand, silhouette,\n      filterMode: 'fast',\n\n      ...opts // overwrite default settings with user settings\n    };\n\n    this._name = container.id;\n    this._container = container;\n    this._data;\n    this._zoomContainer;\n    this._axesContainer;\n    this._pathContainer;\n    this._textContainer;\n    this._svg;\n    this._svgFilters;\n    this._filters;\n    this._datasetsLoaded = 0;\n\n    this._streamData = new _SplitStreamData_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n    this._minTime;\n    this._maxTime;\n    this._maxValue;\n    this._maxDepth;\n    this._indices = {};\n\n    this._xSpacing = this.xSpacingFixed;\n    this._ySpacing = this.ySpacingFixed;\n\n    this._onMouseOver;\n    this._onMouseOut;\n\n    this._color = d3__WEBPACK_IMPORTED_MODULE_0__[\"scaleSequential\"](d3__WEBPACK_IMPORTED_MODULE_0__[\"interpolateBlues\"]);\n    this._colorRandom = false;\n\n    this._init();\n  }\n\n  static get a() { }\n\n  data(d) {\n    return d == null ? this._data : (this._setData(d), this);\n  }\n\n  filters(d) {\n    return d == null ? this._filters : (this._setFilters(d), this);\n  }\n\n  options(opts) {\n    Object.assign(this._opts, opts);\n  }\n\n  set automaticUpdate(auto) {\n    this._opts.automaticUpdate = auto;\n  }\n  set transparentRoot(transparent) {\n    this._opts.transparentRoot = transparent;\n    this._render();\n  }\n  set unifySize(unify) {\n    this._opts.unifySize = unify;\n    this._update();\n  }\n  set yPadding(value) {\n    this._opts.yPadding = +value;\n    this._update();\n  }\n  set unifyPosition(unify) {\n    this._opts.unifyPosition = unify;\n    this._update();\n  }\n  set mirror(mirror) {\n    this._opts.mirror = mirror;\n    this._update();\n  }\n  set splitRoot(splitRoot) {\n    this._opts.splitRoot = splitRoot;\n    this._update();\n  }\n  set minSizeThreshold(threshold) {\n    this._opts.minSizeThreshold = +threshold / 100;\n    this._update();\n  }\n  set zoomTime(factor) {\n    this._opts.zoomTimeFactor = +factor;\n    this._update();\n  }\n  set offset(offset) {\n    this._opts.offset = offset;\n    this._update();\n  }\n  set xMargin(value) {\n    this._opts.xMargin = +value;\n    this._update();\n  }\n  set yMargin(value) {\n    this._opts.yMargin = +value;\n    this._update();\n  }\n  set shapeRendering(rendering) {\n    this._opts.shapeRendering = rendering;\n    this.render();\n  }\n  set filterMode(mode) {\n    if (mode != this._opts.filterMode) {\n      d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('.depthLayer').clearFilter();\n      d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('path.stream').clearFilter();\n    }\n    this._opts.filterMode = mode;\n    this._applyFilters();\n  }\n\n  set color(colorFunction) {\n    this._color = colorFunction;\n    this.render();\n  }\n  set colorRandom(random) {\n    this._colorRandom = random;\n    this.render();\n  }\n  set proportion(value) {\n    this._streamData.proportion = this._opts.proportion = +value;\n    this._update();\n  }\n  set startEndEncoding(encoding) {\n    this._streamData.startEndEncoding = encoding;\n    this._update();\n  }\n  set startEndEncodingX(x) {\n    this._streamData.startEndEncodingX = x;\n    this._update();\n  }\n  set startEndEncodingY(y) {\n    this._streamData.startEndEncodingY = y;\n    this._update();\n  }\n  set xSpacing(callback) {\n    this._xSpacing = callback;\n    this._update();\n  }\n  set ySpacing(callback) {\n    this._ySpacing = callback;\n    this._update();\n  }\n\n  set onMouseOver(callback) {\n    this._onMouseOver = callback;\n    this.render();\n  }\n\n  set onMouseOut(callback) {\n    this._onMouseOut = callback;\n    this.render();\n  }\n\n  get splits() {\n    this._streamData.splits;\n  }\n\n  // expects SplitStreamInputData as input\n  _setData(d) {\n    if (!(d instanceof _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] || d instanceof _SplitStreamFilter_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]))\n      console.error(\n        'Added data is not an instance of SplitStreamData or SplitStreamFilter'\n      );\n\n    this._datasetsLoaded++;\n    this._data = d.data;\n    this._update();\n  }\n\n  _setFilters(d) {\n    if (!d || typeof d !== 'object')\n      return console.log(`ERROR: Added data \"${d}\" is not an object.`);\n    this._filters = d;\n    this._applyFilters();\n  }\n\n  _init() {\n    const { margin } = this._opts;\n    this._svg = d3__WEBPACK_IMPORTED_MODULE_0__[\"select\"](this._container)\n      .append('svg')\n      .classed('secstream', 'true')\n      .attr('height', this._container.clientHeight)\n      .attr('width', this._container.clientWidth)\n      .call(\n        d3__WEBPACK_IMPORTED_MODULE_0__[\"zoom\"]().on('zoom', () => {\n          this._zoomContainer.attr('transform', d3__WEBPACK_IMPORTED_MODULE_0__[\"event\"].transform);\n        })\n      );\n    //.on(\"contextmenu\", () => d3.event.preventDefault());\n    //.append('g')\n    //\t.attr('id', 'svg-drawn')\n    //.attr('transform', \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    this._svgFilters = this._svg.append('defs');\n    this._zoomContainer = this._svg.append('g').classed('zoom', true);\n    this._axesContainer = this._zoomContainer\n      .append('g')\n      .classed('axisContainer', true);\n    this._pathContainer = this._zoomContainer\n      .append('g')\n      .classed('pathContainer', true);\n    this._textContainer = this._zoomContainer\n      .append('g')\n      .classed('textContainer', true);\n    this._tooltipContainer = this._zoomContainer\n      .append('g')\n      .classed('tooltipContainer', true);\n  }\n\n  _applyOrdering() {\n    // change the order of siblings in the data for less edge crossings\n    // TEST: RANDOM ORDER OF LEAF NODES\n  }\n\n  // returns true if node id did not exist before\n  _findStreamId(node) {\n    if (!!node.prev) {\n      // use id of prev node\n      node.streamId = node.prev[0].streamId;\n      return false;\n    } else {\n      // new node\n      // check if id is already in use\n      if (!this._indices[node.id]) {\n        // if not, use this id for the stream\n        this._indices[node.id] = true;\n        node.streamId = node.id;\n      } else {\n        // find a new ID\n        let count = 0;\n        let id;\n        do {\n          count++;\n          id = node.id + '_' + count;\n        } while (!!this._indices[id]);\n        // console.log(`ID '${node.id}' is already in use. Use '${id}' instead.`);\n        // ID is now in use\n        this._indices[id] = true;\n        node.streamId = id;\n      }\n      return true;\n    }\n  }\n\n  _clearStreamIds() {\n    this._streamData.clear();\n    this._indices = {};\n  }\n\n  _normalizeData() {\n    // we add a padding and therefore need to recalculate the aggregate of each node\n    // if a node's size is bigger than its aggregate, it will use the aggregate as size\n    // TODO: padding interferes with positions\n    // TODO: padded aggregate can probably be calculated from the size of the subtree\n    let checkSizes = node => {\n      if (!!node.children) {\n        let aggregate = 0;\n        for (let child of node.children) {\n          checkSizes(child);\n          aggregate += child.size;\n        }\n        if (aggregate > node.dataSize || this._opts.unifySize)\n          node.size = aggregate;\n        else node.size = node.dataSize;\n\n        let padding = (node.children.length + 1) * this._opts.yPadding; // * (1 / (node.depth + 1));\n        node.size += padding;\n      } else\n        node.size = this._opts.unifySize\n          ? 1\n          : node.dataSize + this._opts.yPadding;\n    };\n\n    // TODO: This version is better with positions but doesn't work properly in general\n    // let checkSizes = node => {\n    //   if (!!node.children) {\n    //     let aggregate = 0;\n    //     for (let child of node.children) {\n    //       checkSizes(child);\n    //       aggregate += child.size;\n    //     }\n    //     let dataSize = node.dataSize + this._opts.yPadding;\n    //     if (aggregate > dataSize || this._opts.unifySize)\n    //       node.size = aggregate + this._opts.yPadding;\n    //     else node.size = dataSize;\n    //   } else node.size = this._opts.unifySize ? 1 : node.dataSize;\n    // };\n\n    // if nodes don't have a set position, spread them out equally\n    // positions must be unified, if sizes are unified\n    let checkPositions = (node, pos = 0) => {\n      if (\n        this._opts.unifySize ||\n        this._opts.unifyPosition ||\n        Number.isNaN(node.dataPos)\n        // (!!node.parent && node.parent.id == 'fakeRoot')\n      )\n        node.pos = pos;\n      else node.pos = node.dataPos;\n\n      if (!!node.children && node.children.length > 0) {\n        let aggregate = 0;\n        for (let child of node.children) {\n          aggregate += child.size;\n        }\n        let spacing = (node.size - aggregate) / (node.children.length + 1);\n\n        for (let [i, child] of node.children.entries()) {\n          pos += spacing;\n          checkPositions(child, pos);\n          pos += child.size;\n        }\n      }\n    };\n\n    this._clearStreamIds();\n    let time = this._data.timesteps;\n    this._maxValue = 0;\n    this._maxTime = 0;\n    this._minTime = Infinity;\n    for (let t in time) {\n      checkSizes(time[t].tree);\n      checkPositions(time[t].tree);\n      this._maxValue = Math.max(this._maxValue, time[t].tree.size);\n      this._minTime = Math.min(this._minTime, +t);\n      this._maxTime = Math.max(this._maxTime, +t);\n    }\n\n    this._maxDepth = 0;\n    let traverse = (node, depth) => {\n      this._maxDepth = Math.max(this._maxDepth, depth);\n      node.depth = depth++;\n      let isNew = this._findStreamId(node);\n      if (isNew) this._streamData.add(node);\n\n      if (!!node.children)\n        node.children.forEach(child => traverse(child, depth));\n    };\n\n    for (let i in time) traverse(time[i].tree, 0);\n  }\n\n  _calculatePositions() {\n    let { minSizeThreshold, offset } = this._opts;\n\n    let setOffset = root => {\n      if (offset == 'zero') {\n        root.y0 = 0;\n        root.y1 = root.size / this._maxValue;\n      } else if (offset == 'expand') {\n        root.y0 = 0;\n        root.y1 = 1;\n      } else if (offset == 'silhouette') {\n        root.y0 = 0.5 - (0.5 * root.size) / this._maxValue;\n        root.y1 = 0.5 + (0.5 * root.size) / this._maxValue;\n      }\n    };\n\n    let traverse = (node, childX = 0) => {\n      let p = node.parent;\n      if (!p) {\n        node.marginX = this._opts.splitRoot ? this._xSpacing(node) : 0;\n      } else {\n        let space = p.y1 - p.y0 - (p.children.length + 1) * p.marginY;\n        // if the parent is too small, draw children as a zero line in the center of the parent stream\n        if (space <= 0) {\n          node.y0 = 0.5 * (p.y0 + p.y1);\n          node.y1 = 0.5 * (p.y0 + p.y1);\n        } else {\n          // normalize\n          node.rpos = (node.pos - p.pos) / p.size;\n          node.rsize = node.size / p.size;\n          node.y0 = p.y0 + (childX + 1) * p.marginY + space * node.rpos;\n          node.y1 = node.y0 + space * node.rsize;\n\n          // if a node is too small, draw it as a zero line\n          let size = node.y1 - node.y0;\n          if (size <= minSizeThreshold) {\n            node.y0 = 0.5 * (node.y0 + node.y1);\n            node.y1 = 0.5 * (node.y0 + node.y1);\n          }\n        }\n\n        node.marginX = p.marginX + this._xSpacing(node);\n      }\n\n      node.marginY = this._ySpacing(node);\n\n      if (!!node.children)\n        node.children.forEach((child, i) => traverse(child, i));\n    };\n\n    let time = this._data.timesteps;\n    for (let i in time) {\n      setOffset(time[i].tree);\n      traverse(time[i].tree);\n    }\n\n    this._setScales();\n  }\n\n  _setScales() {\n    let { height, width, margin, mirror, zoomTimeFactor } = this._opts;\n    // treemaps require 0.5 space on the time axis to the left and right of each timestep\n    this._streamData.xScale = d3__WEBPACK_IMPORTED_MODULE_0__[\"scaleLinear\"]()\n      .domain([this._minTime - 0.5, this._maxTime + 0.5])\n      // .domain([\n      //   this._minTime - 0.5 * (1 - this._opts.proportion),\n      //   this._maxTime + 0.5 * (1 - this._opts.proportion)\n      // ])\n      .range([margin.left, width * zoomTimeFactor - margin.right]);\n\n    let domain = mirror ? [1, 0] : [0, 1];\n    this._streamData.yScale = d3__WEBPACK_IMPORTED_MODULE_0__[\"scaleLinear\"]()\n      .domain(domain)\n      .nice()\n      .range([height - margin.bottom, margin.top]);\n    //.range(margin.top, height - margin.bottom);\n\n    this._drawAxes();\n  }\n\n  setRootNodeById(Id) {\n    let root = this._streamData.streams.find(d => d.id == id);\n  }\n\n  render() {\n    let minColoredDepth = this._opts.transparentRoot ? 1 : 0;\n    let color = this._colorRandom\n      ? _functions_js__WEBPACK_IMPORTED_MODULE_5__[\"getRandomColor\"]\n      : this._color.domain([this._maxDepth, minColoredDepth]);\n\n    let streamsByDepth = d3__WEBPACK_IMPORTED_MODULE_0__[\"nest\"]()\n      .key(d => d.deepestDepth)\n      .entries(this._streamData.streams);\n\n    let depthLayers = this._pathContainer\n      .selectAll('g.depthLayer > g.clipLayer')\n      .data(streamsByDepth, d => this._name + this._datasetsLoaded + d.key)\n      .join(enter =>\n        enter\n          .append('g')\n          .classed('depthLayer', true)\n          .each(function (d) {\n            this.classList.add('depth-' + d.key);\n          })\n          .append('g')\n          .classed('clipLayer', true)\n      );\n\n    // .attr('clip-path', d => 'url(#clip' + d.key + 'wrapper)');\n\n    depthLayers\n      .selectAll('path.stream')\n      .data(d => d.values, d => this._name + this._datasetsLoaded + d.id)\n      .join(enter =>\n        enter\n          .append('path')\n          .classed('stream', true)\n          .on('mouseover', this._onMouseOver)\n          .on('mouseout', this._onMouseOut)\n          .attr('clip-path', d => 'url(#clip' + d.id + this._name + ')')\n          .attr('id', d => 'stream' + d.id + this._name)\n          //.attr('stroke-width', 3)\n          .attr('paint-order', 'stroke')\n      )\n      .attr('d', d => d.path)\n      .attr('shape-rendering', this._opts.shapeRendering)\n      .attr(\n        'fill',\n        d => (!!d.data ? d.data.color : null) || color(d.deepestDepth)\n        // 'white'\n      )\n      .attr(\n        'fill-opacity',\n        this._opts.transparentRoot ? d => (d.id == 'fakeRoot' ? 0 : 1) : 1\n      )\n      // remove empty streams (they do not include a single bezier curve)\n      .filter(d => d.path.indexOf('C') == -1)\n      .remove();\n\n    this.showLabels(this._opts.showLabels);\n    this.drawStroke(this._opts.drawStroke);\n\n    let splitData = this._svgFilters\n      .selectAll('clipPath')\n      .data(\n        this._streamData.clipPaths,\n        d => this._name + this._datasetsLoaded + d.id\n      );\n\n    splitData\n      .enter()\n      .append('clipPath')\n      .attr('id', d => 'clip' + d.id + this._name)\n      .merge(splitData)\n      .html(d => '<path d=\"' + d.path + '\">');\n\n    splitData.exit().remove();\n\n    this._applyFilters();\n  }\n\n  _drawAxes() {\n    this._axesContainer.selectAll('*').remove();\n    let { axes, height, width } = this._opts;\n    if (axes) {\n      for (let axis of axes) {\n        axis.subticks = axis.subticks || 0;\n        axis.name = 'axis' + axis.position;\n        let totalTicks = axis.ticks * (1 + axis.subticks);\n        let dirY = axis.position == 'left' || axis.position == 'right';\n\n        let axisCon = this._axesContainer.append('g').classed(axis.name, true);\n\n        let d3axis;\n        if (axis.position == 'left') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisLeft\"](this._streamData.yScale);\n        } else if (axis.position == 'right') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisRight\"](this._streamData.yScale);\n        } else if (axis.position == 'top') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisTop\"](this._streamData.xScale);\n        } else if (axis.position == 'bottom') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisBottom\"](this._streamData.xScale);\n        }\n\n        if (totalTicks) d3axis.ticks(totalTicks);\n        // do not label subticks\n        d3axis.tickFormat((d, i) => (!(i % (1 + axis.subticks)) ? d : null));\n\n        if (axis.tickSize == 'full') {\n          let tickSize = dirY ? width : height;\n          d3axis.tickSize(tickSize);\n        }\n\n        axisCon.call(d3axis);\n\n        // move labels\n        let text = axisCon.selectAll('.tick text');\n        if (axis.textPos)\n          text.attr('x', axis.textPos[0]).attr('y', axis.textPos[1]);\n\n        if (axis.textSize) text.attr('font-size', axis.textSize);\n\n        if (axis.textAnchor) text.attr('text-anchor', axis.textAnchor);\n\n        if (axis.textBase) text.attr('dominant-baseline', axis.textBase);\n\n        axisCon.select('.domain').remove();\n      }\n    }\n  }\n\n  showLabels(show = true) {\n    this._opts.showLabels = show;\n    let labelData = this._opts.showLabels ? this._streamData.streams : [];\n\n    let labels = this._textContainer\n      .selectAll('text')\n      .data(labelData, d => d.id);\n\n    labels\n      .enter()\n      .append('text')\n      .text(d => (!!d.data ? d.data.typeLabel : d.id))\n      .merge(labels)\n      .attr('x', d => d.textPos.x)\n      .attr('y', d => d.textPos.y);\n\n    labels.exit().remove();\n  }\n\n  drawStroke(draw = true) {\n    this._opts.drawStroke = draw;\n    let color = this._opts.drawStroke ? 'black' : null;\n    this._pathContainer.attr('stroke', color);\n    this._pathContainer.attr('stroke-width', 3);\n    // d3.selectAll('path').attr('stroke-width', 0.001)\n  }\n\n  _applyFilters() {\n    if (!this._filters) return;\n\n    let filters = [];\n    for (let filter of this._filters)\n      filters.push(filter.type, {\n        color: 'black',\n        dx: filter.dx,\n        dy: filter.dy,\n        blur: filter.stdDeviation\n      });\n\n    if (this._opts.filterMode == 'fast')\n      d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('.depthLayer').svgFilter(...filters);\n    else if (this._opts.filterMode == 'accurate')\n      d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('path.stream').svgFilter(...filters);\n  }\n\n  update() {\n    this._update(true);\n  }\n  _update(manuallyTriggered = false) {\n    if (!this._data) return;\n\n    if (!this._opts.automaticUpdate) if (!manuallyTriggered) return;\n\n    // console.log('update');\n    let startTime = Date.now();\n\n    this._normalizeData();\n    this._applyOrdering();\n    this._calculatePositions();\n\n    // this._streamData.preprocess();\n    this._streamData.calculatePaths();\n    this.render();\n\n    // console.log(\n    //   'TIMING: ' + this._data.numNodes + ',' + (Date.now() - startTime)\n    // );\n  }\n\n  resize(\n    width = this._container.clientWidth,\n    height = this._container.clientHeight\n  ) {\n    this._opts.width = width;\n    this._opts.height = height;\n    this._svg.attr('width', width).attr('height', height);\n\n    this._update();\n  }\n\n  ySpacingFixed(node) {\n    return this._opts.yMargin / 4;\n  }\n\n  ySpacingPercentage(node) {\n    return ((node.y1 - node.y0) * this._opts.yMargin) / 2;\n  }\n\n  ySpacingHierarchical(node) {\n    return ((node.depth + 1) * this._opts.yMargin) / 4;\n  }\n\n  ySpacingHierarchicalReverse(node) {\n    return ((1 / (node.depth + 1)) * this._opts.yMargin) / 4;\n  }\n\n  xSpacingFixed(node) {\n    return this._opts.xMargin / 10;\n  }\n\n  // TODO: use the max depth at that timepoint instead\n  xSpacingHierarchical(node) {\n    return ((node.depth + 1) / this._maxDepth) * this._opts.xMargin;\n  }\n\n  xSpacingHierarchicalReverse(node) {\n    return (1 / (node.depth + 1)) * this._opts.xMargin;\n  }\n\n  addSplits(splits) {\n    this._streamData.addSplits(splits);\n    this._update();\n  }\n\n  addSplitsAtTimepoints() {\n    let splits = [];\n    for (let i = this._minTime; i <= this._maxTime; i++) splits.push(i);\n    this.addSplits(splits);\n  }\n\n  addSplitsBetweenTimepoints() {\n    let splits = [];\n    for (let i = this._minTime - 1; i <= this._maxTime; i++)\n      splits.push(i + 0.5);\n    this.addSplits(splits);\n  }\n\n  addSplitsRandomly(num = 1) {\n    let t0 = this._minTime - 1;\n    let t1 = this._maxTime + 1;\n    let splits = [];\n    for (let i = 0; i < num; i++) {\n      let r = t0 + Math.random() * (t1 - t0);\n      splits.push(r.toString());\n      splits.sort();\n    }\n    this.addSplits(splits);\n  }\n\n  removeSplits(splits) {\n    this._streamData.removeSplits(splits);\n    this._update();\n  }\n\n  // static extend(...args) {\n  //     this.myNewFunction\n  // }\n  // extend(...args) {\n  //     return SplitStream.extend(...args);\n  // }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW0uanM/OWQzYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUI7QUFDMkI7O0FBRVM7QUFDTjtBQUNKOztBQUVIO0FBQ2hCOztBQUVqQjtBQUNmLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBMkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwyREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0RBQWtCLENBQUMsbURBQW1CO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0Q0FBWTtBQUNsQixNQUFNLDRDQUFZO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQW9CLGlCQUFpQiw2REFBaUI7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsZ0JBQWdCLHlDQUNIO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQU87QUFDZixnREFBZ0Qsd0NBQVE7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QixRQUFRLDRCQUE0QixHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDJCQUEyQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnREFBZ0Q7QUFDekQ7QUFDQSw4QkFBOEIsOENBQ1o7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDhDQUNaO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQWM7QUFDdEI7O0FBRUEseUJBQXlCLHVDQUNkO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBVztBQUM5QixTQUFTO0FBQ1QsbUJBQW1CLDRDQUFZO0FBQy9CLFNBQVM7QUFDVCxtQkFBbUIsMENBQVU7QUFDN0IsU0FBUztBQUNULG1CQUFtQiw2Q0FBYTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsTUFBTSw0Q0FBWTtBQUNsQjtBQUNBLE1BQU0sNENBQVk7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9TcGxpdFN0cmVhbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCAnLi4vbGlicy9kM3N2Z2ZpbHRlcnMvc3JjL2QzLXN2Zy1maWx0ZXJzLmpzJztcblxuaW1wb3J0IFNwbGl0U3RyZWFtSW5wdXREYXRhIGZyb20gJy4vU3BsaXRTdHJlYW1JbnB1dERhdGEuanMnO1xuaW1wb3J0IFNwbGl0U3RyZWFtRmlsdGVyIGZyb20gJy4vU3BsaXRTdHJlYW1GaWx0ZXIuanMnO1xuaW1wb3J0IFNwbGl0U3RyZWFtRGF0YSBmcm9tICcuL1NwbGl0U3RyZWFtRGF0YS5qcyc7XG5cbmltcG9ydCB7IGdldFJhbmRvbUNvbG9yIH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0ICcuLi9jc3MvU3BsaXRTdHJlYW0uY3NzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXRTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIG9wdHMgPSB7fSkge1xuICAgIHRoaXMuX29wdHMgPSB7XG4gICAgICBheGVzOiBbXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICBwb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgICAvLyAgIHRpY2tzOiAxMCxcbiAgICAgICAgLy8gICBzdWJ0aWNrczogMixcbiAgICAgICAgLy8gICBzaXplOiAzMFxuICAgICAgICAvLyB9LFxuICAgICAgICB7XG4gICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgICAgICAgIHRpY2tzOiA1LFxuICAgICAgICAgIHRpY2tTaXplOiAnZnVsbCcsXG4gICAgICAgICAgdGV4dFBvczogWzAsIDBdLFxuICAgICAgICAgIHRleHRTaXplOiAnMmVtJyxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICB0ZXh0QmFzZTogJ25vbmUnIC8vIGRvbWluYW50LWJhc2VsaW5lXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB0cmFuc3BhcmVudFJvb3Q6IGZhbHNlLFxuICAgICAgbWFyZ2luOiB7IHRvcDogMjAsIHJpZ2h0OiAyMCwgYm90dG9tOiAyMCwgbGVmdDogMjAgfSxcbiAgICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodCxcbiAgICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgICBhdXRvbWF0aWNVcGRhdGU6IHRydWUsXG4gICAgICBtaW5TaXplVGhyZXNob2xkOiAwLFxuICAgICAgLy9zZXBhcmF0aW9uWE1ldGhvZDogXCJcIixcbiAgICAgIHhNYXJnaW46IDAsXG4gICAgICAvL3NlcGFyYXRpb25ZTWV0aG9kOiBcIlwiLFxuICAgICAgeU1hcmdpbjogMCxcbiAgICAgIHlQYWRkaW5nOiAwLFxuICAgICAgem9vbVRpbWVGYWN0b3I6IDEsXG4gICAgICB1bmlmeVNpemU6IGZhbHNlLFxuICAgICAgdW5pZnlQb3NpdGlvbjogZmFsc2UsXG4gICAgICBkcmF3U3Ryb2tlOiBmYWxzZSxcbiAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxuICAgICAgbWlycm9yOiBmYWxzZSxcbiAgICAgIHNwbGl0Um9vdDogZmFsc2UsXG4gICAgICBzaGFwZVJlbmRlcmluZzogJ2dlb21ldHJpY1ByZWNpc2lvbicsXG4gICAgICBvZmZzZXQ6ICdzaWxob3VldHRlJywgLy8gemVybywgZXhwYW5kLCBzaWxob3VldHRlLFxuICAgICAgZmlsdGVyTW9kZTogJ2Zhc3QnLFxuXG4gICAgICAuLi5vcHRzIC8vIG92ZXJ3cml0ZSBkZWZhdWx0IHNldHRpbmdzIHdpdGggdXNlciBzZXR0aW5nc1xuICAgIH07XG5cbiAgICB0aGlzLl9uYW1lID0gY29udGFpbmVyLmlkO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLl9kYXRhO1xuICAgIHRoaXMuX3pvb21Db250YWluZXI7XG4gICAgdGhpcy5fYXhlc0NvbnRhaW5lcjtcbiAgICB0aGlzLl9wYXRoQ29udGFpbmVyO1xuICAgIHRoaXMuX3RleHRDb250YWluZXI7XG4gICAgdGhpcy5fc3ZnO1xuICAgIHRoaXMuX3N2Z0ZpbHRlcnM7XG4gICAgdGhpcy5fZmlsdGVycztcbiAgICB0aGlzLl9kYXRhc2V0c0xvYWRlZCA9IDA7XG5cbiAgICB0aGlzLl9zdHJlYW1EYXRhID0gbmV3IFNwbGl0U3RyZWFtRGF0YSgpO1xuICAgIHRoaXMuX21pblRpbWU7XG4gICAgdGhpcy5fbWF4VGltZTtcbiAgICB0aGlzLl9tYXhWYWx1ZTtcbiAgICB0aGlzLl9tYXhEZXB0aDtcbiAgICB0aGlzLl9pbmRpY2VzID0ge307XG5cbiAgICB0aGlzLl94U3BhY2luZyA9IHRoaXMueFNwYWNpbmdGaXhlZDtcbiAgICB0aGlzLl95U3BhY2luZyA9IHRoaXMueVNwYWNpbmdGaXhlZDtcblxuICAgIHRoaXMuX29uTW91c2VPdmVyO1xuICAgIHRoaXMuX29uTW91c2VPdXQ7XG5cbiAgICB0aGlzLl9jb2xvciA9IGQzLnNjYWxlU2VxdWVudGlhbChkMy5pbnRlcnBvbGF0ZUJsdWVzKTtcbiAgICB0aGlzLl9jb2xvclJhbmRvbSA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBhKCkgeyB9XG5cbiAgZGF0YShkKSB7XG4gICAgcmV0dXJuIGQgPT0gbnVsbCA/IHRoaXMuX2RhdGEgOiAodGhpcy5fc2V0RGF0YShkKSwgdGhpcyk7XG4gIH1cblxuICBmaWx0ZXJzKGQpIHtcbiAgICByZXR1cm4gZCA9PSBudWxsID8gdGhpcy5fZmlsdGVycyA6ICh0aGlzLl9zZXRGaWx0ZXJzKGQpLCB0aGlzKTtcbiAgfVxuXG4gIG9wdGlvbnMob3B0cykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fb3B0cywgb3B0cyk7XG4gIH1cblxuICBzZXQgYXV0b21hdGljVXBkYXRlKGF1dG8pIHtcbiAgICB0aGlzLl9vcHRzLmF1dG9tYXRpY1VwZGF0ZSA9IGF1dG87XG4gIH1cbiAgc2V0IHRyYW5zcGFyZW50Um9vdCh0cmFuc3BhcmVudCkge1xuICAgIHRoaXMuX29wdHMudHJhbnNwYXJlbnRSb290ID0gdHJhbnNwYXJlbnQ7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cbiAgc2V0IHVuaWZ5U2l6ZSh1bmlmeSkge1xuICAgIHRoaXMuX29wdHMudW5pZnlTaXplID0gdW5pZnk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHlQYWRkaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5fb3B0cy55UGFkZGluZyA9ICt2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgdW5pZnlQb3NpdGlvbih1bmlmeSkge1xuICAgIHRoaXMuX29wdHMudW5pZnlQb3NpdGlvbiA9IHVuaWZ5O1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCBtaXJyb3IobWlycm9yKSB7XG4gICAgdGhpcy5fb3B0cy5taXJyb3IgPSBtaXJyb3I7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHNwbGl0Um9vdChzcGxpdFJvb3QpIHtcbiAgICB0aGlzLl9vcHRzLnNwbGl0Um9vdCA9IHNwbGl0Um9vdDtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgbWluU2l6ZVRocmVzaG9sZCh0aHJlc2hvbGQpIHtcbiAgICB0aGlzLl9vcHRzLm1pblNpemVUaHJlc2hvbGQgPSArdGhyZXNob2xkIC8gMTAwO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCB6b29tVGltZShmYWN0b3IpIHtcbiAgICB0aGlzLl9vcHRzLnpvb21UaW1lRmFjdG9yID0gK2ZhY3RvcjtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgb2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMuX29wdHMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCB4TWFyZ2luKHZhbHVlKSB7XG4gICAgdGhpcy5fb3B0cy54TWFyZ2luID0gK3ZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCB5TWFyZ2luKHZhbHVlKSB7XG4gICAgdGhpcy5fb3B0cy55TWFyZ2luID0gK3ZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCBzaGFwZVJlbmRlcmluZyhyZW5kZXJpbmcpIHtcbiAgICB0aGlzLl9vcHRzLnNoYXBlUmVuZGVyaW5nID0gcmVuZGVyaW5nO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgc2V0IGZpbHRlck1vZGUobW9kZSkge1xuICAgIGlmIChtb2RlICE9IHRoaXMuX29wdHMuZmlsdGVyTW9kZSkge1xuICAgICAgZDMuc2VsZWN0QWxsKCcuZGVwdGhMYXllcicpLmNsZWFyRmlsdGVyKCk7XG4gICAgICBkMy5zZWxlY3RBbGwoJ3BhdGguc3RyZWFtJykuY2xlYXJGaWx0ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5fb3B0cy5maWx0ZXJNb2RlID0gbW9kZTtcbiAgICB0aGlzLl9hcHBseUZpbHRlcnMoKTtcbiAgfVxuXG4gIHNldCBjb2xvcihjb2xvckZ1bmN0aW9uKSB7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvckZ1bmN0aW9uO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgc2V0IGNvbG9yUmFuZG9tKHJhbmRvbSkge1xuICAgIHRoaXMuX2NvbG9yUmFuZG9tID0gcmFuZG9tO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgc2V0IHByb3BvcnRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9zdHJlYW1EYXRhLnByb3BvcnRpb24gPSB0aGlzLl9vcHRzLnByb3BvcnRpb24gPSArdmFsdWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHN0YXJ0RW5kRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICB0aGlzLl9zdHJlYW1EYXRhLnN0YXJ0RW5kRW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgc3RhcnRFbmRFbmNvZGluZ1goeCkge1xuICAgIHRoaXMuX3N0cmVhbURhdGEuc3RhcnRFbmRFbmNvZGluZ1ggPSB4O1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCBzdGFydEVuZEVuY29kaW5nWSh5KSB7XG4gICAgdGhpcy5fc3RyZWFtRGF0YS5zdGFydEVuZEVuY29kaW5nWSA9IHk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHhTcGFjaW5nKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5feFNwYWNpbmcgPSBjYWxsYmFjaztcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgeVNwYWNpbmcoY2FsbGJhY2spIHtcbiAgICB0aGlzLl95U3BhY2luZyA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgc2V0IG9uTW91c2VPdmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25Nb3VzZU92ZXIgPSBjYWxsYmFjaztcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgc2V0IG9uTW91c2VPdXQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbk1vdXNlT3V0ID0gY2FsbGJhY2s7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIGdldCBzcGxpdHMoKSB7XG4gICAgdGhpcy5fc3RyZWFtRGF0YS5zcGxpdHM7XG4gIH1cblxuICAvLyBleHBlY3RzIFNwbGl0U3RyZWFtSW5wdXREYXRhIGFzIGlucHV0XG4gIF9zZXREYXRhKGQpIHtcbiAgICBpZiAoIShkIGluc3RhbmNlb2YgU3BsaXRTdHJlYW1JbnB1dERhdGEgfHwgZCBpbnN0YW5jZW9mIFNwbGl0U3RyZWFtRmlsdGVyKSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdBZGRlZCBkYXRhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBTcGxpdFN0cmVhbURhdGEgb3IgU3BsaXRTdHJlYW1GaWx0ZXInXG4gICAgICApO1xuXG4gICAgdGhpcy5fZGF0YXNldHNMb2FkZWQrKztcbiAgICB0aGlzLl9kYXRhID0gZC5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX3NldEZpbHRlcnMoZCkge1xuICAgIGlmICghZCB8fCB0eXBlb2YgZCAhPT0gJ29iamVjdCcpXG4gICAgICByZXR1cm4gY29uc29sZS5sb2coYEVSUk9SOiBBZGRlZCBkYXRhIFwiJHtkfVwiIGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gICAgdGhpcy5fZmlsdGVycyA9IGQ7XG4gICAgdGhpcy5fYXBwbHlGaWx0ZXJzKCk7XG4gIH1cblxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB7IG1hcmdpbiB9ID0gdGhpcy5fb3B0cztcbiAgICB0aGlzLl9zdmcgPSBkM1xuICAgICAgLnNlbGVjdCh0aGlzLl9jb250YWluZXIpXG4gICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgLmNsYXNzZWQoJ3NlY3N0cmVhbScsICd0cnVlJylcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KVxuICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoKVxuICAgICAgLmNhbGwoXG4gICAgICAgIGQzLnpvb20oKS5vbignem9vbScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl96b29tQ29udGFpbmVyLmF0dHIoJ3RyYW5zZm9ybScsIGQzLmV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIC8vLm9uKFwiY29udGV4dG1lbnVcIiwgKCkgPT4gZDMuZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgLy8uYXBwZW5kKCdnJylcbiAgICAvL1x0LmF0dHIoJ2lkJywgJ3N2Zy1kcmF3bicpXG4gICAgLy8uYXR0cigndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHRoaXMuX3N2Z0ZpbHRlcnMgPSB0aGlzLl9zdmcuYXBwZW5kKCdkZWZzJyk7XG4gICAgdGhpcy5fem9vbUNvbnRhaW5lciA9IHRoaXMuX3N2Zy5hcHBlbmQoJ2cnKS5jbGFzc2VkKCd6b29tJywgdHJ1ZSk7XG4gICAgdGhpcy5fYXhlc0NvbnRhaW5lciA9IHRoaXMuX3pvb21Db250YWluZXJcbiAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgLmNsYXNzZWQoJ2F4aXNDb250YWluZXInLCB0cnVlKTtcbiAgICB0aGlzLl9wYXRoQ29udGFpbmVyID0gdGhpcy5fem9vbUNvbnRhaW5lclxuICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAuY2xhc3NlZCgncGF0aENvbnRhaW5lcicsIHRydWUpO1xuICAgIHRoaXMuX3RleHRDb250YWluZXIgPSB0aGlzLl96b29tQ29udGFpbmVyXG4gICAgICAuYXBwZW5kKCdnJylcbiAgICAgIC5jbGFzc2VkKCd0ZXh0Q29udGFpbmVyJywgdHJ1ZSk7XG4gICAgdGhpcy5fdG9vbHRpcENvbnRhaW5lciA9IHRoaXMuX3pvb21Db250YWluZXJcbiAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgLmNsYXNzZWQoJ3Rvb2x0aXBDb250YWluZXInLCB0cnVlKTtcbiAgfVxuXG4gIF9hcHBseU9yZGVyaW5nKCkge1xuICAgIC8vIGNoYW5nZSB0aGUgb3JkZXIgb2Ygc2libGluZ3MgaW4gdGhlIGRhdGEgZm9yIGxlc3MgZWRnZSBjcm9zc2luZ3NcbiAgICAvLyBURVNUOiBSQU5ET00gT1JERVIgT0YgTEVBRiBOT0RFU1xuICB9XG5cbiAgLy8gcmV0dXJucyB0cnVlIGlmIG5vZGUgaWQgZGlkIG5vdCBleGlzdCBiZWZvcmVcbiAgX2ZpbmRTdHJlYW1JZChub2RlKSB7XG4gICAgaWYgKCEhbm9kZS5wcmV2KSB7XG4gICAgICAvLyB1c2UgaWQgb2YgcHJldiBub2RlXG4gICAgICBub2RlLnN0cmVhbUlkID0gbm9kZS5wcmV2WzBdLnN0cmVhbUlkO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXcgbm9kZVxuICAgICAgLy8gY2hlY2sgaWYgaWQgaXMgYWxyZWFkeSBpbiB1c2VcbiAgICAgIGlmICghdGhpcy5faW5kaWNlc1tub2RlLmlkXSkge1xuICAgICAgICAvLyBpZiBub3QsIHVzZSB0aGlzIGlkIGZvciB0aGUgc3RyZWFtXG4gICAgICAgIHRoaXMuX2luZGljZXNbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICBub2RlLnN0cmVhbUlkID0gbm9kZS5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbmQgYSBuZXcgSURcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICBpZCA9IG5vZGUuaWQgKyAnXycgKyBjb3VudDtcbiAgICAgICAgfSB3aGlsZSAoISF0aGlzLl9pbmRpY2VzW2lkXSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBJRCAnJHtub2RlLmlkfScgaXMgYWxyZWFkeSBpbiB1c2UuIFVzZSAnJHtpZH0nIGluc3RlYWQuYCk7XG4gICAgICAgIC8vIElEIGlzIG5vdyBpbiB1c2VcbiAgICAgICAgdGhpcy5faW5kaWNlc1tpZF0gPSB0cnVlO1xuICAgICAgICBub2RlLnN0cmVhbUlkID0gaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfY2xlYXJTdHJlYW1JZHMoKSB7XG4gICAgdGhpcy5fc3RyZWFtRGF0YS5jbGVhcigpO1xuICAgIHRoaXMuX2luZGljZXMgPSB7fTtcbiAgfVxuXG4gIF9ub3JtYWxpemVEYXRhKCkge1xuICAgIC8vIHdlIGFkZCBhIHBhZGRpbmcgYW5kIHRoZXJlZm9yZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBhZ2dyZWdhdGUgb2YgZWFjaCBub2RlXG4gICAgLy8gaWYgYSBub2RlJ3Mgc2l6ZSBpcyBiaWdnZXIgdGhhbiBpdHMgYWdncmVnYXRlLCBpdCB3aWxsIHVzZSB0aGUgYWdncmVnYXRlIGFzIHNpemVcbiAgICAvLyBUT0RPOiBwYWRkaW5nIGludGVyZmVyZXMgd2l0aCBwb3NpdGlvbnNcbiAgICAvLyBUT0RPOiBwYWRkZWQgYWdncmVnYXRlIGNhbiBwcm9iYWJseSBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIHNpemUgb2YgdGhlIHN1YnRyZWVcbiAgICBsZXQgY2hlY2tTaXplcyA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBsZXQgYWdncmVnYXRlID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGNoZWNrU2l6ZXMoY2hpbGQpO1xuICAgICAgICAgIGFnZ3JlZ2F0ZSArPSBjaGlsZC5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZ2dyZWdhdGUgPiBub2RlLmRhdGFTaXplIHx8IHRoaXMuX29wdHMudW5pZnlTaXplKVxuICAgICAgICAgIG5vZGUuc2l6ZSA9IGFnZ3JlZ2F0ZTtcbiAgICAgICAgZWxzZSBub2RlLnNpemUgPSBub2RlLmRhdGFTaXplO1xuXG4gICAgICAgIGxldCBwYWRkaW5nID0gKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICsgMSkgKiB0aGlzLl9vcHRzLnlQYWRkaW5nOyAvLyAqICgxIC8gKG5vZGUuZGVwdGggKyAxKSk7XG4gICAgICAgIG5vZGUuc2l6ZSArPSBwYWRkaW5nO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG5vZGUuc2l6ZSA9IHRoaXMuX29wdHMudW5pZnlTaXplXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiBub2RlLmRhdGFTaXplICsgdGhpcy5fb3B0cy55UGFkZGluZztcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogVGhpcyB2ZXJzaW9uIGlzIGJldHRlciB3aXRoIHBvc2l0aW9ucyBidXQgZG9lc24ndCB3b3JrIHByb3Blcmx5IGluIGdlbmVyYWxcbiAgICAvLyBsZXQgY2hlY2tTaXplcyA9IG5vZGUgPT4ge1xuICAgIC8vICAgaWYgKCEhbm9kZS5jaGlsZHJlbikge1xuICAgIC8vICAgICBsZXQgYWdncmVnYXRlID0gMDtcbiAgICAvLyAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgIC8vICAgICAgIGNoZWNrU2l6ZXMoY2hpbGQpO1xuICAgIC8vICAgICAgIGFnZ3JlZ2F0ZSArPSBjaGlsZC5zaXplO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGxldCBkYXRhU2l6ZSA9IG5vZGUuZGF0YVNpemUgKyB0aGlzLl9vcHRzLnlQYWRkaW5nO1xuICAgIC8vICAgICBpZiAoYWdncmVnYXRlID4gZGF0YVNpemUgfHwgdGhpcy5fb3B0cy51bmlmeVNpemUpXG4gICAgLy8gICAgICAgbm9kZS5zaXplID0gYWdncmVnYXRlICsgdGhpcy5fb3B0cy55UGFkZGluZztcbiAgICAvLyAgICAgZWxzZSBub2RlLnNpemUgPSBkYXRhU2l6ZTtcbiAgICAvLyAgIH0gZWxzZSBub2RlLnNpemUgPSB0aGlzLl9vcHRzLnVuaWZ5U2l6ZSA/IDEgOiBub2RlLmRhdGFTaXplO1xuICAgIC8vIH07XG5cbiAgICAvLyBpZiBub2RlcyBkb24ndCBoYXZlIGEgc2V0IHBvc2l0aW9uLCBzcHJlYWQgdGhlbSBvdXQgZXF1YWxseVxuICAgIC8vIHBvc2l0aW9ucyBtdXN0IGJlIHVuaWZpZWQsIGlmIHNpemVzIGFyZSB1bmlmaWVkXG4gICAgbGV0IGNoZWNrUG9zaXRpb25zID0gKG5vZGUsIHBvcyA9IDApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fb3B0cy51bmlmeVNpemUgfHxcbiAgICAgICAgdGhpcy5fb3B0cy51bmlmeVBvc2l0aW9uIHx8XG4gICAgICAgIE51bWJlci5pc05hTihub2RlLmRhdGFQb3MpXG4gICAgICAgIC8vICghIW5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LmlkID09ICdmYWtlUm9vdCcpXG4gICAgICApXG4gICAgICAgIG5vZGUucG9zID0gcG9zO1xuICAgICAgZWxzZSBub2RlLnBvcyA9IG5vZGUuZGF0YVBvcztcblxuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGFnZ3JlZ2F0ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBhZ2dyZWdhdGUgKz0gY2hpbGQuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhY2luZyA9IChub2RlLnNpemUgLSBhZ2dyZWdhdGUpIC8gKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG5cbiAgICAgICAgZm9yIChsZXQgW2ksIGNoaWxkXSBvZiBub2RlLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgIHBvcyArPSBzcGFjaW5nO1xuICAgICAgICAgIGNoZWNrUG9zaXRpb25zKGNoaWxkLCBwb3MpO1xuICAgICAgICAgIHBvcyArPSBjaGlsZC5zaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2NsZWFyU3RyZWFtSWRzKCk7XG4gICAgbGV0IHRpbWUgPSB0aGlzLl9kYXRhLnRpbWVzdGVwcztcbiAgICB0aGlzLl9tYXhWYWx1ZSA9IDA7XG4gICAgdGhpcy5fbWF4VGltZSA9IDA7XG4gICAgdGhpcy5fbWluVGltZSA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IHQgaW4gdGltZSkge1xuICAgICAgY2hlY2tTaXplcyh0aW1lW3RdLnRyZWUpO1xuICAgICAgY2hlY2tQb3NpdGlvbnModGltZVt0XS50cmVlKTtcbiAgICAgIHRoaXMuX21heFZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWF4VmFsdWUsIHRpbWVbdF0udHJlZS5zaXplKTtcbiAgICAgIHRoaXMuX21pblRpbWUgPSBNYXRoLm1pbih0aGlzLl9taW5UaW1lLCArdCk7XG4gICAgICB0aGlzLl9tYXhUaW1lID0gTWF0aC5tYXgodGhpcy5fbWF4VGltZSwgK3QpO1xuICAgIH1cblxuICAgIHRoaXMuX21heERlcHRoID0gMDtcbiAgICBsZXQgdHJhdmVyc2UgPSAobm9kZSwgZGVwdGgpID0+IHtcbiAgICAgIHRoaXMuX21heERlcHRoID0gTWF0aC5tYXgodGhpcy5fbWF4RGVwdGgsIGRlcHRoKTtcbiAgICAgIG5vZGUuZGVwdGggPSBkZXB0aCsrO1xuICAgICAgbGV0IGlzTmV3ID0gdGhpcy5fZmluZFN0cmVhbUlkKG5vZGUpO1xuICAgICAgaWYgKGlzTmV3KSB0aGlzLl9zdHJlYW1EYXRhLmFkZChub2RlKTtcblxuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbilcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHRyYXZlcnNlKGNoaWxkLCBkZXB0aCkpO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBpIGluIHRpbWUpIHRyYXZlcnNlKHRpbWVbaV0udHJlZSwgMCk7XG4gIH1cblxuICBfY2FsY3VsYXRlUG9zaXRpb25zKCkge1xuICAgIGxldCB7IG1pblNpemVUaHJlc2hvbGQsIG9mZnNldCB9ID0gdGhpcy5fb3B0cztcblxuICAgIGxldCBzZXRPZmZzZXQgPSByb290ID0+IHtcbiAgICAgIGlmIChvZmZzZXQgPT0gJ3plcm8nKSB7XG4gICAgICAgIHJvb3QueTAgPSAwO1xuICAgICAgICByb290LnkxID0gcm9vdC5zaXplIC8gdGhpcy5fbWF4VmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAnZXhwYW5kJykge1xuICAgICAgICByb290LnkwID0gMDtcbiAgICAgICAgcm9vdC55MSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAnc2lsaG91ZXR0ZScpIHtcbiAgICAgICAgcm9vdC55MCA9IDAuNSAtICgwLjUgKiByb290LnNpemUpIC8gdGhpcy5fbWF4VmFsdWU7XG4gICAgICAgIHJvb3QueTEgPSAwLjUgKyAoMC41ICogcm9vdC5zaXplKSAvIHRoaXMuX21heFZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgdHJhdmVyc2UgPSAobm9kZSwgY2hpbGRYID0gMCkgPT4ge1xuICAgICAgbGV0IHAgPSBub2RlLnBhcmVudDtcbiAgICAgIGlmICghcCkge1xuICAgICAgICBub2RlLm1hcmdpblggPSB0aGlzLl9vcHRzLnNwbGl0Um9vdCA/IHRoaXMuX3hTcGFjaW5nKG5vZGUpIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzcGFjZSA9IHAueTEgLSBwLnkwIC0gKHAuY2hpbGRyZW4ubGVuZ3RoICsgMSkgKiBwLm1hcmdpblk7XG4gICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgaXMgdG9vIHNtYWxsLCBkcmF3IGNoaWxkcmVuIGFzIGEgemVybyBsaW5lIGluIHRoZSBjZW50ZXIgb2YgdGhlIHBhcmVudCBzdHJlYW1cbiAgICAgICAgaWYgKHNwYWNlIDw9IDApIHtcbiAgICAgICAgICBub2RlLnkwID0gMC41ICogKHAueTAgKyBwLnkxKTtcbiAgICAgICAgICBub2RlLnkxID0gMC41ICogKHAueTAgKyBwLnkxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3JtYWxpemVcbiAgICAgICAgICBub2RlLnJwb3MgPSAobm9kZS5wb3MgLSBwLnBvcykgLyBwLnNpemU7XG4gICAgICAgICAgbm9kZS5yc2l6ZSA9IG5vZGUuc2l6ZSAvIHAuc2l6ZTtcbiAgICAgICAgICBub2RlLnkwID0gcC55MCArIChjaGlsZFggKyAxKSAqIHAubWFyZ2luWSArIHNwYWNlICogbm9kZS5ycG9zO1xuICAgICAgICAgIG5vZGUueTEgPSBub2RlLnkwICsgc3BhY2UgKiBub2RlLnJzaXplO1xuXG4gICAgICAgICAgLy8gaWYgYSBub2RlIGlzIHRvbyBzbWFsbCwgZHJhdyBpdCBhcyBhIHplcm8gbGluZVxuICAgICAgICAgIGxldCBzaXplID0gbm9kZS55MSAtIG5vZGUueTA7XG4gICAgICAgICAgaWYgKHNpemUgPD0gbWluU2l6ZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgbm9kZS55MCA9IDAuNSAqIChub2RlLnkwICsgbm9kZS55MSk7XG4gICAgICAgICAgICBub2RlLnkxID0gMC41ICogKG5vZGUueTAgKyBub2RlLnkxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLm1hcmdpblggPSBwLm1hcmdpblggKyB0aGlzLl94U3BhY2luZyhub2RlKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5tYXJnaW5ZID0gdGhpcy5feVNwYWNpbmcobm9kZSk7XG5cbiAgICAgIGlmICghIW5vZGUuY2hpbGRyZW4pXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGkpID0+IHRyYXZlcnNlKGNoaWxkLCBpKSk7XG4gICAgfTtcblxuICAgIGxldCB0aW1lID0gdGhpcy5fZGF0YS50aW1lc3RlcHM7XG4gICAgZm9yIChsZXQgaSBpbiB0aW1lKSB7XG4gICAgICBzZXRPZmZzZXQodGltZVtpXS50cmVlKTtcbiAgICAgIHRyYXZlcnNlKHRpbWVbaV0udHJlZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0U2NhbGVzKCk7XG4gIH1cblxuICBfc2V0U2NhbGVzKCkge1xuICAgIGxldCB7IGhlaWdodCwgd2lkdGgsIG1hcmdpbiwgbWlycm9yLCB6b29tVGltZUZhY3RvciB9ID0gdGhpcy5fb3B0cztcbiAgICAvLyB0cmVlbWFwcyByZXF1aXJlIDAuNSBzcGFjZSBvbiB0aGUgdGltZSBheGlzIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiBlYWNoIHRpbWVzdGVwXG4gICAgdGhpcy5fc3RyZWFtRGF0YS54U2NhbGUgPSBkM1xuICAgICAgLnNjYWxlTGluZWFyKClcbiAgICAgIC5kb21haW4oW3RoaXMuX21pblRpbWUgLSAwLjUsIHRoaXMuX21heFRpbWUgKyAwLjVdKVxuICAgICAgLy8gLmRvbWFpbihbXG4gICAgICAvLyAgIHRoaXMuX21pblRpbWUgLSAwLjUgKiAoMSAtIHRoaXMuX29wdHMucHJvcG9ydGlvbiksXG4gICAgICAvLyAgIHRoaXMuX21heFRpbWUgKyAwLjUgKiAoMSAtIHRoaXMuX29wdHMucHJvcG9ydGlvbilcbiAgICAgIC8vIF0pXG4gICAgICAucmFuZ2UoW21hcmdpbi5sZWZ0LCB3aWR0aCAqIHpvb21UaW1lRmFjdG9yIC0gbWFyZ2luLnJpZ2h0XSk7XG5cbiAgICBsZXQgZG9tYWluID0gbWlycm9yID8gWzEsIDBdIDogWzAsIDFdO1xuICAgIHRoaXMuX3N0cmVhbURhdGEueVNjYWxlID0gZDNcbiAgICAgIC5zY2FsZUxpbmVhcigpXG4gICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgIC5uaWNlKClcbiAgICAgIC5yYW5nZShbaGVpZ2h0IC0gbWFyZ2luLmJvdHRvbSwgbWFyZ2luLnRvcF0pO1xuICAgIC8vLnJhbmdlKG1hcmdpbi50b3AsIGhlaWdodCAtIG1hcmdpbi5ib3R0b20pO1xuXG4gICAgdGhpcy5fZHJhd0F4ZXMoKTtcbiAgfVxuXG4gIHNldFJvb3ROb2RlQnlJZChJZCkge1xuICAgIGxldCByb290ID0gdGhpcy5fc3RyZWFtRGF0YS5zdHJlYW1zLmZpbmQoZCA9PiBkLmlkID09IGlkKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgbWluQ29sb3JlZERlcHRoID0gdGhpcy5fb3B0cy50cmFuc3BhcmVudFJvb3QgPyAxIDogMDtcbiAgICBsZXQgY29sb3IgPSB0aGlzLl9jb2xvclJhbmRvbVxuICAgICAgPyBnZXRSYW5kb21Db2xvclxuICAgICAgOiB0aGlzLl9jb2xvci5kb21haW4oW3RoaXMuX21heERlcHRoLCBtaW5Db2xvcmVkRGVwdGhdKTtcblxuICAgIGxldCBzdHJlYW1zQnlEZXB0aCA9IGQzXG4gICAgICAubmVzdCgpXG4gICAgICAua2V5KGQgPT4gZC5kZWVwZXN0RGVwdGgpXG4gICAgICAuZW50cmllcyh0aGlzLl9zdHJlYW1EYXRhLnN0cmVhbXMpO1xuXG4gICAgbGV0IGRlcHRoTGF5ZXJzID0gdGhpcy5fcGF0aENvbnRhaW5lclxuICAgICAgLnNlbGVjdEFsbCgnZy5kZXB0aExheWVyID4gZy5jbGlwTGF5ZXInKVxuICAgICAgLmRhdGEoc3RyZWFtc0J5RGVwdGgsIGQgPT4gdGhpcy5fbmFtZSArIHRoaXMuX2RhdGFzZXRzTG9hZGVkICsgZC5rZXkpXG4gICAgICAuam9pbihlbnRlciA9PlxuICAgICAgICBlbnRlclxuICAgICAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgICAgIC5jbGFzc2VkKCdkZXB0aExheWVyJywgdHJ1ZSlcbiAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkZXB0aC0nICsgZC5rZXkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgLmNsYXNzZWQoJ2NsaXBMYXllcicsIHRydWUpXG4gICAgICApO1xuXG4gICAgLy8gLmF0dHIoJ2NsaXAtcGF0aCcsIGQgPT4gJ3VybCgjY2xpcCcgKyBkLmtleSArICd3cmFwcGVyKScpO1xuXG4gICAgZGVwdGhMYXllcnNcbiAgICAgIC5zZWxlY3RBbGwoJ3BhdGguc3RyZWFtJylcbiAgICAgIC5kYXRhKGQgPT4gZC52YWx1ZXMsIGQgPT4gdGhpcy5fbmFtZSArIHRoaXMuX2RhdGFzZXRzTG9hZGVkICsgZC5pZClcbiAgICAgIC5qb2luKGVudGVyID0+XG4gICAgICAgIGVudGVyXG4gICAgICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgLmNsYXNzZWQoJ3N0cmVhbScsIHRydWUpXG4gICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCB0aGlzLl9vbk1vdXNlT3ZlcilcbiAgICAgICAgICAub24oJ21vdXNlb3V0JywgdGhpcy5fb25Nb3VzZU91dClcbiAgICAgICAgICAuYXR0cignY2xpcC1wYXRoJywgZCA9PiAndXJsKCNjbGlwJyArIGQuaWQgKyB0aGlzLl9uYW1lICsgJyknKVxuICAgICAgICAgIC5hdHRyKCdpZCcsIGQgPT4gJ3N0cmVhbScgKyBkLmlkICsgdGhpcy5fbmFtZSlcbiAgICAgICAgICAvLy5hdHRyKCdzdHJva2Utd2lkdGgnLCAzKVxuICAgICAgICAgIC5hdHRyKCdwYWludC1vcmRlcicsICdzdHJva2UnKVxuICAgICAgKVxuICAgICAgLmF0dHIoJ2QnLCBkID0+IGQucGF0aClcbiAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCB0aGlzLl9vcHRzLnNoYXBlUmVuZGVyaW5nKVxuICAgICAgLmF0dHIoXG4gICAgICAgICdmaWxsJyxcbiAgICAgICAgZCA9PiAoISFkLmRhdGEgPyBkLmRhdGEuY29sb3IgOiBudWxsKSB8fCBjb2xvcihkLmRlZXBlc3REZXB0aClcbiAgICAgICAgLy8gJ3doaXRlJ1xuICAgICAgKVxuICAgICAgLmF0dHIoXG4gICAgICAgICdmaWxsLW9wYWNpdHknLFxuICAgICAgICB0aGlzLl9vcHRzLnRyYW5zcGFyZW50Um9vdCA/IGQgPT4gKGQuaWQgPT0gJ2Zha2VSb290JyA/IDAgOiAxKSA6IDFcbiAgICAgIClcbiAgICAgIC8vIHJlbW92ZSBlbXB0eSBzdHJlYW1zICh0aGV5IGRvIG5vdCBpbmNsdWRlIGEgc2luZ2xlIGJlemllciBjdXJ2ZSlcbiAgICAgIC5maWx0ZXIoZCA9PiBkLnBhdGguaW5kZXhPZignQycpID09IC0xKVxuICAgICAgLnJlbW92ZSgpO1xuXG4gICAgdGhpcy5zaG93TGFiZWxzKHRoaXMuX29wdHMuc2hvd0xhYmVscyk7XG4gICAgdGhpcy5kcmF3U3Ryb2tlKHRoaXMuX29wdHMuZHJhd1N0cm9rZSk7XG5cbiAgICBsZXQgc3BsaXREYXRhID0gdGhpcy5fc3ZnRmlsdGVyc1xuICAgICAgLnNlbGVjdEFsbCgnY2xpcFBhdGgnKVxuICAgICAgLmRhdGEoXG4gICAgICAgIHRoaXMuX3N0cmVhbURhdGEuY2xpcFBhdGhzLFxuICAgICAgICBkID0+IHRoaXMuX25hbWUgKyB0aGlzLl9kYXRhc2V0c0xvYWRlZCArIGQuaWRcbiAgICAgICk7XG5cbiAgICBzcGxpdERhdGFcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAuYXR0cignaWQnLCBkID0+ICdjbGlwJyArIGQuaWQgKyB0aGlzLl9uYW1lKVxuICAgICAgLm1lcmdlKHNwbGl0RGF0YSlcbiAgICAgIC5odG1sKGQgPT4gJzxwYXRoIGQ9XCInICsgZC5wYXRoICsgJ1wiPicpO1xuXG4gICAgc3BsaXREYXRhLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIHRoaXMuX2FwcGx5RmlsdGVycygpO1xuICB9XG5cbiAgX2RyYXdBeGVzKCkge1xuICAgIHRoaXMuX2F4ZXNDb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gICAgbGV0IHsgYXhlcywgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcy5fb3B0cztcbiAgICBpZiAoYXhlcykge1xuICAgICAgZm9yIChsZXQgYXhpcyBvZiBheGVzKSB7XG4gICAgICAgIGF4aXMuc3VidGlja3MgPSBheGlzLnN1YnRpY2tzIHx8IDA7XG4gICAgICAgIGF4aXMubmFtZSA9ICdheGlzJyArIGF4aXMucG9zaXRpb247XG4gICAgICAgIGxldCB0b3RhbFRpY2tzID0gYXhpcy50aWNrcyAqICgxICsgYXhpcy5zdWJ0aWNrcyk7XG4gICAgICAgIGxldCBkaXJZID0gYXhpcy5wb3NpdGlvbiA9PSAnbGVmdCcgfHwgYXhpcy5wb3NpdGlvbiA9PSAncmlnaHQnO1xuXG4gICAgICAgIGxldCBheGlzQ29uID0gdGhpcy5fYXhlc0NvbnRhaW5lci5hcHBlbmQoJ2cnKS5jbGFzc2VkKGF4aXMubmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgbGV0IGQzYXhpcztcbiAgICAgICAgaWYgKGF4aXMucG9zaXRpb24gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgZDNheGlzID0gZDMuYXhpc0xlZnQodGhpcy5fc3RyZWFtRGF0YS55U2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXMucG9zaXRpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGQzYXhpcyA9IGQzLmF4aXNSaWdodCh0aGlzLl9zdHJlYW1EYXRhLnlTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpcy5wb3NpdGlvbiA9PSAndG9wJykge1xuICAgICAgICAgIGQzYXhpcyA9IGQzLmF4aXNUb3AodGhpcy5fc3RyZWFtRGF0YS54U2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXMucG9zaXRpb24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBkM2F4aXMgPSBkMy5heGlzQm90dG9tKHRoaXMuX3N0cmVhbURhdGEueFNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3RhbFRpY2tzKSBkM2F4aXMudGlja3ModG90YWxUaWNrcyk7XG4gICAgICAgIC8vIGRvIG5vdCBsYWJlbCBzdWJ0aWNrc1xuICAgICAgICBkM2F4aXMudGlja0Zvcm1hdCgoZCwgaSkgPT4gKCEoaSAlICgxICsgYXhpcy5zdWJ0aWNrcykpID8gZCA6IG51bGwpKTtcblxuICAgICAgICBpZiAoYXhpcy50aWNrU2l6ZSA9PSAnZnVsbCcpIHtcbiAgICAgICAgICBsZXQgdGlja1NpemUgPSBkaXJZID8gd2lkdGggOiBoZWlnaHQ7XG4gICAgICAgICAgZDNheGlzLnRpY2tTaXplKHRpY2tTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF4aXNDb24uY2FsbChkM2F4aXMpO1xuXG4gICAgICAgIC8vIG1vdmUgbGFiZWxzXG4gICAgICAgIGxldCB0ZXh0ID0gYXhpc0Nvbi5zZWxlY3RBbGwoJy50aWNrIHRleHQnKTtcbiAgICAgICAgaWYgKGF4aXMudGV4dFBvcylcbiAgICAgICAgICB0ZXh0LmF0dHIoJ3gnLCBheGlzLnRleHRQb3NbMF0pLmF0dHIoJ3knLCBheGlzLnRleHRQb3NbMV0pO1xuXG4gICAgICAgIGlmIChheGlzLnRleHRTaXplKSB0ZXh0LmF0dHIoJ2ZvbnQtc2l6ZScsIGF4aXMudGV4dFNpemUpO1xuXG4gICAgICAgIGlmIChheGlzLnRleHRBbmNob3IpIHRleHQuYXR0cigndGV4dC1hbmNob3InLCBheGlzLnRleHRBbmNob3IpO1xuXG4gICAgICAgIGlmIChheGlzLnRleHRCYXNlKSB0ZXh0LmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgYXhpcy50ZXh0QmFzZSk7XG5cbiAgICAgICAgYXhpc0Nvbi5zZWxlY3QoJy5kb21haW4nKS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzaG93TGFiZWxzKHNob3cgPSB0cnVlKSB7XG4gICAgdGhpcy5fb3B0cy5zaG93TGFiZWxzID0gc2hvdztcbiAgICBsZXQgbGFiZWxEYXRhID0gdGhpcy5fb3B0cy5zaG93TGFiZWxzID8gdGhpcy5fc3RyZWFtRGF0YS5zdHJlYW1zIDogW107XG5cbiAgICBsZXQgbGFiZWxzID0gdGhpcy5fdGV4dENvbnRhaW5lclxuICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAuZGF0YShsYWJlbERhdGEsIGQgPT4gZC5pZCk7XG5cbiAgICBsYWJlbHNcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgIC50ZXh0KGQgPT4gKCEhZC5kYXRhID8gZC5kYXRhLnR5cGVMYWJlbCA6IGQuaWQpKVxuICAgICAgLm1lcmdlKGxhYmVscylcbiAgICAgIC5hdHRyKCd4JywgZCA9PiBkLnRleHRQb3MueClcbiAgICAgIC5hdHRyKCd5JywgZCA9PiBkLnRleHRQb3MueSk7XG5cbiAgICBsYWJlbHMuZXhpdCgpLnJlbW92ZSgpO1xuICB9XG5cbiAgZHJhd1N0cm9rZShkcmF3ID0gdHJ1ZSkge1xuICAgIHRoaXMuX29wdHMuZHJhd1N0cm9rZSA9IGRyYXc7XG4gICAgbGV0IGNvbG9yID0gdGhpcy5fb3B0cy5kcmF3U3Ryb2tlID8gJ2JsYWNrJyA6IG51bGw7XG4gICAgdGhpcy5fcGF0aENvbnRhaW5lci5hdHRyKCdzdHJva2UnLCBjb2xvcik7XG4gICAgdGhpcy5fcGF0aENvbnRhaW5lci5hdHRyKCdzdHJva2Utd2lkdGgnLCAzKTtcbiAgICAvLyBkMy5zZWxlY3RBbGwoJ3BhdGgnKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjAwMSlcbiAgfVxuXG4gIF9hcHBseUZpbHRlcnMoKSB7XG4gICAgaWYgKCF0aGlzLl9maWx0ZXJzKSByZXR1cm47XG5cbiAgICBsZXQgZmlsdGVycyA9IFtdO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiB0aGlzLl9maWx0ZXJzKVxuICAgICAgZmlsdGVycy5wdXNoKGZpbHRlci50eXBlLCB7XG4gICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICBkeDogZmlsdGVyLmR4LFxuICAgICAgICBkeTogZmlsdGVyLmR5LFxuICAgICAgICBibHVyOiBmaWx0ZXIuc3RkRGV2aWF0aW9uXG4gICAgICB9KTtcblxuICAgIGlmICh0aGlzLl9vcHRzLmZpbHRlck1vZGUgPT0gJ2Zhc3QnKVxuICAgICAgZDMuc2VsZWN0QWxsKCcuZGVwdGhMYXllcicpLnN2Z0ZpbHRlciguLi5maWx0ZXJzKTtcbiAgICBlbHNlIGlmICh0aGlzLl9vcHRzLmZpbHRlck1vZGUgPT0gJ2FjY3VyYXRlJylcbiAgICAgIGQzLnNlbGVjdEFsbCgncGF0aC5zdHJlYW0nKS5zdmdGaWx0ZXIoLi4uZmlsdGVycyk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICB9XG4gIF91cGRhdGUobWFudWFsbHlUcmlnZ2VyZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5fZGF0YSkgcmV0dXJuO1xuXG4gICAgaWYgKCF0aGlzLl9vcHRzLmF1dG9tYXRpY1VwZGF0ZSkgaWYgKCFtYW51YWxseVRyaWdnZXJlZCkgcmV0dXJuO1xuXG4gICAgLy8gY29uc29sZS5sb2coJ3VwZGF0ZScpO1xuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplRGF0YSgpO1xuICAgIHRoaXMuX2FwcGx5T3JkZXJpbmcoKTtcbiAgICB0aGlzLl9jYWxjdWxhdGVQb3NpdGlvbnMoKTtcblxuICAgIC8vIHRoaXMuX3N0cmVhbURhdGEucHJlcHJvY2VzcygpO1xuICAgIHRoaXMuX3N0cmVhbURhdGEuY2FsY3VsYXRlUGF0aHMoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgLy8gY29uc29sZS5sb2coXG4gICAgLy8gICAnVElNSU5HOiAnICsgdGhpcy5fZGF0YS5udW1Ob2RlcyArICcsJyArIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxuICAgIC8vICk7XG4gIH1cblxuICByZXNpemUoXG4gICAgd2lkdGggPSB0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodFxuICApIHtcbiAgICB0aGlzLl9vcHRzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fb3B0cy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fc3ZnLmF0dHIoJ3dpZHRoJywgd2lkdGgpLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIHlTcGFjaW5nRml4ZWQobm9kZSkge1xuICAgIHJldHVybiB0aGlzLl9vcHRzLnlNYXJnaW4gLyA0O1xuICB9XG5cbiAgeVNwYWNpbmdQZXJjZW50YWdlKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLnkxIC0gbm9kZS55MCkgKiB0aGlzLl9vcHRzLnlNYXJnaW4pIC8gMjtcbiAgfVxuXG4gIHlTcGFjaW5nSGllcmFyY2hpY2FsKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLmRlcHRoICsgMSkgKiB0aGlzLl9vcHRzLnlNYXJnaW4pIC8gNDtcbiAgfVxuXG4gIHlTcGFjaW5nSGllcmFyY2hpY2FsUmV2ZXJzZShub2RlKSB7XG4gICAgcmV0dXJuICgoMSAvIChub2RlLmRlcHRoICsgMSkpICogdGhpcy5fb3B0cy55TWFyZ2luKSAvIDQ7XG4gIH1cblxuICB4U3BhY2luZ0ZpeGVkKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0cy54TWFyZ2luIC8gMTA7XG4gIH1cblxuICAvLyBUT0RPOiB1c2UgdGhlIG1heCBkZXB0aCBhdCB0aGF0IHRpbWVwb2ludCBpbnN0ZWFkXG4gIHhTcGFjaW5nSGllcmFyY2hpY2FsKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLmRlcHRoICsgMSkgLyB0aGlzLl9tYXhEZXB0aCkgKiB0aGlzLl9vcHRzLnhNYXJnaW47XG4gIH1cblxuICB4U3BhY2luZ0hpZXJhcmNoaWNhbFJldmVyc2Uobm9kZSkge1xuICAgIHJldHVybiAoMSAvIChub2RlLmRlcHRoICsgMSkpICogdGhpcy5fb3B0cy54TWFyZ2luO1xuICB9XG5cbiAgYWRkU3BsaXRzKHNwbGl0cykge1xuICAgIHRoaXMuX3N0cmVhbURhdGEuYWRkU3BsaXRzKHNwbGl0cyk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBhZGRTcGxpdHNBdFRpbWVwb2ludHMoKSB7XG4gICAgbGV0IHNwbGl0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9taW5UaW1lOyBpIDw9IHRoaXMuX21heFRpbWU7IGkrKykgc3BsaXRzLnB1c2goaSk7XG4gICAgdGhpcy5hZGRTcGxpdHMoc3BsaXRzKTtcbiAgfVxuXG4gIGFkZFNwbGl0c0JldHdlZW5UaW1lcG9pbnRzKCkge1xuICAgIGxldCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5fbWluVGltZSAtIDE7IGkgPD0gdGhpcy5fbWF4VGltZTsgaSsrKVxuICAgICAgc3BsaXRzLnB1c2goaSArIDAuNSk7XG4gICAgdGhpcy5hZGRTcGxpdHMoc3BsaXRzKTtcbiAgfVxuXG4gIGFkZFNwbGl0c1JhbmRvbWx5KG51bSA9IDEpIHtcbiAgICBsZXQgdDAgPSB0aGlzLl9taW5UaW1lIC0gMTtcbiAgICBsZXQgdDEgPSB0aGlzLl9tYXhUaW1lICsgMTtcbiAgICBsZXQgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgbGV0IHIgPSB0MCArIE1hdGgucmFuZG9tKCkgKiAodDEgLSB0MCk7XG4gICAgICBzcGxpdHMucHVzaChyLnRvU3RyaW5nKCkpO1xuICAgICAgc3BsaXRzLnNvcnQoKTtcbiAgICB9XG4gICAgdGhpcy5hZGRTcGxpdHMoc3BsaXRzKTtcbiAgfVxuXG4gIHJlbW92ZVNwbGl0cyhzcGxpdHMpIHtcbiAgICB0aGlzLl9zdHJlYW1EYXRhLnJlbW92ZVNwbGl0cyhzcGxpdHMpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgLy8gc3RhdGljIGV4dGVuZCguLi5hcmdzKSB7XG4gIC8vICAgICB0aGlzLm15TmV3RnVuY3Rpb25cbiAgLy8gfVxuICAvLyBleHRlbmQoLi4uYXJncykge1xuICAvLyAgICAgcmV0dXJuIFNwbGl0U3RyZWFtLmV4dGVuZCguLi5hcmdzKTtcbiAgLy8gfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/SplitStream.js\n"
          );

          /***/
        },

      /***/ './src/SplitStreamData.js':
        /*!********************************!*\
  !*** ./src/SplitStreamData.js ***!
  \********************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStreamData; });\n/* harmony import */ var _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SvgPath.js */ \"./src/SvgPath.js\");\n\n\nclass SplitStreamData {\n  // array of streams\n  // every stream has a unique ID\n  // every stream contains references to all nodes which belong to that stream\n\n  // if parent never changes, draw stream after parent\n  // if parent changes, draw after both parents.\n  // if special case, split path in 2 and draw before and after\n  constructor() {\n    this._streamNodes = [];\n    this._streams = [];\n    this._splits = {};\n    this._xScale = d => d;\n    this._yScale = d => d;\n    this._proportion = 1;\n\n    this._xCurve = 'bezier'; // linear, bezier\n    this._startEnd = {\n      encoding: 'plug', // circle, plug, default\n      x: 0.85,\n      y: 0\n    };\n  }\n\n  get streams() {\n    return this._streams;\n  }\n  get clipPaths() {\n    return this._clipPaths;\n  }\n  get splits() {\n    return Object.keys(this._splits);\n  }\n\n  set xScale(callback) {\n    this._xScale = callback;\n  }\n  set yScale(callback) {\n    this._yScale = callback;\n  }\n  get xScale() {\n    return this._xScale;\n  }\n  get yScale() {\n    return this._yScale;\n  }\n\n  set startEndEncoding(encoding) {\n    this._startEnd.encoding = encoding;\n  }\n  set startEndEncodingX(x) {\n    this._startEnd.x = x;\n  }\n  set startEndEncodingY(y) {\n    this._startEnd.y = y;\n  }\n  set proportion(p) {\n    this._proportion = p;\n  }\n\n  add(node) {\n    this._streamNodes.push(node);\n  }\n\n  // extract special operations (splits, merges, parentSwap) from the data and treat it extra\n  preprocess() {\n    let mergeNodes = [];\n    let splitNodes = [];\n    let parentSwaps = [];\n    let newStreams = [];\n\n    // cut connection between node and previous nodes\n    let cutPrevious = node => {\n      if (!!node.prev) {\n        for (let prev of node.prev) {\n          if (prev.next.length == 1) prev.next = undefined;\n          else prev.next.splice(prev.next.indexOf(node), 1);\n        }\n      }\n    };\n\n    // cut connection between node and next nodes\n    let cutNext = node => {\n      if (!!node.next) {\n        for (let next of node.next) {\n          if (next.prev.length == 1) next.prev = undefined;\n          else next.prev.splice(next.prev.indexOf(node), 1);\n        }\n      }\n    };\n\n    let traverse = node => {\n      if (!!node.next) for (let next of node.next) traverse(next);\n\n      // split nodes\n      if (!!node.next && node.next.length > 1) {\n        splitNodes.push(node);\n        cutNext(node);\n        // create new streams from here\n        newStreams.push({ ...node.next });\n\n        // end stream here\n        node.next = undefined;\n      }\n\n      // merge nodes\n      if (!!node.prev && node.prev.length > 1) {\n        mergeNodes.push(node);\n        endPrevious(node);\n\n        node.prev = undefined;\n        this.newStreams.push(node);\n      }\n\n      // parent swap\n      if (!!node.next) {\n        for (let next of node.next) {\n          // only consider nodes whos parents change\n          // 1. node becomes root node (parent changes from defined to undefined)\n          // 2. parent id changes (TODO: make sure that this case is not handled twice, because both node's parents change)\n          if (\n            (!node.parent && !!next.parent) ||\n            (!!node.parent && !!next.parent && node.parent.id != next.parent.id)\n          ) {\n            // check if next.parent had node as an ancestor in the previous step\n\n            if (!!next.parent.prev) {\n              for (let prev of next.parent.prev) {\n                let isAncestor = false;\n                let p = prev;\n                while (p && !isAncestor) {\n                  if (p.id == node.id) isAncestor = true;\n                  else p = p.parent;\n                }\n                if (isAncestor) {\n                  endPrevious(prev);\n                  if (!!prev.next) addFollowing(prev.next);\n                  parentSwaps.push({\n                    node: { ...prev },\n                    next: { ...next.parent }\n                  });\n                  prev.next = undefined;\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // draw special case for node \"p\" and all its children, as well as node\n\n    // loop in reverse, because elements are added and deleted\n    for (let i = this._streamNodes.length - 1; i >= 0; i--) {\n      traverse(this._streamNodes[i]);\n    }\n  }\n\n  clear() {\n    this._streamNodes = [];\n    this._streams = [];\n    this._clipPaths = [];\n  }\n\n  addSplits(splits) {\n    if (Array.isArray(splits))\n      splits.forEach(d => {\n        this._splits[d] = true;\n      });\n    else this._splits[d] = true;\n  }\n\n  removeSplits(splits) {\n    if (!splits) this._splits = {};\n    else\n      splits.forEach(d => {\n        this._splits[d].remove();\n      });\n  }\n\n  //TODO: find more elaborate solution\n  _findSplits(t0, t1) {\n    let splits = [];\n    for (let split in this._splits) {\n      if (split >= t0 && split <= t1) splits.push(+split);\n    }\n    return splits;\n  }\n\n  _findClosestNode(stream, x) {\n    let traverseTime = function(node) {\n      let distance = Math.abs(node.x - x);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestNode = node;\n        // if distance is greater than minDistance, it will only increase with following nodes\n        if (!!node.next) {\n          node.next.forEach(traverseTime);\n        }\n      }\n    };\n    let minDistance = Infinity;\n    let closestNode;\n    traverseTime(stream);\n    return closestNode;\n  }\n\n  // WARNING: work in process\n  _checkForNullStreams() {\n    for (let i = 0; i < this._streamNodes.length; i++) {\n      let isNull = true;\n\n      let traverse = node => {\n        if (node.y1 - node.y0 > 0) {\n          isNull = false;\n          return;\n        }\n\n        if (!!node.next) node.next.forEach(traverse);\n      };\n\n      traverse(this._streamNodes[i]);\n\n      if (isNull) {\n        delete this._streamNodes[i]; //delete stream;\n        i--;\n      }\n    }\n  }\n\n  _drawStart(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    // extend to left\n    d.move(x(node.x), y(node.y1));\n\n    // don't draw start for zero values\n    if (node.y1 - node.y0 <= 0) return;\n\n    let t = node.x - 0.5 * (1 - prop);\n    d.horizontal(x(t));\n\n    // connect top and bottom\n    let root = node;\n    while (!!root.parent) root = root.parent;\n\n    if (!root.prev) {\n      // make first timestep flat\n      d.vertical(y(node.y0));\n    } else {\n      if (this._startEnd.encoding == 'circle') this._drawStartCircle(d, node);\n      else if (this._startEnd.encoding == 'plug') this._drawStartPlug(d, node);\n      else this._drawStartDefault(d, node);\n    }\n\n    // connect back\n    d.horizontal(x(node.x));\n  }\n\n  _drawEnd(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    if (node.y1 - node.y0 <= 0) return;\n\n    // extend to right\n    let t = node.x + 0.5 * (1 - prop);\n    d.horizontal(x(t));\n\n    // connect bottom and top\n    let root = node;\n    while (!!root.parent) root = root.parent;\n    if (!root.next) {\n      // make last timestep flat\n      d.vertical(y(node.y1));\n    } else {\n      if (this._startEnd.encoding == 'circle') this._drawEndCircle(d, node);\n      else if (this._startEnd.encoding == 'plug') this._drawEndPlug(d, node);\n      else this._drawEndDefault(d, node);\n    }\n\n    // connect back\n    d.horizontal(x(node.x));\n  }\n\n  _drawStartDefault(path, node) {\n    // insert node\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    // find position to insert node\n    let pos;\n    // find the oldest parent of node, which does not exist in the previous step\n    let parentNoPrev = node;\n    while (!!parentNoPrev.parent && !parentNoPrev.parent.prev)\n      parentNoPrev = parentNoPrev.parent;\n\n    // p is an ancestor who existed in the previous timestep\n    let p = parentNoPrev.parent;\n    if (!p) {\n      d.vertical(y(node.y0));\n    } else {\n      // use the center of the stream as reference point\n      let mid = 0.5 * (parentNoPrev.y0 + parentNoPrev.y1);\n\n      // if the nodes parent has multiple previous nodes, find the one closest to mid\n      let refPrevId = -1;\n      for (let n = 0; n < p.prev.length && refPrevId == -1; n++) {\n        let prev = p.prev[n];\n        // if mid lies within a prev node\n        if (prev.y0 <= mid && prev.y1 >= mid) {\n          // if node has children\n          if (!!prev.children && prev.children.length > 0) {\n            let refChildId = -1; // find two children to put the mid in between\n            for (let i = 0; i < prev.children.length && refChildId == -1; i++) {\n              let child = prev.children[i];\n              if (mid <= 0.5 * (child.y0 + child.y1)) refChildId = i; // setting ID breaks the loop\n            }\n            if (refChildId == 0)\n              // before first child\n              pos = 0.5 * (prev.y0 + prev.children[0].y0);\n            else if (refChildId == -1)\n              // after last child\n              pos =\n                0.5 * (prev.y1 + prev.children[prev.children.length - 1].y1);\n            else\n              pos =\n                0.5 *\n                (prev.children[refChildId - 1].y1 +\n                  prev.children[refChildId].y0);\n          } // node has no children\n          else pos = 0.5 * (prev.y0 + prev.y1);\n          refPrevId = -2; // setting ID breaks the loop\n        }\n        // if it lies outside, find two nodes to put it inbetween\n        else {\n          if (mid <= 0.5 * (prev.y0 + prev.y1)) refPrevId = n; // setting ID breaks the loop\n        }\n      }\n\n      if (refPrevId != -2) {\n        // if -2, then pos was already set\n        let node; // define the node to draw inside\n        let first; // boolean to define if it should be drawn before the first or after the last child\n        if (refPrevId == 0) {\n          // before first child\n          node = p.prev[0];\n          first = true;\n        } else if (refPrevId == -1) {\n          // after last child\n          node = p.prev[p.prev.length - 1];\n          first = false;\n        } else {\n          // find which node is closer\n          if (\n            Math.abs(p.prev[refPrevId].y0 - mid) <\n            Math.abs(p.prev[refPrevId - 1].y1)\n          ) {\n            node = p.prev[refPrevId];\n            first = true;\n          } else {\n            node = p.prev[refPrevId - 1];\n            first = false;\n          }\n        }\n\n        if (!!node.children && node.children.length > 0) {\n          if (first) pos = 0.5 * (node.y0 + node.children[0].y0);\n          else\n            pos = 0.5 * (node.y1 + node.children[node.children.length - 1].y1);\n        } else pos = 0.5 * (node.y0 + node.y1);\n      }\n\n      let tdiff = node.x - p.prev[0].x;\n      let t0 = node.x - 0.5 * (1 - prop) * tdiff;\n      let t1 = t0 - 0.5 * prop * tdiff;\n\n      if (this._xCurve == 'linear') {\n        d.line(x(p.prev[0].x), y(pos));\n        d.line(x(t0), y(node.y0));\n      } else if (this._xCurve == 'bezier') {\n        d.bezier(x(t1), y(node.y1), x(t1), y(pos), x(p.prev[0].x), y(pos));\n        d.bezier(x(t1), y(pos), x(t1), y(node.y0), x(t0), y(node.y0));\n      }\n    }\n  }\n\n  _drawEndDefault(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    // find position to delete node to\n    let pos;\n    // find the oldest parent of node, which does not exist in the next step\n    let parentNoNext = node;\n    while (!!parentNoNext.parent && !parentNoNext.parent.next)\n      parentNoNext = parentNoNext.parent; // p is the oldest parent of node, which does not exist in the next step\n\n    // p is an ancestor who exists in the next timestep\n    let p = parentNoNext.parent;\n    if (!p) {\n      d.vertical(y(node.y1));\n    } else {\n      // use the center of the stream as reference point\n      let mid = 0.5 * (parentNoNext.y0 + parentNoNext.y1);\n      // if the nodes parent has multiple next nodes, find the one closest to mid\n      let refNextId = -1;\n      for (let n = 0; n < p.next.length && refNextId == -1; n++) {\n        let next = p.next[n];\n        // if mid lies within a next node\n        if (next.y0 <= mid && next.y1 >= mid) {\n          // if node has children\n          if (!!next.children && next.children.length > 0) {\n            let refChildId = -1; // find two children to put the mid in between\n            for (let i = 0; i < next.children.length && refChildId == -1; i++) {\n              let child = next.children[i];\n              if (mid <= 0.5 * (child.y0 + child.y1)) refChildId = i; // setting ID breaks the loop\n            }\n            if (refChildId == 0)\n              // before first child\n              pos = 0.5 * (next.y0 + next.children[0].y0);\n            else if (refChildId == -1)\n              // after last child\n              pos =\n                0.5 * (next.y1 + next.children[next.children.length - 1].y1);\n            else\n              pos =\n                0.5 *\n                (next.children[refChildId - 1].y1 +\n                  next.children[refChildId].y0);\n          } // node has no children\n          else pos = 0.5 * (next.y0 + next.y1);\n          refNextId = -2; // setting ID breaks the loop\n        }\n        // if it lies outside, find two nodes to put it inbetween\n        else {\n          if (mid <= 0.5 * (next.y0 + next.y1)) refNextId = n; // setting ID breaks the loop\n        }\n      }\n\n      if (refNextId != -2) {\n        // if -2, then pos was already set\n        let node; // define the node to draw inside\n        let first; // boolean to define if it should be drawn before the first or after the last child\n        if (refNextId == 0) {\n          // before first child\n          node = p.next[0];\n          first = true;\n        } else if (refNextId == -1) {\n          // after last child\n          node = p.next[p.next.length - 1];\n          first = false;\n        } else {\n          // find which node is closer\n          if (\n            Math.abs(p.next[refNextId].y0 - mid) <\n            Math.abs(p.next[refNextId - 1].y1)\n          ) {\n            node = p.next[refNextId];\n            first = true;\n          } else {\n            node = p.next[refNextId - 1];\n            first = false;\n          }\n        }\n\n        if (!!node.children && node.children.length > 0) {\n          if (first) pos = 0.5 * (node.y0 + node.children[0].y0);\n          else\n            pos = 0.5 * (node.y1 + node.children[node.children.length - 1].y1);\n        } else pos = 0.5 * (node.y0 + node.y1);\n      }\n\n      let tdiff = p.next[0].x - node.x;\n      let t0 = node.x + 0.5 * (1 - prop) * tdiff;\n      let t1 = t0 + 0.5 * prop * tdiff;\n\n      if (this._xCurve == 'linear') {\n        d.line(x(p.next[0].x), y(pos));\n        d.line(x(t0), y(node.y1));\n      } else if (this._xCurve == 'bezier') {\n        d.bezier(x(t1), y(node.y0), x(t1), y(pos), x(p.next[0].x), y(pos));\n        d.bezier(x(t1), y(pos), x(t1), y(node.y1), x(t0), y(node.y1));\n      }\n    }\n  }\n\n  _drawStartCircle(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let height = node.y1 - node.y0;\n    let t = node.x - 0.5 * (1 - prop);\n    d.move(x(t), y(node.y1));\n    //d.arc(Math.log(height), 1, 0, 0, 0, x(node.x), y(node.y0));\n    d.arc(prop, 1, 0, 0, 0, x(t), y(node.y0));\n  }\n\n  _drawEndCircle(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let height = node.y1 - node.y0;\n    let t = node.x + 0.5 * (1 - prop);\n    //d.arc(Math.log(height), 1, 0, 0, 0, x(node.x), y(node.y1));\n    d.arc(prop, 1, 0, 0, 0, x(t), y(node.y1));\n  }\n\n  _drawStartPlug(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let t = node.x - 0.5 * (1 - prop);\n    let height = node.y1 - node.y0;\n    d.bezier(\n      x(t - prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y1 + this._startEnd.y * height),\n      x(t - prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y0 - this._startEnd.y * height),\n      x(t),\n      y(node.y0)\n    );\n  }\n\n  _drawEndPlug(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let t = node.x + 0.5 * (1 - prop);\n    let height = node.y1 - node.y0;\n    d.bezier(\n      x(t + prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y0 - this._startEnd.y * height),\n      x(t + prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y1 + this._startEnd.y * height),\n      x(t),\n      y(node.y1)\n    );\n  }\n\n  calculatePaths() {\n    //this._checkForNullStreams();\n\n    const prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n    let d, lastTimepoint, deepestDepth, largestSize; // find the deepest depth each stream has over the whole timeseries\n\n    let drawLine = (t1, t2, t3, ySource, yDest) => {\n      let t12 = 0.5 * (t1 + t2); // mid between t1 and t2\n      d.horizontal(t1);\n      if (this._xCurve == 'linear') {\n        d.line(t2, y(yDest));\n      } else if (this._xCurve == 'bezier') {\n        d.bezier(t12, y(ySource), t12, y(yDest), t2, y(yDest));\n      }\n      d.horizontal(t3);\n    };\n\n    let traverse = node => {\n      if (node.x > lastTimepoint) lastTimepoint = node.x;\n\n      if (node.depth > deepestDepth) deepestDepth = node.depth;\n      if (node.size > largestSize) largestSize = node.size;\n\n      if (!!node.next) {\n        let dt = node.next[0].x - node.x;\n        let t0 = x(node.x);\n        let t1 = x(node.x + 0.5 * (1 - prop) * dt);\n        let t2 = x(node.next[0].x - 0.5 * (1 - prop) * dt);\n        let t3 = x(node.next[0].x);\n\n        let y0 = node.y0;\n        let y1 = node.y1;\n\n        for (let i = 0; i < node.next.length; i++) {\n          let dest = node.next[i];\n          // don't draw anything for streams with zero height\n          if (y1 - y0 <= 0 && dest.y1 - dest.y0 <= 0) {\n            d.move(t3, y(dest.y0));\n            traverse(dest);\n            d.move(t0, y(y0));\n          } else {\n            drawLine(t1, t2, t3, y0, dest.y0); // bottom line (forwards)\n            traverse(dest);\n            drawLine(t2, t1, t0, dest.y1, y1); // top line (backwards)\n          }\n          // if dest is one of the nodes where the split occured, we need to draw a line back to our starting point\n          if (node.next.length > 1 && i < node.next.length - 1)\n            d.vertical(y(y0));\n        }\n      } else this._drawEnd(d, node);\n    };\n\n    for (let stream of this._streamNodes) {\n      d = new _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      // reset before new values are found by traverse\n      lastTimepoint = 0;\n      deepestDepth = 0;\n      largestSize = 0;\n\n      this._drawStart(d, stream);\n      traverse(stream);\n      //d.close();\n\n      // add splits\n\n      let clipPath = new _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      let splits = this._findSplits(stream.x - 0.5, lastTimepoint + 0.5);\n\n      let clipStart = x(-1);\n      let y0 = y(0);\n      let y1 = y(1);\n      for (let split of splits) {\n        // we move by 0.0001 to avoid cases in which the split is in the middle of 2 nodes\n        let clipEnd = x(\n          split - 0.5 * this._findClosestNode(stream, split - 0.0001).marginX\n        );\n\n        if (clipEnd - clipStart > 0) {\n          clipPath.move(clipStart, y0);\n          clipPath.horizontal(clipEnd);\n          clipPath.vertical(y1);\n          /*let dist = y1-y0;\n          let zigzags = 300;\n          let zigzagWidth = 5;\n          for (let z = 0; z < zigzags; z++) {\n              let dir = (z % 2 * 2 - 1);\n              clipPath.lineD(dir * zigzagWidth, dist/zigzags)\n          }*/\n\n          clipPath.horizontal(clipStart);\n          clipPath.vertical(y0);\n          /*for (let z = 0; z < zigzags; z++) {\n              let dir = (z % 2 * 2 - 1);\n              clipPath.lineD(dir * zigzagWidth, -dist/zigzags)\n          }*/\n        }\n        clipStart = x(\n          split + 0.5 * this._findClosestNode(stream, split + 0.0001).marginX\n        );\n      }\n      clipPath.move(clipStart, y0);\n      clipPath.horizontal(x(lastTimepoint + 1));\n      clipPath.vertical(y1);\n      clipPath.horizontal(clipStart);\n      clipPath.vertical(y0);\n\n      this._clipPaths.push({\n        id: stream.streamId,\n        path: clipPath.get()\n      });\n\n      // find position to put a text label\n      let textPos;\n      if (Math.abs(y(stream.y1) - y(stream.y0)) < 25) textPos = -1;\n      else {\n        if (y(stream.y1) > y(stream.y0)) textPos = y(stream.y0) + 15;\n        else textPos = y(stream.y1) + 15;\n      }\n\n      let streamObj = {\n        path: d.get(),\n        depth: stream.depth,\n        deepestDepth: deepestDepth,\n        largestSize: largestSize,\n        id: stream.streamId,\n        data: stream.data,\n        textPos: {\n          x: x(stream.x - 0.5 * (1 - this._proportion) + 0.5 * stream.marginX),\n          y: textPos\n        }\n      };\n\n      this._streams.push(streamObj);\n      // if (!this._streams[stream.depth])\n      //     this._streams[stream.depth] = [];\n      // this._streams[stream.depth].push(streamObj);\n    }\n\n    // WARNING: This was a fix for: \"if stream IDs are strings, the clipPath array has an empty value in the beginning --> remove\"\n    // But instead it just removes all clipPaths which have string as an ID\n    //this._clipPaths = this._clipPaths.filter(d => d);\n\n    // TODO: apply an order in which children are drawn correctly\n    // this._streams.sort((a,b) => (a.depth < b.depth) ? -1 : 1)\n    this._streams.sort((a, b) => (a.deepestDepth < b.deepestDepth ? -1 : 1));\n    //this._streams.sort((a,b) => a.id < b.id ? -1: 1)\n    //this._streams.reverse();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1EYXRhLmpzP2UwMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQW1DOztBQUVwQjtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywyQkFBMkIsOENBQThDO0FBQ3pFO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywyQkFBMkIsOENBQThDO0FBQ3pFO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsOENBQThDO0FBQzlDO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxjQUFjLG1EQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsbURBQU87QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL1NwbGl0U3RyZWFtRGF0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdmdQYXRoIGZyb20gJy4vU3ZnUGF0aC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0U3RyZWFtRGF0YSB7XG4gIC8vIGFycmF5IG9mIHN0cmVhbXNcbiAgLy8gZXZlcnkgc3RyZWFtIGhhcyBhIHVuaXF1ZSBJRFxuICAvLyBldmVyeSBzdHJlYW0gY29udGFpbnMgcmVmZXJlbmNlcyB0byBhbGwgbm9kZXMgd2hpY2ggYmVsb25nIHRvIHRoYXQgc3RyZWFtXG5cbiAgLy8gaWYgcGFyZW50IG5ldmVyIGNoYW5nZXMsIGRyYXcgc3RyZWFtIGFmdGVyIHBhcmVudFxuICAvLyBpZiBwYXJlbnQgY2hhbmdlcywgZHJhdyBhZnRlciBib3RoIHBhcmVudHMuXG4gIC8vIGlmIHNwZWNpYWwgY2FzZSwgc3BsaXQgcGF0aCBpbiAyIGFuZCBkcmF3IGJlZm9yZSBhbmQgYWZ0ZXJcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc3RyZWFtTm9kZXMgPSBbXTtcbiAgICB0aGlzLl9zdHJlYW1zID0gW107XG4gICAgdGhpcy5fc3BsaXRzID0ge307XG4gICAgdGhpcy5feFNjYWxlID0gZCA9PiBkO1xuICAgIHRoaXMuX3lTY2FsZSA9IGQgPT4gZDtcbiAgICB0aGlzLl9wcm9wb3J0aW9uID0gMTtcblxuICAgIHRoaXMuX3hDdXJ2ZSA9ICdiZXppZXInOyAvLyBsaW5lYXIsIGJlemllclxuICAgIHRoaXMuX3N0YXJ0RW5kID0ge1xuICAgICAgZW5jb2Rpbmc6ICdwbHVnJywgLy8gY2lyY2xlLCBwbHVnLCBkZWZhdWx0XG4gICAgICB4OiAwLjg1LFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICBnZXQgc3RyZWFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtcztcbiAgfVxuICBnZXQgY2xpcFBhdGhzKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGlwUGF0aHM7XG4gIH1cbiAgZ2V0IHNwbGl0cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3BsaXRzKTtcbiAgfVxuXG4gIHNldCB4U2NhbGUoY2FsbGJhY2spIHtcbiAgICB0aGlzLl94U2NhbGUgPSBjYWxsYmFjaztcbiAgfVxuICBzZXQgeVNjYWxlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5feVNjYWxlID0gY2FsbGJhY2s7XG4gIH1cbiAgZ2V0IHhTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5feFNjYWxlO1xuICB9XG4gIGdldCB5U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3lTY2FsZTtcbiAgfVxuXG4gIHNldCBzdGFydEVuZEVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgdGhpcy5fc3RhcnRFbmQuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgfVxuICBzZXQgc3RhcnRFbmRFbmNvZGluZ1goeCkge1xuICAgIHRoaXMuX3N0YXJ0RW5kLnggPSB4O1xuICB9XG4gIHNldCBzdGFydEVuZEVuY29kaW5nWSh5KSB7XG4gICAgdGhpcy5fc3RhcnRFbmQueSA9IHk7XG4gIH1cbiAgc2V0IHByb3BvcnRpb24ocCkge1xuICAgIHRoaXMuX3Byb3BvcnRpb24gPSBwO1xuICB9XG5cbiAgYWRkKG5vZGUpIHtcbiAgICB0aGlzLl9zdHJlYW1Ob2Rlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBzcGVjaWFsIG9wZXJhdGlvbnMgKHNwbGl0cywgbWVyZ2VzLCBwYXJlbnRTd2FwKSBmcm9tIHRoZSBkYXRhIGFuZCB0cmVhdCBpdCBleHRyYVxuICBwcmVwcm9jZXNzKCkge1xuICAgIGxldCBtZXJnZU5vZGVzID0gW107XG4gICAgbGV0IHNwbGl0Tm9kZXMgPSBbXTtcbiAgICBsZXQgcGFyZW50U3dhcHMgPSBbXTtcbiAgICBsZXQgbmV3U3RyZWFtcyA9IFtdO1xuXG4gICAgLy8gY3V0IGNvbm5lY3Rpb24gYmV0d2VlbiBub2RlIGFuZCBwcmV2aW91cyBub2Rlc1xuICAgIGxldCBjdXRQcmV2aW91cyA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCEhbm9kZS5wcmV2KSB7XG4gICAgICAgIGZvciAobGV0IHByZXYgb2Ygbm9kZS5wcmV2KSB7XG4gICAgICAgICAgaWYgKHByZXYubmV4dC5sZW5ndGggPT0gMSkgcHJldi5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGVsc2UgcHJldi5uZXh0LnNwbGljZShwcmV2Lm5leHQuaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY3V0IGNvbm5lY3Rpb24gYmV0d2VlbiBub2RlIGFuZCBuZXh0IG5vZGVzXG4gICAgbGV0IGN1dE5leHQgPSBub2RlID0+IHtcbiAgICAgIGlmICghIW5vZGUubmV4dCkge1xuICAgICAgICBmb3IgKGxldCBuZXh0IG9mIG5vZGUubmV4dCkge1xuICAgICAgICAgIGlmIChuZXh0LnByZXYubGVuZ3RoID09IDEpIG5leHQucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBlbHNlIG5leHQucHJldi5zcGxpY2UobmV4dC5wcmV2LmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCB0cmF2ZXJzZSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCEhbm9kZS5uZXh0KSBmb3IgKGxldCBuZXh0IG9mIG5vZGUubmV4dCkgdHJhdmVyc2UobmV4dCk7XG5cbiAgICAgIC8vIHNwbGl0IG5vZGVzXG4gICAgICBpZiAoISFub2RlLm5leHQgJiYgbm9kZS5uZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3BsaXROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBjdXROZXh0KG5vZGUpO1xuICAgICAgICAvLyBjcmVhdGUgbmV3IHN0cmVhbXMgZnJvbSBoZXJlXG4gICAgICAgIG5ld1N0cmVhbXMucHVzaCh7IC4uLm5vZGUubmV4dCB9KTtcblxuICAgICAgICAvLyBlbmQgc3RyZWFtIGhlcmVcbiAgICAgICAgbm9kZS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBtZXJnZSBub2Rlc1xuICAgICAgaWYgKCEhbm9kZS5wcmV2ICYmIG5vZGUucHJldi5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1lcmdlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgZW5kUHJldmlvdXMobm9kZSk7XG5cbiAgICAgICAgbm9kZS5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5ld1N0cmVhbXMucHVzaChub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyZW50IHN3YXBcbiAgICAgIGlmICghIW5vZGUubmV4dCkge1xuICAgICAgICBmb3IgKGxldCBuZXh0IG9mIG5vZGUubmV4dCkge1xuICAgICAgICAgIC8vIG9ubHkgY29uc2lkZXIgbm9kZXMgd2hvcyBwYXJlbnRzIGNoYW5nZVxuICAgICAgICAgIC8vIDEuIG5vZGUgYmVjb21lcyByb290IG5vZGUgKHBhcmVudCBjaGFuZ2VzIGZyb20gZGVmaW5lZCB0byB1bmRlZmluZWQpXG4gICAgICAgICAgLy8gMi4gcGFyZW50IGlkIGNoYW5nZXMgKFRPRE86IG1ha2Ugc3VyZSB0aGF0IHRoaXMgY2FzZSBpcyBub3QgaGFuZGxlZCB0d2ljZSwgYmVjYXVzZSBib3RoIG5vZGUncyBwYXJlbnRzIGNoYW5nZSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoIW5vZGUucGFyZW50ICYmICEhbmV4dC5wYXJlbnQpIHx8XG4gICAgICAgICAgICAoISFub2RlLnBhcmVudCAmJiAhIW5leHQucGFyZW50ICYmIG5vZGUucGFyZW50LmlkICE9IG5leHQucGFyZW50LmlkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbmV4dC5wYXJlbnQgaGFkIG5vZGUgYXMgYW4gYW5jZXN0b3IgaW4gdGhlIHByZXZpb3VzIHN0ZXBcblxuICAgICAgICAgICAgaWYgKCEhbmV4dC5wYXJlbnQucHJldikge1xuICAgICAgICAgICAgICBmb3IgKGxldCBwcmV2IG9mIG5leHQucGFyZW50LnByZXYpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNBbmNlc3RvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBwID0gcHJldjtcbiAgICAgICAgICAgICAgICB3aGlsZSAocCAmJiAhaXNBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgaWYgKHAuaWQgPT0gbm9kZS5pZCkgaXNBbmNlc3RvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBlbHNlIHAgPSBwLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGVuZFByZXZpb3VzKHByZXYpO1xuICAgICAgICAgICAgICAgICAgaWYgKCEhcHJldi5uZXh0KSBhZGRGb2xsb3dpbmcocHJldi5uZXh0KTtcbiAgICAgICAgICAgICAgICAgIHBhcmVudFN3YXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiB7IC4uLnByZXYgfSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogeyAuLi5uZXh0LnBhcmVudCB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZHJhdyBzcGVjaWFsIGNhc2UgZm9yIG5vZGUgXCJwXCIgYW5kIGFsbCBpdHMgY2hpbGRyZW4sIGFzIHdlbGwgYXMgbm9kZVxuXG4gICAgLy8gbG9vcCBpbiByZXZlcnNlLCBiZWNhdXNlIGVsZW1lbnRzIGFyZSBhZGRlZCBhbmQgZGVsZXRlZFxuICAgIGZvciAobGV0IGkgPSB0aGlzLl9zdHJlYW1Ob2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdHJhdmVyc2UodGhpcy5fc3RyZWFtTm9kZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3N0cmVhbU5vZGVzID0gW107XG4gICAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICAgIHRoaXMuX2NsaXBQYXRocyA9IFtdO1xuICB9XG5cbiAgYWRkU3BsaXRzKHNwbGl0cykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNwbGl0cykpXG4gICAgICBzcGxpdHMuZm9yRWFjaChkID0+IHtcbiAgICAgICAgdGhpcy5fc3BsaXRzW2RdID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIGVsc2UgdGhpcy5fc3BsaXRzW2RdID0gdHJ1ZTtcbiAgfVxuXG4gIHJlbW92ZVNwbGl0cyhzcGxpdHMpIHtcbiAgICBpZiAoIXNwbGl0cykgdGhpcy5fc3BsaXRzID0ge307XG4gICAgZWxzZVxuICAgICAgc3BsaXRzLmZvckVhY2goZCA9PiB7XG4gICAgICAgIHRoaXMuX3NwbGl0c1tkXS5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLy9UT0RPOiBmaW5kIG1vcmUgZWxhYm9yYXRlIHNvbHV0aW9uXG4gIF9maW5kU3BsaXRzKHQwLCB0MSkge1xuICAgIGxldCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBzcGxpdCBpbiB0aGlzLl9zcGxpdHMpIHtcbiAgICAgIGlmIChzcGxpdCA+PSB0MCAmJiBzcGxpdCA8PSB0MSkgc3BsaXRzLnB1c2goK3NwbGl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuXG4gIF9maW5kQ2xvc2VzdE5vZGUoc3RyZWFtLCB4KSB7XG4gICAgbGV0IHRyYXZlcnNlVGltZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGguYWJzKG5vZGUueCAtIHgpO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgY2xvc2VzdE5vZGUgPSBub2RlO1xuICAgICAgICAvLyBpZiBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gbWluRGlzdGFuY2UsIGl0IHdpbGwgb25seSBpbmNyZWFzZSB3aXRoIGZvbGxvd2luZyBub2Rlc1xuICAgICAgICBpZiAoISFub2RlLm5leHQpIHtcbiAgICAgICAgICBub2RlLm5leHQuZm9yRWFjaCh0cmF2ZXJzZVRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgY2xvc2VzdE5vZGU7XG4gICAgdHJhdmVyc2VUaW1lKHN0cmVhbSk7XG4gICAgcmV0dXJuIGNsb3Nlc3ROb2RlO1xuICB9XG5cbiAgLy8gV0FSTklORzogd29yayBpbiBwcm9jZXNzXG4gIF9jaGVja0Zvck51bGxTdHJlYW1zKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc3RyZWFtTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBpc051bGwgPSB0cnVlO1xuXG4gICAgICBsZXQgdHJhdmVyc2UgPSBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUueTEgLSBub2RlLnkwID4gMCkge1xuICAgICAgICAgIGlzTnVsbCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghIW5vZGUubmV4dCkgbm9kZS5uZXh0LmZvckVhY2godHJhdmVyc2UpO1xuICAgICAgfTtcblxuICAgICAgdHJhdmVyc2UodGhpcy5fc3RyZWFtTm9kZXNbaV0pO1xuXG4gICAgICBpZiAoaXNOdWxsKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdHJlYW1Ob2Rlc1tpXTsgLy9kZWxldGUgc3RyZWFtO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RyYXdTdGFydChwYXRoLCBub2RlKSB7XG4gICAgY29uc3QgZCA9IHBhdGgsXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xuXG4gICAgLy8gZXh0ZW5kIHRvIGxlZnRcbiAgICBkLm1vdmUoeChub2RlLngpLCB5KG5vZGUueTEpKTtcblxuICAgIC8vIGRvbid0IGRyYXcgc3RhcnQgZm9yIHplcm8gdmFsdWVzXG4gICAgaWYgKG5vZGUueTEgLSBub2RlLnkwIDw9IDApIHJldHVybjtcblxuICAgIGxldCB0ID0gbm9kZS54IC0gMC41ICogKDEgLSBwcm9wKTtcbiAgICBkLmhvcml6b250YWwoeCh0KSk7XG5cbiAgICAvLyBjb25uZWN0IHRvcCBhbmQgYm90dG9tXG4gICAgbGV0IHJvb3QgPSBub2RlO1xuICAgIHdoaWxlICghIXJvb3QucGFyZW50KSByb290ID0gcm9vdC5wYXJlbnQ7XG5cbiAgICBpZiAoIXJvb3QucHJldikge1xuICAgICAgLy8gbWFrZSBmaXJzdCB0aW1lc3RlcCBmbGF0XG4gICAgICBkLnZlcnRpY2FsKHkobm9kZS55MCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fc3RhcnRFbmQuZW5jb2RpbmcgPT0gJ2NpcmNsZScpIHRoaXMuX2RyYXdTdGFydENpcmNsZShkLCBub2RlKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXJ0RW5kLmVuY29kaW5nID09ICdwbHVnJykgdGhpcy5fZHJhd1N0YXJ0UGx1ZyhkLCBub2RlKTtcbiAgICAgIGVsc2UgdGhpcy5fZHJhd1N0YXJ0RGVmYXVsdChkLCBub2RlKTtcbiAgICB9XG5cbiAgICAvLyBjb25uZWN0IGJhY2tcbiAgICBkLmhvcml6b250YWwoeChub2RlLngpKTtcbiAgfVxuXG4gIF9kcmF3RW5kKHBhdGgsIG5vZGUpIHtcbiAgICBjb25zdCBkID0gcGF0aCxcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XG5cbiAgICBpZiAobm9kZS55MSAtIG5vZGUueTAgPD0gMCkgcmV0dXJuO1xuXG4gICAgLy8gZXh0ZW5kIHRvIHJpZ2h0XG4gICAgbGV0IHQgPSBub2RlLnggKyAwLjUgKiAoMSAtIHByb3ApO1xuICAgIGQuaG9yaXpvbnRhbCh4KHQpKTtcblxuICAgIC8vIGNvbm5lY3QgYm90dG9tIGFuZCB0b3BcbiAgICBsZXQgcm9vdCA9IG5vZGU7XG4gICAgd2hpbGUgKCEhcm9vdC5wYXJlbnQpIHJvb3QgPSByb290LnBhcmVudDtcbiAgICBpZiAoIXJvb3QubmV4dCkge1xuICAgICAgLy8gbWFrZSBsYXN0IHRpbWVzdGVwIGZsYXRcbiAgICAgIGQudmVydGljYWwoeShub2RlLnkxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9zdGFydEVuZC5lbmNvZGluZyA9PSAnY2lyY2xlJykgdGhpcy5fZHJhd0VuZENpcmNsZShkLCBub2RlKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXJ0RW5kLmVuY29kaW5nID09ICdwbHVnJykgdGhpcy5fZHJhd0VuZFBsdWcoZCwgbm9kZSk7XG4gICAgICBlbHNlIHRoaXMuX2RyYXdFbmREZWZhdWx0KGQsIG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGNvbm5lY3QgYmFja1xuICAgIGQuaG9yaXpvbnRhbCh4KG5vZGUueCkpO1xuICB9XG5cbiAgX2RyYXdTdGFydERlZmF1bHQocGF0aCwgbm9kZSkge1xuICAgIC8vIGluc2VydCBub2RlXG4gICAgY29uc3QgZCA9IHBhdGgsXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xuXG4gICAgLy8gZmluZCBwb3NpdGlvbiB0byBpbnNlcnQgbm9kZVxuICAgIGxldCBwb3M7XG4gICAgLy8gZmluZCB0aGUgb2xkZXN0IHBhcmVudCBvZiBub2RlLCB3aGljaCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcHJldmlvdXMgc3RlcFxuICAgIGxldCBwYXJlbnROb1ByZXYgPSBub2RlO1xuICAgIHdoaWxlICghIXBhcmVudE5vUHJldi5wYXJlbnQgJiYgIXBhcmVudE5vUHJldi5wYXJlbnQucHJldilcbiAgICAgIHBhcmVudE5vUHJldiA9IHBhcmVudE5vUHJldi5wYXJlbnQ7XG5cbiAgICAvLyBwIGlzIGFuIGFuY2VzdG9yIHdobyBleGlzdGVkIGluIHRoZSBwcmV2aW91cyB0aW1lc3RlcFxuICAgIGxldCBwID0gcGFyZW50Tm9QcmV2LnBhcmVudDtcbiAgICBpZiAoIXApIHtcbiAgICAgIGQudmVydGljYWwoeShub2RlLnkwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVzZSB0aGUgY2VudGVyIG9mIHRoZSBzdHJlYW0gYXMgcmVmZXJlbmNlIHBvaW50XG4gICAgICBsZXQgbWlkID0gMC41ICogKHBhcmVudE5vUHJldi55MCArIHBhcmVudE5vUHJldi55MSk7XG5cbiAgICAgIC8vIGlmIHRoZSBub2RlcyBwYXJlbnQgaGFzIG11bHRpcGxlIHByZXZpb3VzIG5vZGVzLCBmaW5kIHRoZSBvbmUgY2xvc2VzdCB0byBtaWRcbiAgICAgIGxldCByZWZQcmV2SWQgPSAtMTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgcC5wcmV2Lmxlbmd0aCAmJiByZWZQcmV2SWQgPT0gLTE7IG4rKykge1xuICAgICAgICBsZXQgcHJldiA9IHAucHJldltuXTtcbiAgICAgICAgLy8gaWYgbWlkIGxpZXMgd2l0aGluIGEgcHJldiBub2RlXG4gICAgICAgIGlmIChwcmV2LnkwIDw9IG1pZCAmJiBwcmV2LnkxID49IG1pZCkge1xuICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIGNoaWxkcmVuXG4gICAgICAgICAgaWYgKCEhcHJldi5jaGlsZHJlbiAmJiBwcmV2LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCByZWZDaGlsZElkID0gLTE7IC8vIGZpbmQgdHdvIGNoaWxkcmVuIHRvIHB1dCB0aGUgbWlkIGluIGJldHdlZW5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5jaGlsZHJlbi5sZW5ndGggJiYgcmVmQ2hpbGRJZCA9PSAtMTsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBjaGlsZCA9IHByZXYuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgIGlmIChtaWQgPD0gMC41ICogKGNoaWxkLnkwICsgY2hpbGQueTEpKSByZWZDaGlsZElkID0gaTsgLy8gc2V0dGluZyBJRCBicmVha3MgdGhlIGxvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZDaGlsZElkID09IDApXG4gICAgICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBjaGlsZFxuICAgICAgICAgICAgICBwb3MgPSAwLjUgKiAocHJldi55MCArIHByZXYuY2hpbGRyZW5bMF0ueTApO1xuICAgICAgICAgICAgZWxzZSBpZiAocmVmQ2hpbGRJZCA9PSAtMSlcbiAgICAgICAgICAgICAgLy8gYWZ0ZXIgbGFzdCBjaGlsZFxuICAgICAgICAgICAgICBwb3MgPVxuICAgICAgICAgICAgICAgIDAuNSAqIChwcmV2LnkxICsgcHJldi5jaGlsZHJlbltwcmV2LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnkxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcG9zID1cbiAgICAgICAgICAgICAgICAwLjUgKlxuICAgICAgICAgICAgICAgIChwcmV2LmNoaWxkcmVuW3JlZkNoaWxkSWQgLSAxXS55MSArXG4gICAgICAgICAgICAgICAgICBwcmV2LmNoaWxkcmVuW3JlZkNoaWxkSWRdLnkwKTtcbiAgICAgICAgICB9IC8vIG5vZGUgaGFzIG5vIGNoaWxkcmVuXG4gICAgICAgICAgZWxzZSBwb3MgPSAwLjUgKiAocHJldi55MCArIHByZXYueTEpO1xuICAgICAgICAgIHJlZlByZXZJZCA9IC0yOyAvLyBzZXR0aW5nIElEIGJyZWFrcyB0aGUgbG9vcFxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGl0IGxpZXMgb3V0c2lkZSwgZmluZCB0d28gbm9kZXMgdG8gcHV0IGl0IGluYmV0d2VlblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAobWlkIDw9IDAuNSAqIChwcmV2LnkwICsgcHJldi55MSkpIHJlZlByZXZJZCA9IG47IC8vIHNldHRpbmcgSUQgYnJlYWtzIHRoZSBsb29wXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlZlByZXZJZCAhPSAtMikge1xuICAgICAgICAvLyBpZiAtMiwgdGhlbiBwb3Mgd2FzIGFscmVhZHkgc2V0XG4gICAgICAgIGxldCBub2RlOyAvLyBkZWZpbmUgdGhlIG5vZGUgdG8gZHJhdyBpbnNpZGVcbiAgICAgICAgbGV0IGZpcnN0OyAvLyBib29sZWFuIHRvIGRlZmluZSBpZiBpdCBzaG91bGQgYmUgZHJhd24gYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZFxuICAgICAgICBpZiAocmVmUHJldklkID09IDApIHtcbiAgICAgICAgICAvLyBiZWZvcmUgZmlyc3QgY2hpbGRcbiAgICAgICAgICBub2RlID0gcC5wcmV2WzBdO1xuICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZQcmV2SWQgPT0gLTEpIHtcbiAgICAgICAgICAvLyBhZnRlciBsYXN0IGNoaWxkXG4gICAgICAgICAgbm9kZSA9IHAucHJldltwLnByZXYubGVuZ3RoIC0gMV07XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaW5kIHdoaWNoIG5vZGUgaXMgY2xvc2VyXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgTWF0aC5hYnMocC5wcmV2W3JlZlByZXZJZF0ueTAgLSBtaWQpIDxcbiAgICAgICAgICAgIE1hdGguYWJzKHAucHJldltyZWZQcmV2SWQgLSAxXS55MSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5vZGUgPSBwLnByZXZbcmVmUHJldklkXTtcbiAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IHAucHJldltyZWZQcmV2SWQgLSAxXTtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoZmlyc3QpIHBvcyA9IDAuNSAqIChub2RlLnkwICsgbm9kZS5jaGlsZHJlblswXS55MCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcG9zID0gMC41ICogKG5vZGUueTEgKyBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueTEpO1xuICAgICAgICB9IGVsc2UgcG9zID0gMC41ICogKG5vZGUueTAgKyBub2RlLnkxKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRkaWZmID0gbm9kZS54IC0gcC5wcmV2WzBdLng7XG4gICAgICBsZXQgdDAgPSBub2RlLnggLSAwLjUgKiAoMSAtIHByb3ApICogdGRpZmY7XG4gICAgICBsZXQgdDEgPSB0MCAtIDAuNSAqIHByb3AgKiB0ZGlmZjtcblxuICAgICAgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnbGluZWFyJykge1xuICAgICAgICBkLmxpbmUoeChwLnByZXZbMF0ueCksIHkocG9zKSk7XG4gICAgICAgIGQubGluZSh4KHQwKSwgeShub2RlLnkwKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnYmV6aWVyJykge1xuICAgICAgICBkLmJlemllcih4KHQxKSwgeShub2RlLnkxKSwgeCh0MSksIHkocG9zKSwgeChwLnByZXZbMF0ueCksIHkocG9zKSk7XG4gICAgICAgIGQuYmV6aWVyKHgodDEpLCB5KHBvcyksIHgodDEpLCB5KG5vZGUueTApLCB4KHQwKSwgeShub2RlLnkwKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RyYXdFbmREZWZhdWx0KHBhdGgsIG5vZGUpIHtcbiAgICBjb25zdCBkID0gcGF0aCxcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XG5cbiAgICAvLyBmaW5kIHBvc2l0aW9uIHRvIGRlbGV0ZSBub2RlIHRvXG4gICAgbGV0IHBvcztcbiAgICAvLyBmaW5kIHRoZSBvbGRlc3QgcGFyZW50IG9mIG5vZGUsIHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIHRoZSBuZXh0IHN0ZXBcbiAgICBsZXQgcGFyZW50Tm9OZXh0ID0gbm9kZTtcbiAgICB3aGlsZSAoISFwYXJlbnROb05leHQucGFyZW50ICYmICFwYXJlbnROb05leHQucGFyZW50Lm5leHQpXG4gICAgICBwYXJlbnROb05leHQgPSBwYXJlbnROb05leHQucGFyZW50OyAvLyBwIGlzIHRoZSBvbGRlc3QgcGFyZW50IG9mIG5vZGUsIHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIHRoZSBuZXh0IHN0ZXBcblxuICAgIC8vIHAgaXMgYW4gYW5jZXN0b3Igd2hvIGV4aXN0cyBpbiB0aGUgbmV4dCB0aW1lc3RlcFxuICAgIGxldCBwID0gcGFyZW50Tm9OZXh0LnBhcmVudDtcbiAgICBpZiAoIXApIHtcbiAgICAgIGQudmVydGljYWwoeShub2RlLnkxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVzZSB0aGUgY2VudGVyIG9mIHRoZSBzdHJlYW0gYXMgcmVmZXJlbmNlIHBvaW50XG4gICAgICBsZXQgbWlkID0gMC41ICogKHBhcmVudE5vTmV4dC55MCArIHBhcmVudE5vTmV4dC55MSk7XG4gICAgICAvLyBpZiB0aGUgbm9kZXMgcGFyZW50IGhhcyBtdWx0aXBsZSBuZXh0IG5vZGVzLCBmaW5kIHRoZSBvbmUgY2xvc2VzdCB0byBtaWRcbiAgICAgIGxldCByZWZOZXh0SWQgPSAtMTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgcC5uZXh0Lmxlbmd0aCAmJiByZWZOZXh0SWQgPT0gLTE7IG4rKykge1xuICAgICAgICBsZXQgbmV4dCA9IHAubmV4dFtuXTtcbiAgICAgICAgLy8gaWYgbWlkIGxpZXMgd2l0aGluIGEgbmV4dCBub2RlXG4gICAgICAgIGlmIChuZXh0LnkwIDw9IG1pZCAmJiBuZXh0LnkxID49IG1pZCkge1xuICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIGNoaWxkcmVuXG4gICAgICAgICAgaWYgKCEhbmV4dC5jaGlsZHJlbiAmJiBuZXh0LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCByZWZDaGlsZElkID0gLTE7IC8vIGZpbmQgdHdvIGNoaWxkcmVuIHRvIHB1dCB0aGUgbWlkIGluIGJldHdlZW5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dC5jaGlsZHJlbi5sZW5ndGggJiYgcmVmQ2hpbGRJZCA9PSAtMTsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBjaGlsZCA9IG5leHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgIGlmIChtaWQgPD0gMC41ICogKGNoaWxkLnkwICsgY2hpbGQueTEpKSByZWZDaGlsZElkID0gaTsgLy8gc2V0dGluZyBJRCBicmVha3MgdGhlIGxvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZDaGlsZElkID09IDApXG4gICAgICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBjaGlsZFxuICAgICAgICAgICAgICBwb3MgPSAwLjUgKiAobmV4dC55MCArIG5leHQuY2hpbGRyZW5bMF0ueTApO1xuICAgICAgICAgICAgZWxzZSBpZiAocmVmQ2hpbGRJZCA9PSAtMSlcbiAgICAgICAgICAgICAgLy8gYWZ0ZXIgbGFzdCBjaGlsZFxuICAgICAgICAgICAgICBwb3MgPVxuICAgICAgICAgICAgICAgIDAuNSAqIChuZXh0LnkxICsgbmV4dC5jaGlsZHJlbltuZXh0LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnkxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcG9zID1cbiAgICAgICAgICAgICAgICAwLjUgKlxuICAgICAgICAgICAgICAgIChuZXh0LmNoaWxkcmVuW3JlZkNoaWxkSWQgLSAxXS55MSArXG4gICAgICAgICAgICAgICAgICBuZXh0LmNoaWxkcmVuW3JlZkNoaWxkSWRdLnkwKTtcbiAgICAgICAgICB9IC8vIG5vZGUgaGFzIG5vIGNoaWxkcmVuXG4gICAgICAgICAgZWxzZSBwb3MgPSAwLjUgKiAobmV4dC55MCArIG5leHQueTEpO1xuICAgICAgICAgIHJlZk5leHRJZCA9IC0yOyAvLyBzZXR0aW5nIElEIGJyZWFrcyB0aGUgbG9vcFxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGl0IGxpZXMgb3V0c2lkZSwgZmluZCB0d28gbm9kZXMgdG8gcHV0IGl0IGluYmV0d2VlblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAobWlkIDw9IDAuNSAqIChuZXh0LnkwICsgbmV4dC55MSkpIHJlZk5leHRJZCA9IG47IC8vIHNldHRpbmcgSUQgYnJlYWtzIHRoZSBsb29wXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlZk5leHRJZCAhPSAtMikge1xuICAgICAgICAvLyBpZiAtMiwgdGhlbiBwb3Mgd2FzIGFscmVhZHkgc2V0XG4gICAgICAgIGxldCBub2RlOyAvLyBkZWZpbmUgdGhlIG5vZGUgdG8gZHJhdyBpbnNpZGVcbiAgICAgICAgbGV0IGZpcnN0OyAvLyBib29sZWFuIHRvIGRlZmluZSBpZiBpdCBzaG91bGQgYmUgZHJhd24gYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZFxuICAgICAgICBpZiAocmVmTmV4dElkID09IDApIHtcbiAgICAgICAgICAvLyBiZWZvcmUgZmlyc3QgY2hpbGRcbiAgICAgICAgICBub2RlID0gcC5uZXh0WzBdO1xuICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZOZXh0SWQgPT0gLTEpIHtcbiAgICAgICAgICAvLyBhZnRlciBsYXN0IGNoaWxkXG4gICAgICAgICAgbm9kZSA9IHAubmV4dFtwLm5leHQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaW5kIHdoaWNoIG5vZGUgaXMgY2xvc2VyXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgTWF0aC5hYnMocC5uZXh0W3JlZk5leHRJZF0ueTAgLSBtaWQpIDxcbiAgICAgICAgICAgIE1hdGguYWJzKHAubmV4dFtyZWZOZXh0SWQgLSAxXS55MSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5vZGUgPSBwLm5leHRbcmVmTmV4dElkXTtcbiAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IHAubmV4dFtyZWZOZXh0SWQgLSAxXTtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoZmlyc3QpIHBvcyA9IDAuNSAqIChub2RlLnkwICsgbm9kZS5jaGlsZHJlblswXS55MCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcG9zID0gMC41ICogKG5vZGUueTEgKyBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueTEpO1xuICAgICAgICB9IGVsc2UgcG9zID0gMC41ICogKG5vZGUueTAgKyBub2RlLnkxKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRkaWZmID0gcC5uZXh0WzBdLnggLSBub2RlLng7XG4gICAgICBsZXQgdDAgPSBub2RlLnggKyAwLjUgKiAoMSAtIHByb3ApICogdGRpZmY7XG4gICAgICBsZXQgdDEgPSB0MCArIDAuNSAqIHByb3AgKiB0ZGlmZjtcblxuICAgICAgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnbGluZWFyJykge1xuICAgICAgICBkLmxpbmUoeChwLm5leHRbMF0ueCksIHkocG9zKSk7XG4gICAgICAgIGQubGluZSh4KHQwKSwgeShub2RlLnkxKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnYmV6aWVyJykge1xuICAgICAgICBkLmJlemllcih4KHQxKSwgeShub2RlLnkwKSwgeCh0MSksIHkocG9zKSwgeChwLm5leHRbMF0ueCksIHkocG9zKSk7XG4gICAgICAgIGQuYmV6aWVyKHgodDEpLCB5KHBvcyksIHgodDEpLCB5KG5vZGUueTEpLCB4KHQwKSwgeShub2RlLnkxKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RyYXdTdGFydENpcmNsZShwYXRoLCBub2RlKSB7XG4gICAgY29uc3QgZCA9IHBhdGgsXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xuXG4gICAgbGV0IGhlaWdodCA9IG5vZGUueTEgLSBub2RlLnkwO1xuICAgIGxldCB0ID0gbm9kZS54IC0gMC41ICogKDEgLSBwcm9wKTtcbiAgICBkLm1vdmUoeCh0KSwgeShub2RlLnkxKSk7XG4gICAgLy9kLmFyYyhNYXRoLmxvZyhoZWlnaHQpLCAxLCAwLCAwLCAwLCB4KG5vZGUueCksIHkobm9kZS55MCkpO1xuICAgIGQuYXJjKHByb3AsIDEsIDAsIDAsIDAsIHgodCksIHkobm9kZS55MCkpO1xuICB9XG5cbiAgX2RyYXdFbmRDaXJjbGUocGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IGQgPSBwYXRoLFxuICAgICAgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb24sXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxuICAgICAgeSA9IHRoaXMuX3lTY2FsZTtcblxuICAgIGxldCBoZWlnaHQgPSBub2RlLnkxIC0gbm9kZS55MDtcbiAgICBsZXQgdCA9IG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCk7XG4gICAgLy9kLmFyYyhNYXRoLmxvZyhoZWlnaHQpLCAxLCAwLCAwLCAwLCB4KG5vZGUueCksIHkobm9kZS55MSkpO1xuICAgIGQuYXJjKHByb3AsIDEsIDAsIDAsIDAsIHgodCksIHkobm9kZS55MSkpO1xuICB9XG5cbiAgX2RyYXdTdGFydFBsdWcocGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IGQgPSBwYXRoLFxuICAgICAgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb24sXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxuICAgICAgeSA9IHRoaXMuX3lTY2FsZTtcblxuICAgIGxldCB0ID0gbm9kZS54IC0gMC41ICogKDEgLSBwcm9wKTtcbiAgICBsZXQgaGVpZ2h0ID0gbm9kZS55MSAtIG5vZGUueTA7XG4gICAgZC5iZXppZXIoXG4gICAgICB4KHQgLSBwcm9wICogdGhpcy5fc3RhcnRFbmQueCAqIE1hdGguc3FydChoZWlnaHQpKSxcbiAgICAgIHkobm9kZS55MSArIHRoaXMuX3N0YXJ0RW5kLnkgKiBoZWlnaHQpLFxuICAgICAgeCh0IC0gcHJvcCAqIHRoaXMuX3N0YXJ0RW5kLnggKiBNYXRoLnNxcnQoaGVpZ2h0KSksXG4gICAgICB5KG5vZGUueTAgLSB0aGlzLl9zdGFydEVuZC55ICogaGVpZ2h0KSxcbiAgICAgIHgodCksXG4gICAgICB5KG5vZGUueTApXG4gICAgKTtcbiAgfVxuXG4gIF9kcmF3RW5kUGx1ZyhwYXRoLCBub2RlKSB7XG4gICAgY29uc3QgZCA9IHBhdGgsXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xuXG4gICAgbGV0IHQgPSBub2RlLnggKyAwLjUgKiAoMSAtIHByb3ApO1xuICAgIGxldCBoZWlnaHQgPSBub2RlLnkxIC0gbm9kZS55MDtcbiAgICBkLmJlemllcihcbiAgICAgIHgodCArIHByb3AgKiB0aGlzLl9zdGFydEVuZC54ICogTWF0aC5zcXJ0KGhlaWdodCkpLFxuICAgICAgeShub2RlLnkwIC0gdGhpcy5fc3RhcnRFbmQueSAqIGhlaWdodCksXG4gICAgICB4KHQgKyBwcm9wICogdGhpcy5fc3RhcnRFbmQueCAqIE1hdGguc3FydChoZWlnaHQpKSxcbiAgICAgIHkobm9kZS55MSArIHRoaXMuX3N0YXJ0RW5kLnkgKiBoZWlnaHQpLFxuICAgICAgeCh0KSxcbiAgICAgIHkobm9kZS55MSlcbiAgICApO1xuICB9XG5cbiAgY2FsY3VsYXRlUGF0aHMoKSB7XG4gICAgLy90aGlzLl9jaGVja0Zvck51bGxTdHJlYW1zKCk7XG5cbiAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xuICAgIGxldCBkLCBsYXN0VGltZXBvaW50LCBkZWVwZXN0RGVwdGgsIGxhcmdlc3RTaXplOyAvLyBmaW5kIHRoZSBkZWVwZXN0IGRlcHRoIGVhY2ggc3RyZWFtIGhhcyBvdmVyIHRoZSB3aG9sZSB0aW1lc2VyaWVzXG5cbiAgICBsZXQgZHJhd0xpbmUgPSAodDEsIHQyLCB0MywgeVNvdXJjZSwgeURlc3QpID0+IHtcbiAgICAgIGxldCB0MTIgPSAwLjUgKiAodDEgKyB0Mik7IC8vIG1pZCBiZXR3ZWVuIHQxIGFuZCB0MlxuICAgICAgZC5ob3Jpem9udGFsKHQxKTtcbiAgICAgIGlmICh0aGlzLl94Q3VydmUgPT0gJ2xpbmVhcicpIHtcbiAgICAgICAgZC5saW5lKHQyLCB5KHlEZXN0KSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnYmV6aWVyJykge1xuICAgICAgICBkLmJlemllcih0MTIsIHkoeVNvdXJjZSksIHQxMiwgeSh5RGVzdCksIHQyLCB5KHlEZXN0KSk7XG4gICAgICB9XG4gICAgICBkLmhvcml6b250YWwodDMpO1xuICAgIH07XG5cbiAgICBsZXQgdHJhdmVyc2UgPSBub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnggPiBsYXN0VGltZXBvaW50KSBsYXN0VGltZXBvaW50ID0gbm9kZS54O1xuXG4gICAgICBpZiAobm9kZS5kZXB0aCA+IGRlZXBlc3REZXB0aCkgZGVlcGVzdERlcHRoID0gbm9kZS5kZXB0aDtcbiAgICAgIGlmIChub2RlLnNpemUgPiBsYXJnZXN0U2l6ZSkgbGFyZ2VzdFNpemUgPSBub2RlLnNpemU7XG5cbiAgICAgIGlmICghIW5vZGUubmV4dCkge1xuICAgICAgICBsZXQgZHQgPSBub2RlLm5leHRbMF0ueCAtIG5vZGUueDtcbiAgICAgICAgbGV0IHQwID0geChub2RlLngpO1xuICAgICAgICBsZXQgdDEgPSB4KG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCkgKiBkdCk7XG4gICAgICAgIGxldCB0MiA9IHgobm9kZS5uZXh0WzBdLnggLSAwLjUgKiAoMSAtIHByb3ApICogZHQpO1xuICAgICAgICBsZXQgdDMgPSB4KG5vZGUubmV4dFswXS54KTtcblxuICAgICAgICBsZXQgeTAgPSBub2RlLnkwO1xuICAgICAgICBsZXQgeTEgPSBub2RlLnkxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGRlc3QgPSBub2RlLm5leHRbaV07XG4gICAgICAgICAgLy8gZG9uJ3QgZHJhdyBhbnl0aGluZyBmb3Igc3RyZWFtcyB3aXRoIHplcm8gaGVpZ2h0XG4gICAgICAgICAgaWYgKHkxIC0geTAgPD0gMCAmJiBkZXN0LnkxIC0gZGVzdC55MCA8PSAwKSB7XG4gICAgICAgICAgICBkLm1vdmUodDMsIHkoZGVzdC55MCkpO1xuICAgICAgICAgICAgdHJhdmVyc2UoZGVzdCk7XG4gICAgICAgICAgICBkLm1vdmUodDAsIHkoeTApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd0xpbmUodDEsIHQyLCB0MywgeTAsIGRlc3QueTApOyAvLyBib3R0b20gbGluZSAoZm9yd2FyZHMpXG4gICAgICAgICAgICB0cmF2ZXJzZShkZXN0KTtcbiAgICAgICAgICAgIGRyYXdMaW5lKHQyLCB0MSwgdDAsIGRlc3QueTEsIHkxKTsgLy8gdG9wIGxpbmUgKGJhY2t3YXJkcylcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgZGVzdCBpcyBvbmUgb2YgdGhlIG5vZGVzIHdoZXJlIHRoZSBzcGxpdCBvY2N1cmVkLCB3ZSBuZWVkIHRvIGRyYXcgYSBsaW5lIGJhY2sgdG8gb3VyIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgaWYgKG5vZGUubmV4dC5sZW5ndGggPiAxICYmIGkgPCBub2RlLm5leHQubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIGQudmVydGljYWwoeSh5MCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgdGhpcy5fZHJhd0VuZChkLCBub2RlKTtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgc3RyZWFtIG9mIHRoaXMuX3N0cmVhbU5vZGVzKSB7XG4gICAgICBkID0gbmV3IFN2Z1BhdGgoKTtcbiAgICAgIC8vIHJlc2V0IGJlZm9yZSBuZXcgdmFsdWVzIGFyZSBmb3VuZCBieSB0cmF2ZXJzZVxuICAgICAgbGFzdFRpbWVwb2ludCA9IDA7XG4gICAgICBkZWVwZXN0RGVwdGggPSAwO1xuICAgICAgbGFyZ2VzdFNpemUgPSAwO1xuXG4gICAgICB0aGlzLl9kcmF3U3RhcnQoZCwgc3RyZWFtKTtcbiAgICAgIHRyYXZlcnNlKHN0cmVhbSk7XG4gICAgICAvL2QuY2xvc2UoKTtcblxuICAgICAgLy8gYWRkIHNwbGl0c1xuXG4gICAgICBsZXQgY2xpcFBhdGggPSBuZXcgU3ZnUGF0aCgpO1xuICAgICAgbGV0IHNwbGl0cyA9IHRoaXMuX2ZpbmRTcGxpdHMoc3RyZWFtLnggLSAwLjUsIGxhc3RUaW1lcG9pbnQgKyAwLjUpO1xuXG4gICAgICBsZXQgY2xpcFN0YXJ0ID0geCgtMSk7XG4gICAgICBsZXQgeTAgPSB5KDApO1xuICAgICAgbGV0IHkxID0geSgxKTtcbiAgICAgIGZvciAobGV0IHNwbGl0IG9mIHNwbGl0cykge1xuICAgICAgICAvLyB3ZSBtb3ZlIGJ5IDAuMDAwMSB0byBhdm9pZCBjYXNlcyBpbiB3aGljaCB0aGUgc3BsaXQgaXMgaW4gdGhlIG1pZGRsZSBvZiAyIG5vZGVzXG4gICAgICAgIGxldCBjbGlwRW5kID0geChcbiAgICAgICAgICBzcGxpdCAtIDAuNSAqIHRoaXMuX2ZpbmRDbG9zZXN0Tm9kZShzdHJlYW0sIHNwbGl0IC0gMC4wMDAxKS5tYXJnaW5YXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGNsaXBFbmQgLSBjbGlwU3RhcnQgPiAwKSB7XG4gICAgICAgICAgY2xpcFBhdGgubW92ZShjbGlwU3RhcnQsIHkwKTtcbiAgICAgICAgICBjbGlwUGF0aC5ob3Jpem9udGFsKGNsaXBFbmQpO1xuICAgICAgICAgIGNsaXBQYXRoLnZlcnRpY2FsKHkxKTtcbiAgICAgICAgICAvKmxldCBkaXN0ID0geTEteTA7XG4gICAgICAgICAgbGV0IHppZ3phZ3MgPSAzMDA7XG4gICAgICAgICAgbGV0IHppZ3phZ1dpZHRoID0gNTtcbiAgICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHppZ3phZ3M7IHorKykge1xuICAgICAgICAgICAgICBsZXQgZGlyID0gKHogJSAyICogMiAtIDEpO1xuICAgICAgICAgICAgICBjbGlwUGF0aC5saW5lRChkaXIgKiB6aWd6YWdXaWR0aCwgZGlzdC96aWd6YWdzKVxuICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgY2xpcFBhdGguaG9yaXpvbnRhbChjbGlwU3RhcnQpO1xuICAgICAgICAgIGNsaXBQYXRoLnZlcnRpY2FsKHkwKTtcbiAgICAgICAgICAvKmZvciAobGV0IHogPSAwOyB6IDwgemlnemFnczsgeisrKSB7XG4gICAgICAgICAgICAgIGxldCBkaXIgPSAoeiAlIDIgKiAyIC0gMSk7XG4gICAgICAgICAgICAgIGNsaXBQYXRoLmxpbmVEKGRpciAqIHppZ3phZ1dpZHRoLCAtZGlzdC96aWd6YWdzKVxuICAgICAgICAgIH0qL1xuICAgICAgICB9XG4gICAgICAgIGNsaXBTdGFydCA9IHgoXG4gICAgICAgICAgc3BsaXQgKyAwLjUgKiB0aGlzLl9maW5kQ2xvc2VzdE5vZGUoc3RyZWFtLCBzcGxpdCArIDAuMDAwMSkubWFyZ2luWFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2xpcFBhdGgubW92ZShjbGlwU3RhcnQsIHkwKTtcbiAgICAgIGNsaXBQYXRoLmhvcml6b250YWwoeChsYXN0VGltZXBvaW50ICsgMSkpO1xuICAgICAgY2xpcFBhdGgudmVydGljYWwoeTEpO1xuICAgICAgY2xpcFBhdGguaG9yaXpvbnRhbChjbGlwU3RhcnQpO1xuICAgICAgY2xpcFBhdGgudmVydGljYWwoeTApO1xuXG4gICAgICB0aGlzLl9jbGlwUGF0aHMucHVzaCh7XG4gICAgICAgIGlkOiBzdHJlYW0uc3RyZWFtSWQsXG4gICAgICAgIHBhdGg6IGNsaXBQYXRoLmdldCgpXG4gICAgICB9KTtcblxuICAgICAgLy8gZmluZCBwb3NpdGlvbiB0byBwdXQgYSB0ZXh0IGxhYmVsXG4gICAgICBsZXQgdGV4dFBvcztcbiAgICAgIGlmIChNYXRoLmFicyh5KHN0cmVhbS55MSkgLSB5KHN0cmVhbS55MCkpIDwgMjUpIHRleHRQb3MgPSAtMTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoeShzdHJlYW0ueTEpID4geShzdHJlYW0ueTApKSB0ZXh0UG9zID0geShzdHJlYW0ueTApICsgMTU7XG4gICAgICAgIGVsc2UgdGV4dFBvcyA9IHkoc3RyZWFtLnkxKSArIDE1O1xuICAgICAgfVxuXG4gICAgICBsZXQgc3RyZWFtT2JqID0ge1xuICAgICAgICBwYXRoOiBkLmdldCgpLFxuICAgICAgICBkZXB0aDogc3RyZWFtLmRlcHRoLFxuICAgICAgICBkZWVwZXN0RGVwdGg6IGRlZXBlc3REZXB0aCxcbiAgICAgICAgbGFyZ2VzdFNpemU6IGxhcmdlc3RTaXplLFxuICAgICAgICBpZDogc3RyZWFtLnN0cmVhbUlkLFxuICAgICAgICBkYXRhOiBzdHJlYW0uZGF0YSxcbiAgICAgICAgdGV4dFBvczoge1xuICAgICAgICAgIHg6IHgoc3RyZWFtLnggLSAwLjUgKiAoMSAtIHRoaXMuX3Byb3BvcnRpb24pICsgMC41ICogc3RyZWFtLm1hcmdpblgpLFxuICAgICAgICAgIHk6IHRleHRQb3NcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc3RyZWFtcy5wdXNoKHN0cmVhbU9iaik7XG4gICAgICAvLyBpZiAoIXRoaXMuX3N0cmVhbXNbc3RyZWFtLmRlcHRoXSlcbiAgICAgIC8vICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5kZXB0aF0gPSBbXTtcbiAgICAgIC8vIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmRlcHRoXS5wdXNoKHN0cmVhbU9iaik7XG4gICAgfVxuXG4gICAgLy8gV0FSTklORzogVGhpcyB3YXMgYSBmaXggZm9yOiBcImlmIHN0cmVhbSBJRHMgYXJlIHN0cmluZ3MsIHRoZSBjbGlwUGF0aCBhcnJheSBoYXMgYW4gZW1wdHkgdmFsdWUgaW4gdGhlIGJlZ2lubmluZyAtLT4gcmVtb3ZlXCJcbiAgICAvLyBCdXQgaW5zdGVhZCBpdCBqdXN0IHJlbW92ZXMgYWxsIGNsaXBQYXRocyB3aGljaCBoYXZlIHN0cmluZyBhcyBhbiBJRFxuICAgIC8vdGhpcy5fY2xpcFBhdGhzID0gdGhpcy5fY2xpcFBhdGhzLmZpbHRlcihkID0+IGQpO1xuXG4gICAgLy8gVE9ETzogYXBwbHkgYW4gb3JkZXIgaW4gd2hpY2ggY2hpbGRyZW4gYXJlIGRyYXduIGNvcnJlY3RseVxuICAgIC8vIHRoaXMuX3N0cmVhbXMuc29ydCgoYSxiKSA9PiAoYS5kZXB0aCA8IGIuZGVwdGgpID8gLTEgOiAxKVxuICAgIHRoaXMuX3N0cmVhbXMuc29ydCgoYSwgYikgPT4gKGEuZGVlcGVzdERlcHRoIDwgYi5kZWVwZXN0RGVwdGggPyAtMSA6IDEpKTtcbiAgICAvL3RoaXMuX3N0cmVhbXMuc29ydCgoYSxiKSA9PiBhLmlkIDwgYi5pZCA/IC0xOiAxKVxuICAgIC8vdGhpcy5fc3RyZWFtcy5yZXZlcnNlKCk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SplitStreamData.js\n"
          );

          /***/
        },

      /***/ './src/SplitStreamFilter.js':
        /*!**********************************!*\
  !*** ./src/SplitStreamFilter.js ***!
  \**********************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SplitStreamFilter; });\n/* harmony import */ var flatted_esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatted/esm */ "./node_modules/flatted/esm/index.js");\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SplitStreamInputData.js */ "./src/SplitStreamInputData.js");\n\r\n\r\n\r\nclass SplitStreamFilter {\r\n  // expects SplitStreamInputData.data as input\r\n  constructor(inputData, options = {}) {\r\n    this._opts = {\r\n      ...options // overwrite default settings with user settings\r\n    };\r\n    if (!inputData instanceof _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_1__["default"])\r\n      throw Exeption(\'Added data is not an instance of SplitStreamData\');\r\n    this.__inputData = inputData;\r\n    this._filteredData;\r\n    this._lastMaxDepth = 0;\r\n    this._reset();\r\n  }\r\n\r\n  get data() {\r\n    return this._filteredData;\r\n  }\r\n\r\n  _reset() {\r\n    let json = Object(flatted_esm__WEBPACK_IMPORTED_MODULE_0__["stringify"])(this.__inputData.data);\r\n    this._filteredData = Object(flatted_esm__WEBPACK_IMPORTED_MODULE_0__["parse"])(json);\r\n    //this._filteredData.timesteps = this._filteredData.timesteps.filter(d => d);\r\n    return this;\r\n  }\r\n\r\n  maxDepth(maxDepth) {\r\n    // if (maxDepth > this._lastMaxDepth) this._reset();\r\n\r\n    let traverse = node => {\r\n      if (node.depth >= maxDepth) {\r\n        node.children = [];\r\n      } else {\r\n        if (!!node.children) for (let child of node.children) traverse(child);\r\n      }\r\n    };\r\n\r\n    for (let time of this._filteredData.timesteps) {\r\n      if (!!time)\r\n        // TODO: Check why some entries are empty\r\n        traverse(time.tree);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  branch(branchNr) {\r\n    branchNr = +branchNr;\r\n    // this._reset();\r\n    for (let time of this._filteredData.timesteps) {\r\n      if (!!time) {\r\n        // TODO: Check why some entries are empty\r\n        let branches = time.tree.children;\r\n        // remove branches after branchNr\r\n        if (branchNr < branches.length - 1) branches.splice(branchNr + 1);\r\n        // remove branches before branchNr\r\n        if (branchNr > 0) branches.splice(0, branchNr);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  select(nodeId) {}\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1GaWx0ZXIuanM/ZTJkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNjOztBQUU5QztBQUNmO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnRUFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsNkRBQVM7QUFDeEIseUJBQXlCLHlEQUFLO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3BsaXRTdHJlYW1GaWx0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSwgc3RyaW5naWZ5IH0gZnJvbSAnZmxhdHRlZC9lc20nO1xyXG5pbXBvcnQgU3BsaXRTdHJlYW1JbnB1dERhdGEgZnJvbSAnLi9TcGxpdFN0cmVhbUlucHV0RGF0YS5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdFN0cmVhbUZpbHRlciB7XHJcbiAgLy8gZXhwZWN0cyBTcGxpdFN0cmVhbUlucHV0RGF0YS5kYXRhIGFzIGlucHV0XHJcbiAgY29uc3RydWN0b3IoaW5wdXREYXRhLCBvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMuX29wdHMgPSB7XHJcbiAgICAgIC4uLm9wdGlvbnMgLy8gb3ZlcndyaXRlIGRlZmF1bHQgc2V0dGluZ3Mgd2l0aCB1c2VyIHNldHRpbmdzXHJcbiAgICB9O1xyXG4gICAgaWYgKCFpbnB1dERhdGEgaW5zdGFuY2VvZiBTcGxpdFN0cmVhbUlucHV0RGF0YSlcclxuICAgICAgdGhyb3cgRXhlcHRpb24oJ0FkZGVkIGRhdGEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFNwbGl0U3RyZWFtRGF0YScpO1xyXG4gICAgdGhpcy5fX2lucHV0RGF0YSA9IGlucHV0RGF0YTtcclxuICAgIHRoaXMuX2ZpbHRlcmVkRGF0YTtcclxuICAgIHRoaXMuX2xhc3RNYXhEZXB0aCA9IDA7XHJcbiAgICB0aGlzLl9yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWREYXRhO1xyXG4gIH1cclxuXHJcbiAgX3Jlc2V0KCkge1xyXG4gICAgbGV0IGpzb24gPSBzdHJpbmdpZnkodGhpcy5fX2lucHV0RGF0YS5kYXRhKTtcclxuICAgIHRoaXMuX2ZpbHRlcmVkRGF0YSA9IHBhcnNlKGpzb24pO1xyXG4gICAgLy90aGlzLl9maWx0ZXJlZERhdGEudGltZXN0ZXBzID0gdGhpcy5fZmlsdGVyZWREYXRhLnRpbWVzdGVwcy5maWx0ZXIoZCA9PiBkKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgbWF4RGVwdGgobWF4RGVwdGgpIHtcclxuICAgIC8vIGlmIChtYXhEZXB0aCA+IHRoaXMuX2xhc3RNYXhEZXB0aCkgdGhpcy5fcmVzZXQoKTtcclxuXHJcbiAgICBsZXQgdHJhdmVyc2UgPSBub2RlID0+IHtcclxuICAgICAgaWYgKG5vZGUuZGVwdGggPj0gbWF4RGVwdGgpIHtcclxuICAgICAgICBub2RlLmNoaWxkcmVuID0gW107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbikgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikgdHJhdmVyc2UoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IHRpbWUgb2YgdGhpcy5fZmlsdGVyZWREYXRhLnRpbWVzdGVwcykge1xyXG4gICAgICBpZiAoISF0aW1lKVxyXG4gICAgICAgIC8vIFRPRE86IENoZWNrIHdoeSBzb21lIGVudHJpZXMgYXJlIGVtcHR5XHJcbiAgICAgICAgdHJhdmVyc2UodGltZS50cmVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgYnJhbmNoKGJyYW5jaE5yKSB7XHJcbiAgICBicmFuY2hOciA9ICticmFuY2hOcjtcclxuICAgIC8vIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICBmb3IgKGxldCB0aW1lIG9mIHRoaXMuX2ZpbHRlcmVkRGF0YS50aW1lc3RlcHMpIHtcclxuICAgICAgaWYgKCEhdGltZSkge1xyXG4gICAgICAgIC8vIFRPRE86IENoZWNrIHdoeSBzb21lIGVudHJpZXMgYXJlIGVtcHR5XHJcbiAgICAgICAgbGV0IGJyYW5jaGVzID0gdGltZS50cmVlLmNoaWxkcmVuO1xyXG4gICAgICAgIC8vIHJlbW92ZSBicmFuY2hlcyBhZnRlciBicmFuY2hOclxyXG4gICAgICAgIGlmIChicmFuY2hOciA8IGJyYW5jaGVzLmxlbmd0aCAtIDEpIGJyYW5jaGVzLnNwbGljZShicmFuY2hOciArIDEpO1xyXG4gICAgICAgIC8vIHJlbW92ZSBicmFuY2hlcyBiZWZvcmUgYnJhbmNoTnJcclxuICAgICAgICBpZiAoYnJhbmNoTnIgPiAwKSBicmFuY2hlcy5zcGxpY2UoMCwgYnJhbmNoTnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNlbGVjdChub2RlSWQpIHt9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/SplitStreamFilter.js\n'
          );

          /***/
        },

      /***/ './src/SplitStreamInputData.js':
        /*!*************************************!*\
  !*** ./src/SplitStreamInputData.js ***!
  \*************************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStreamInputData; });\nclass SplitStreamInputData {\n  constructor(options = {}) {\n    this._opts = {\n      forceFakeRoot: false,\n      order: {\n        name: 'minimizeEdgeCrossings',\n        options: {\n          iterations: 20\n        }\n      },\n      ...options // overwrite default settings with user settings\n    };\n    // hold a tree (root node) for each timestep\n    // hold a reference array which includes all nodes present in a single timestep\n    // TODO: if timesteps do not start with 0, for ... of loops give back undefined until the first timestep is reached\n    // TODO: The problem is that an array does contain all inbetween values, but a for ... in loop in an object converts numbers to strings again\n    // maybe prove a nextTimestep function for convenience\n    // or store the keys for timesteps in an individual array and use integer indices from 0 to n internally\n    // also requires convenience function to not write +t + 1 every time\n    this._timesteps = {};\n    this._numNodes = 0;\n  }\n\n  get data() {\n    return { timesteps: this._timesteps, numNodes: this._numNodes };\n  }\n\n  addNode(t, id, size = undefined, pos = undefined, data = undefined) {\n    if (!this._timesteps[t]) this._createTimestep(t);\n\n    if (!this._timesteps[t].references[id]) {\n      let dataSize = +size;\n      let dataPos = +pos;\n      id = String(id);\n      // size = +size;\n      // pos = +pos;\n      this._timesteps[t].references[id] = {\n        id,\n        dataSize,\n        dataPos,\n        size,\n        pos,\n        data\n      };\n      this._numNodes++;\n    } else; // console.log(`Warning AddNode: Node ${id} at timestep ${t} exists already.`);\n  }\n\n  addParent(t, id, pId) {\n    let nodes = this._timesteps[t].references;\n    let node = nodes[id];\n    let parent = nodes[pId];\n    if (!node) {\n      // console.log(`Error 'addParent': Node '${id}' does not exist.`);\n      return;\n    }\n    if (!parent) {\n      // console.log(`Error 'addParent': Parent node '${pId}' does not exist.`);\n      return;\n    }\n    node.parent = parent;\n    if (!parent.children) parent.children = [];\n    parent.children.push(node);\n  }\n\n  addNext(t, id, nextId) {\n    let time1 = this._timesteps[t];\n    let time2 = this._timesteps[+t + 1];\n    if (!time1 || !time2) {\n      // console.log(`Error 'addNext': Timestep '${+t + 1}' does not exist.`);\n      return false;\n    }\n\n    let node = time1.references[id];\n    let nextNode = time2.references[nextId];\n    if (!node || !nextNode) {\n      // console.log(`Error 'addNext': Node '${id}' does not exist.`);\n      return false;\n    }\n\n    // console.log(`Change timestep ${t}: ${id} to ${nextId}`);\n    if (!node.next) node.next = [];\n    node.next.push(nextNode);\n    if (!nextNode.prev) nextNode.prev = [];\n    nextNode.prev.push(node);\n    return true;\n  }\n\n  finalize() {\n    this._checkParents();\n\n    this.__forEachNodeDepthFirst((node, depth, t) => {\n      node.x = +t;\n      node.depth = depth;\n      this._setSizeAndAggregate(node);\n      this._checkSize(node);\n      this._checkPositions(node);\n    });\n\n    if (this._opts.order)\n      if (this._opts.order.name == 'minimizeEdgeCrossings') {\n        if (this._opts.order.options)\n          this.minimizeEdgeCrossings(this._opts.order.options.iterations);\n        else this.minimizeEdgeCrossings();\n      }\n  }\n\n  // check if all nodes except the root have a parent\n  // if multiple roots exist, create a fake root\n  _checkParents() {\n    let nodesWithoutParents = {};\n    for (let t in this._timesteps) {\n      let nodes = this._timesteps[t].references;\n      for (let id in nodes) {\n        let node = nodes[id];\n        if (!node.parent) {\n          if (!nodesWithoutParents[t]) nodesWithoutParents[t] = [];\n          nodesWithoutParents[t].push(node);\n        }\n      }\n    }\n\n    let fakeRootNeeded = false;\n    for (let t in nodesWithoutParents) {\n      if (nodesWithoutParents[t].length > 1) {\n        fakeRootNeeded = true;\n        break;\n      }\n    }\n\n    if (fakeRootNeeded || this._opts.forceFakeRoot) {\n      let prevT;\n      for (let t in nodesWithoutParents) {\n        this.addNode(t, 'fakeRoot');\n        nodesWithoutParents[t].forEach(node => {\n          this.addParent(t, node.id, 'fakeRoot');\n          this._timesteps[t].tree = this._timesteps[t].references['fakeRoot'];\n        });\n        // connect fake roots\n        if (!!prevT) {\n          this.addNext(prevT, 'fakeRoot', 'fakeRoot');\n        }\n        prevT = t;\n      }\n    } else {\n      // every timepoint has a single root node\n      for (let t in nodesWithoutParents) {\n        this._timesteps[t].tree = nodesWithoutParents[t][0];\n      }\n    }\n  }\n\n  // if node does not have a size, set it's size to the sum of the sizes of its children\n  // if a node does not have a size and does not have children, give it size 1\n  _setSizeAndAggregate(node) {\n    if (!!node.children) {\n      node.aggregate = 0;\n      for (let child of node.children) node.aggregate += child.dataSize;\n      if (Number.isNaN(node.dataSize)) node.dataSize = node.aggregate;\n    } else {\n      if (Number.isNaN(node.dataSize)) node.dataSize = 1;\n      node.aggregate = node.dataSize;\n    }\n  }\n\n  _checkSize(node) {\n    if (node.dataSize < node.aggregate) {\n      // console.log('Error: Node has a smaller size than its children.');\n      // console.log(node);\n    }\n  }\n\n  // check if size of parent elements is bigger than the aggregate of the sizes of its children\n  _checkPositions(node) {\n    if (!!node.children) {\n      let minPos = 0;\n      for (let child of node.children) {\n        if (child.pos >= 0) {\n          if (minPos > child.pos) {\n            // console.log('Error: Children positions overlap each other.');\n            // console.log(node);\n          }\n          minPos = child.pos + child.dataSize;\n        }\n      }\n    }\n  }\n\n  __forEachNodeDepthFirst(callback) {\n    let traverse = function(node, depth, t) {\n      if (!!node.children)\n        node.children.forEach(child => traverse(child, depth + 1, t));\n      callback(node, depth, t);\n    };\n\n    for (let t in this._timesteps) traverse(this._timesteps[t].tree, 0, t);\n  }\n\n  _createTimestep(t) {\n    this._timesteps[t] = {\n      references: {},\n      tree: null\n    };\n  }\n\n  // connect nodes which have the same ID in consecutive timesteps\n  connectEqualIds() {\n    for (let t in this._timesteps) {\n      if (!!this._timesteps[+t + 1]) {\n        let nodes = this._timesteps[t].references;\n        let nodes2 = this._timesteps[+t + 1].references;\n        for (let id in nodes) {\n          if (!!nodes2[id]) {\n            // do not build connections if the nodes next elements were manually set\n            if (!nodes[id].next) nodes[id].next = [];\n            if (!nodes2[id].prev) nodes2[id].prev = [];\n\n            nodes[id].next.push(nodes2[id]);\n            nodes2[id].prev.push(nodes[id]);\n          }\n        }\n      }\n    }\n  }\n\n  // following the algorithm by Shixia Liu et al. in StoryFlow, based on\n  // Methods for Visual Understanding of Hierarchical System Structures by Sugiyama et al.\n  minimizeEdgeCrossings(iterations = 20) {\n    // create t-1 adjacency matrices for leave nodes\n    let leaves = this.__getLeafNodes();\n    let M = this.__getAdjacencyMatrices(leaves);\n    let timesteps = Object.keys(this._timesteps);\n\n    let calculateBarycenterCols = t => {\n      for (let l in leaves[t])\n        leaves[t][l].barycenter = this.__getBarycenterCol(M[t - 1], l);\n    };\n\n    let calculateBarycenterRows = t => {\n      for (let l in leaves[t])\n        leaves[t][l].barycenter = this.__getBarycenterRow(M[t], l);\n    };\n\n    let reorder = t => {\n      this.__orderByBarycenter(this._timesteps[t].tree);\n      let newOrder = this.__getNewOrder(this._timesteps[t].tree);\n      applyOrder(t, newOrder);\n    };\n\n    let applyOrder = (t, order) => {\n      // reorder matrix rows\n      if (M[t]) M[t] = order.map(i => M[t][i]);\n      // reorder same nodes in previous matrix columns\n      if (M[t - 1])\n        M[t - 1].forEach((row, i) => (M[t - 1][i] = order.map(i => row[i])));\n      // reorder leaf array\n      leaves[t] = order.map(i => leaves[t][i]);\n    };\n\n    //sweep right, reorder columns based on barycenters\n    let phase1Down = () => {\n      for (let tId = 1; tId < timesteps.length; tId++) {\n        let t = timesteps[tId];\n        calculateBarycenterCols(t);\n        reorder(t);\n      }\n    };\n\n    // sweep left, reorder rows\n    let phase1Up = () => {\n      for (let tId = timesteps.length - 2; tId >= 0; tId--) {\n        let t = timesteps[tId];\n        calculateBarycenterRows(t);\n        reorder(t);\n      }\n    };\n\n    // sweep right, reverse order of nodes with equal barycenter\n    let phase2Down = () => {\n      for (let tId = 1; tId < timesteps.length; tId++) {\n        let t = timesteps[tId];\n        calculateBarycenterCols(t);\n        this.__reverseEqualBarycenters(this._timesteps[t].tree);\n        let newOrder = this.__getNewOrder(this._timesteps[t].tree);\n        applyOrder(t, newOrder);\n      }\n    };\n\n    let phase2Up = () => {\n      for (let tId = timesteps.length - 2; tId >= 0; tId--) {\n        let t = timesteps[tId];\n        calculateBarycenterRows(t);\n        this.__reverseEqualBarycenters(this._timesteps[t].tree);\n        let newOrder = this.__getNewOrder(this._timesteps[t].tree);\n        applyOrder(t, newOrder);\n      }\n    };\n\n    for (let i = 0; i < iterations; i++) {\n      if (i % 2 == 0) {\n        phase1Down();\n        phase2Down();\n        phase2Up();\n      } else {\n        phase1Up();\n        phase2Up();\n        phase2Down();\n      }\n\n      // TODO: stop if all rows and columns are sorted ascending\n      // this is the case when no order changed in an iteration\n    }\n  }\n\n  // takes an array of barycenter values as input\n  // outputs an array of new indices, where elements with equal values are reversed\n  __reverseIndicesOfEqualValues(array) {\n    let result = [];\n    // create an object that contains for each value an array of indices that have this value\n    let equals = {};\n    array.forEach((val, idx) => {\n      if (!equals[val]) equals[val] = [];\n      equals[val].push(idx);\n    });\n    // for each value reverse the index order\n    for (let val in equals) {\n      let indices = equals[val];\n      indices.forEach((idx, i) => {\n        result[idx] = indices[indices.length - i - 1];\n      });\n    }\n    return result;\n  }\n\n  __reverseEqualBarycenters(tree) {\n    let numLeaves = 0;\n    let traverse = node => {\n      if (!node.children) node.bcMatrixPosition = numLeaves++;\n      else {\n        node.children.forEach(child => traverse(child));\n        // extract an array of barycenters in order\n        let barycenterArray = node.children.map(d => d.barycenter);\n        // reverse the order of equal barycenters\n        let newOrder = this.__reverseIndicesOfEqualValues(barycenterArray);\n        // reorder children\n        node.children = newOrder.map(idx => node.children[idx]);\n      }\n    };\n    traverse(tree);\n  }\n\n  __getNewOrder(tree) {\n    let order = [];\n    let newLeafOrder = node => {\n      if (node.children) node.children.forEach(child => newLeafOrder(child));\n      else order.push(node.bcMatrixPosition);\n    };\n    newLeafOrder(tree);\n    return order;\n  }\n\n  // bcMatrixRange defines the area of the adjacency matrix in which the node has influence\n  // this is necesasry because of hierarchy nodes that span a wider range\n  __orderByBarycenter(tree) {\n    let numLeaves = 0;\n    let traverse = node => {\n      if (!node.children) node.bcMatrixPosition = numLeaves++;\n      else {\n        node.barycenter = 0; // hierarchy nodes get the average of their childrens' barycenter\n        let numInvolvedChildren = 0;\n        node.children.forEach((child, i) => {\n          traverse(child);\n          // child.index = i; // store previous child index\n          if (!Number.isNaN(child.barycenter)) {\n            node.barycenter += child.barycenter;\n            numInvolvedChildren++;\n          }\n        });\n        if (numInvolvedChildren > 0) node.barycenter /= numInvolvedChildren;\n\n        node.children.sort((a, b) => {\n          if (Number.isNaN(a.barycenter) || Number.isNaN(b.barycenter))\n            return 0;\n          if (a.barycenter == b.barycenter) return 0;\n          else return a.barycenter > b.barycenter ? 1 : -1;\n        });\n      }\n    };\n\n    traverse(tree);\n  }\n\n  __getLeafNodes() {\n    let leaves = {};\n    this.__forEachNodeDepthFirst((node, depth, t) => {\n      if (!node.children) {\n        if (!leaves[t]) leaves[t] = [];\n        leaves[t].push(node);\n      }\n    });\n    return leaves;\n  }\n\n  __getAdjacencyMatrices(leaves) {\n    let M = [];\n    for (let t in this._timesteps) {\n      let left = leaves[t];\n      let right = leaves[+t + 1];\n      if (right)\n        // skip the last timestep\n        M[t] = this.__getAdjacencyMatrix(left, right);\n    }\n    return M;\n  }\n\n  __getAdjacencyMatrix(left, right) {\n    let targetLookup = {};\n    let M = [];\n    for (let i = 0; i < left.length; i++) {\n      M[i] = Array(right.length).fill(0);\n      for (let j = 0; j < right.length; j++) targetLookup[right[j].id] = j;\n      // set edges to 1\n      if (left[i].next)\n        for (let next of left[i].next) {\n          // only if the edge goes to one of the leaf nodes\n          if (typeof M[i][targetLookup[next.id]] !== 'undefined')\n            M[i][targetLookup[next.id]] = 1;\n        }\n    }\n    return M;\n  }\n\n  // variable names match the equation given in the paper by Sugiyama et al.\n  __getNumCrossings(matrix) {\n    let crossings = 0;\n    let p = matrix.length; // row length (num of leaves in the left layer)\n    let q = matrix[0].length; // column length\n    for (let j = 0; j < p - 1; j++)\n      for (let k = j + 1; k < p; k++)\n        for (let a = 0; a < q - 1; a++)\n          for (let b = a + 1; b < q; b++)\n            crossings += matrix[j][b] * matrix[k][a];\n    return crossings;\n  }\n\n  __getBarycenterRow(matrix, row) {\n    let barycenter = 0;\n    let sum = 0;\n    let q = matrix[0].length;\n\n    for (let l = 0; l < q; l++) {\n      barycenter += (l + 1) * matrix[row][l];\n      sum += matrix[row][l];\n    }\n    return barycenter / sum; // || 0;\n  }\n\n  __getBarycenterCol(matrix, col) {\n    let barycenter = 0;\n    let sum = 0;\n    let p = matrix.length;\n\n    for (let l = 0; l < p; l++) {\n      barycenter += (l + 1) * matrix[l][col];\n      sum += matrix[l][col];\n    }\n    return barycenter / sum; //|| 0;\n  }\n\n  // sort all children of a node by their number of children\n  __sortChildrenByNumChildren() {\n    for (let t in this._timesteps) {\n      let nodes = this._timesteps[t].references;\n      for (let id in nodes) {\n        let node = nodes[id];\n        if (node.children)\n          node.children.sort((a, b) => {\n            if (a.children && b.children)\n              return a.children.length > b.children.length ? 1 : -1;\n            else if (a.children) return 1;\n            else return -1;\n          });\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1JbnB1dERhdGEuanM/ZGZkOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQWU7QUFDZiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxNQUFNLHlDQUF5QyxHQUFHLGVBQWUsRUFBRTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEdBQUc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBOztBQUVBLHNDQUFzQyxFQUFFLElBQUksR0FBRyxNQUFNLE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLG1CQUFtQixXQUFXO0FBQzlCLHlCQUF5QixPQUFPO0FBQ2hDLHVCQUF1QixXQUFXO0FBQ2xDLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9TcGxpdFN0cmVhbUlucHV0RGF0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0U3RyZWFtSW5wdXREYXRhIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fb3B0cyA9IHtcbiAgICAgIGZvcmNlRmFrZVJvb3Q6IGZhbHNlLFxuICAgICAgb3JkZXI6IHtcbiAgICAgICAgbmFtZTogJ21pbmltaXplRWRnZUNyb3NzaW5ncycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBpdGVyYXRpb25zOiAyMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyAvLyBvdmVyd3JpdGUgZGVmYXVsdCBzZXR0aW5ncyB3aXRoIHVzZXIgc2V0dGluZ3NcbiAgICB9O1xuICAgIC8vIGhvbGQgYSB0cmVlIChyb290IG5vZGUpIGZvciBlYWNoIHRpbWVzdGVwXG4gICAgLy8gaG9sZCBhIHJlZmVyZW5jZSBhcnJheSB3aGljaCBpbmNsdWRlcyBhbGwgbm9kZXMgcHJlc2VudCBpbiBhIHNpbmdsZSB0aW1lc3RlcFxuICAgIC8vIFRPRE86IGlmIHRpbWVzdGVwcyBkbyBub3Qgc3RhcnQgd2l0aCAwLCBmb3IgLi4uIG9mIGxvb3BzIGdpdmUgYmFjayB1bmRlZmluZWQgdW50aWwgdGhlIGZpcnN0IHRpbWVzdGVwIGlzIHJlYWNoZWRcbiAgICAvLyBUT0RPOiBUaGUgcHJvYmxlbSBpcyB0aGF0IGFuIGFycmF5IGRvZXMgY29udGFpbiBhbGwgaW5iZXR3ZWVuIHZhbHVlcywgYnV0IGEgZm9yIC4uLiBpbiBsb29wIGluIGFuIG9iamVjdCBjb252ZXJ0cyBudW1iZXJzIHRvIHN0cmluZ3MgYWdhaW5cbiAgICAvLyBtYXliZSBwcm92ZSBhIG5leHRUaW1lc3RlcCBmdW5jdGlvbiBmb3IgY29udmVuaWVuY2VcbiAgICAvLyBvciBzdG9yZSB0aGUga2V5cyBmb3IgdGltZXN0ZXBzIGluIGFuIGluZGl2aWR1YWwgYXJyYXkgYW5kIHVzZSBpbnRlZ2VyIGluZGljZXMgZnJvbSAwIHRvIG4gaW50ZXJuYWxseVxuICAgIC8vIGFsc28gcmVxdWlyZXMgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gbm90IHdyaXRlICt0ICsgMSBldmVyeSB0aW1lXG4gICAgdGhpcy5fdGltZXN0ZXBzID0ge307XG4gICAgdGhpcy5fbnVtTm9kZXMgPSAwO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHsgdGltZXN0ZXBzOiB0aGlzLl90aW1lc3RlcHMsIG51bU5vZGVzOiB0aGlzLl9udW1Ob2RlcyB9O1xuICB9XG5cbiAgYWRkTm9kZSh0LCBpZCwgc2l6ZSA9IHVuZGVmaW5lZCwgcG9zID0gdW5kZWZpbmVkLCBkYXRhID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCF0aGlzLl90aW1lc3RlcHNbdF0pIHRoaXMuX2NyZWF0ZVRpbWVzdGVwKHQpO1xuXG4gICAgaWYgKCF0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlc1tpZF0pIHtcbiAgICAgIGxldCBkYXRhU2l6ZSA9ICtzaXplO1xuICAgICAgbGV0IGRhdGFQb3MgPSArcG9zO1xuICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgLy8gc2l6ZSA9ICtzaXplO1xuICAgICAgLy8gcG9zID0gK3BvcztcbiAgICAgIHRoaXMuX3RpbWVzdGVwc1t0XS5yZWZlcmVuY2VzW2lkXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGFTaXplLFxuICAgICAgICBkYXRhUG9zLFxuICAgICAgICBzaXplLFxuICAgICAgICBwb3MsXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgICB0aGlzLl9udW1Ob2RlcysrO1xuICAgIH0gZWxzZTsgLy8gY29uc29sZS5sb2coYFdhcm5pbmcgQWRkTm9kZTogTm9kZSAke2lkfSBhdCB0aW1lc3RlcCAke3R9IGV4aXN0cyBhbHJlYWR5LmApO1xuICB9XG5cbiAgYWRkUGFyZW50KHQsIGlkLCBwSWQpIHtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlcztcbiAgICBsZXQgbm9kZSA9IG5vZGVzW2lkXTtcbiAgICBsZXQgcGFyZW50ID0gbm9kZXNbcElkXTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBFcnJvciAnYWRkUGFyZW50JzogTm9kZSAnJHtpZH0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYEVycm9yICdhZGRQYXJlbnQnOiBQYXJlbnQgbm9kZSAnJHtwSWR9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQuY2hpbGRyZW4pIHBhcmVudC5jaGlsZHJlbiA9IFtdO1xuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICB9XG5cbiAgYWRkTmV4dCh0LCBpZCwgbmV4dElkKSB7XG4gICAgbGV0IHRpbWUxID0gdGhpcy5fdGltZXN0ZXBzW3RdO1xuICAgIGxldCB0aW1lMiA9IHRoaXMuX3RpbWVzdGVwc1srdCArIDFdO1xuICAgIGlmICghdGltZTEgfHwgIXRpbWUyKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgRXJyb3IgJ2FkZE5leHQnOiBUaW1lc3RlcCAnJHsrdCArIDF9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHRpbWUxLnJlZmVyZW5jZXNbaWRdO1xuICAgIGxldCBuZXh0Tm9kZSA9IHRpbWUyLnJlZmVyZW5jZXNbbmV4dElkXTtcbiAgICBpZiAoIW5vZGUgfHwgIW5leHROb2RlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgRXJyb3IgJ2FkZE5leHQnOiBOb2RlICcke2lkfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coYENoYW5nZSB0aW1lc3RlcCAke3R9OiAke2lkfSB0byAke25leHRJZH1gKTtcbiAgICBpZiAoIW5vZGUubmV4dCkgbm9kZS5uZXh0ID0gW107XG4gICAgbm9kZS5uZXh0LnB1c2gobmV4dE5vZGUpO1xuICAgIGlmICghbmV4dE5vZGUucHJldikgbmV4dE5vZGUucHJldiA9IFtdO1xuICAgIG5leHROb2RlLnByZXYucHVzaChub2RlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIHRoaXMuX2NoZWNrUGFyZW50cygpO1xuXG4gICAgdGhpcy5fX2ZvckVhY2hOb2RlRGVwdGhGaXJzdCgobm9kZSwgZGVwdGgsIHQpID0+IHtcbiAgICAgIG5vZGUueCA9ICt0O1xuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoO1xuICAgICAgdGhpcy5fc2V0U2l6ZUFuZEFnZ3JlZ2F0ZShub2RlKTtcbiAgICAgIHRoaXMuX2NoZWNrU2l6ZShub2RlKTtcbiAgICAgIHRoaXMuX2NoZWNrUG9zaXRpb25zKG5vZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX29wdHMub3JkZXIpXG4gICAgICBpZiAodGhpcy5fb3B0cy5vcmRlci5uYW1lID09ICdtaW5pbWl6ZUVkZ2VDcm9zc2luZ3MnKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRzLm9yZGVyLm9wdGlvbnMpXG4gICAgICAgICAgdGhpcy5taW5pbWl6ZUVkZ2VDcm9zc2luZ3ModGhpcy5fb3B0cy5vcmRlci5vcHRpb25zLml0ZXJhdGlvbnMpO1xuICAgICAgICBlbHNlIHRoaXMubWluaW1pemVFZGdlQ3Jvc3NpbmdzKCk7XG4gICAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSByb290IGhhdmUgYSBwYXJlbnRcbiAgLy8gaWYgbXVsdGlwbGUgcm9vdHMgZXhpc3QsIGNyZWF0ZSBhIGZha2Ugcm9vdFxuICBfY2hlY2tQYXJlbnRzKCkge1xuICAgIGxldCBub2Rlc1dpdGhvdXRQYXJlbnRzID0ge307XG4gICAgZm9yIChsZXQgdCBpbiB0aGlzLl90aW1lc3RlcHMpIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMuX3RpbWVzdGVwc1t0XS5yZWZlcmVuY2VzO1xuICAgICAgZm9yIChsZXQgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpZF07XG4gICAgICAgIGlmICghbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIW5vZGVzV2l0aG91dFBhcmVudHNbdF0pIG5vZGVzV2l0aG91dFBhcmVudHNbdF0gPSBbXTtcbiAgICAgICAgICBub2Rlc1dpdGhvdXRQYXJlbnRzW3RdLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZmFrZVJvb3ROZWVkZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB0IGluIG5vZGVzV2l0aG91dFBhcmVudHMpIHtcbiAgICAgIGlmIChub2Rlc1dpdGhvdXRQYXJlbnRzW3RdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZmFrZVJvb3ROZWVkZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFrZVJvb3ROZWVkZWQgfHwgdGhpcy5fb3B0cy5mb3JjZUZha2VSb290KSB7XG4gICAgICBsZXQgcHJldlQ7XG4gICAgICBmb3IgKGxldCB0IGluIG5vZGVzV2l0aG91dFBhcmVudHMpIHtcbiAgICAgICAgdGhpcy5hZGROb2RlKHQsICdmYWtlUm9vdCcpO1xuICAgICAgICBub2Rlc1dpdGhvdXRQYXJlbnRzW3RdLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRQYXJlbnQodCwgbm9kZS5pZCwgJ2Zha2VSb290Jyk7XG4gICAgICAgICAgdGhpcy5fdGltZXN0ZXBzW3RdLnRyZWUgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlc1snZmFrZVJvb3QnXTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbm5lY3QgZmFrZSByb290c1xuICAgICAgICBpZiAoISFwcmV2VCkge1xuICAgICAgICAgIHRoaXMuYWRkTmV4dChwcmV2VCwgJ2Zha2VSb290JywgJ2Zha2VSb290Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlQgPSB0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBldmVyeSB0aW1lcG9pbnQgaGFzIGEgc2luZ2xlIHJvb3Qgbm9kZVxuICAgICAgZm9yIChsZXQgdCBpbiBub2Rlc1dpdGhvdXRQYXJlbnRzKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlID0gbm9kZXNXaXRob3V0UGFyZW50c1t0XVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBub2RlIGRvZXMgbm90IGhhdmUgYSBzaXplLCBzZXQgaXQncyBzaXplIHRvIHRoZSBzdW0gb2YgdGhlIHNpemVzIG9mIGl0cyBjaGlsZHJlblxuICAvLyBpZiBhIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNpemUgYW5kIGRvZXMgbm90IGhhdmUgY2hpbGRyZW4sIGdpdmUgaXQgc2l6ZSAxXG4gIF9zZXRTaXplQW5kQWdncmVnYXRlKG5vZGUpIHtcbiAgICBpZiAoISFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmFnZ3JlZ2F0ZSA9IDA7XG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSBub2RlLmFnZ3JlZ2F0ZSArPSBjaGlsZC5kYXRhU2l6ZTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4obm9kZS5kYXRhU2l6ZSkpIG5vZGUuZGF0YVNpemUgPSBub2RlLmFnZ3JlZ2F0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE51bWJlci5pc05hTihub2RlLmRhdGFTaXplKSkgbm9kZS5kYXRhU2l6ZSA9IDE7XG4gICAgICBub2RlLmFnZ3JlZ2F0ZSA9IG5vZGUuZGF0YVNpemU7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrU2l6ZShub2RlKSB7XG4gICAgaWYgKG5vZGUuZGF0YVNpemUgPCBub2RlLmFnZ3JlZ2F0ZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ0Vycm9yOiBOb2RlIGhhcyBhIHNtYWxsZXIgc2l6ZSB0aGFuIGl0cyBjaGlsZHJlbi4nKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHNpemUgb2YgcGFyZW50IGVsZW1lbnRzIGlzIGJpZ2dlciB0aGFuIHRoZSBhZ2dyZWdhdGUgb2YgdGhlIHNpemVzIG9mIGl0cyBjaGlsZHJlblxuICBfY2hlY2tQb3NpdGlvbnMobm9kZSkge1xuICAgIGlmICghIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGxldCBtaW5Qb3MgPSAwO1xuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQucG9zID49IDApIHtcbiAgICAgICAgICBpZiAobWluUG9zID4gY2hpbGQucG9zKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRXJyb3I6IENoaWxkcmVuIHBvc2l0aW9ucyBvdmVybGFwIGVhY2ggb3RoZXIuJyk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWluUG9zID0gY2hpbGQucG9zICsgY2hpbGQuZGF0YVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2ZvckVhY2hOb2RlRGVwdGhGaXJzdChjYWxsYmFjaykge1xuICAgIGxldCB0cmF2ZXJzZSA9IGZ1bmN0aW9uKG5vZGUsIGRlcHRoLCB0KSB7XG4gICAgICBpZiAoISFub2RlLmNoaWxkcmVuKVxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdHJhdmVyc2UoY2hpbGQsIGRlcHRoICsgMSwgdCkpO1xuICAgICAgY2FsbGJhY2sobm9kZSwgZGVwdGgsIHQpO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCB0IGluIHRoaXMuX3RpbWVzdGVwcykgdHJhdmVyc2UodGhpcy5fdGltZXN0ZXBzW3RdLnRyZWUsIDAsIHQpO1xuICB9XG5cbiAgX2NyZWF0ZVRpbWVzdGVwKHQpIHtcbiAgICB0aGlzLl90aW1lc3RlcHNbdF0gPSB7XG4gICAgICByZWZlcmVuY2VzOiB7fSxcbiAgICAgIHRyZWU6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLy8gY29ubmVjdCBub2RlcyB3aGljaCBoYXZlIHRoZSBzYW1lIElEIGluIGNvbnNlY3V0aXZlIHRpbWVzdGVwc1xuICBjb25uZWN0RXF1YWxJZHMoKSB7XG4gICAgZm9yIChsZXQgdCBpbiB0aGlzLl90aW1lc3RlcHMpIHtcbiAgICAgIGlmICghIXRoaXMuX3RpbWVzdGVwc1srdCArIDFdKSB7XG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuX3RpbWVzdGVwc1t0XS5yZWZlcmVuY2VzO1xuICAgICAgICBsZXQgbm9kZXMyID0gdGhpcy5fdGltZXN0ZXBzWyt0ICsgMV0ucmVmZXJlbmNlcztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgICBpZiAoISFub2RlczJbaWRdKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgYnVpbGQgY29ubmVjdGlvbnMgaWYgdGhlIG5vZGVzIG5leHQgZWxlbWVudHMgd2VyZSBtYW51YWxseSBzZXRcbiAgICAgICAgICAgIGlmICghbm9kZXNbaWRdLm5leHQpIG5vZGVzW2lkXS5uZXh0ID0gW107XG4gICAgICAgICAgICBpZiAoIW5vZGVzMltpZF0ucHJldikgbm9kZXMyW2lkXS5wcmV2ID0gW107XG5cbiAgICAgICAgICAgIG5vZGVzW2lkXS5uZXh0LnB1c2gobm9kZXMyW2lkXSk7XG4gICAgICAgICAgICBub2RlczJbaWRdLnByZXYucHVzaChub2Rlc1tpZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvbGxvd2luZyB0aGUgYWxnb3JpdGhtIGJ5IFNoaXhpYSBMaXUgZXQgYWwuIGluIFN0b3J5RmxvdywgYmFzZWQgb25cbiAgLy8gTWV0aG9kcyBmb3IgVmlzdWFsIFVuZGVyc3RhbmRpbmcgb2YgSGllcmFyY2hpY2FsIFN5c3RlbSBTdHJ1Y3R1cmVzIGJ5IFN1Z2l5YW1hIGV0IGFsLlxuICBtaW5pbWl6ZUVkZ2VDcm9zc2luZ3MoaXRlcmF0aW9ucyA9IDIwKSB7XG4gICAgLy8gY3JlYXRlIHQtMSBhZGphY2VuY3kgbWF0cmljZXMgZm9yIGxlYXZlIG5vZGVzXG4gICAgbGV0IGxlYXZlcyA9IHRoaXMuX19nZXRMZWFmTm9kZXMoKTtcbiAgICBsZXQgTSA9IHRoaXMuX19nZXRBZGphY2VuY3lNYXRyaWNlcyhsZWF2ZXMpO1xuICAgIGxldCB0aW1lc3RlcHMgPSBPYmplY3Qua2V5cyh0aGlzLl90aW1lc3RlcHMpO1xuXG4gICAgbGV0IGNhbGN1bGF0ZUJhcnljZW50ZXJDb2xzID0gdCA9PiB7XG4gICAgICBmb3IgKGxldCBsIGluIGxlYXZlc1t0XSlcbiAgICAgICAgbGVhdmVzW3RdW2xdLmJhcnljZW50ZXIgPSB0aGlzLl9fZ2V0QmFyeWNlbnRlckNvbChNW3QgLSAxXSwgbCk7XG4gICAgfTtcblxuICAgIGxldCBjYWxjdWxhdGVCYXJ5Y2VudGVyUm93cyA9IHQgPT4ge1xuICAgICAgZm9yIChsZXQgbCBpbiBsZWF2ZXNbdF0pXG4gICAgICAgIGxlYXZlc1t0XVtsXS5iYXJ5Y2VudGVyID0gdGhpcy5fX2dldEJhcnljZW50ZXJSb3coTVt0XSwgbCk7XG4gICAgfTtcblxuICAgIGxldCByZW9yZGVyID0gdCA9PiB7XG4gICAgICB0aGlzLl9fb3JkZXJCeUJhcnljZW50ZXIodGhpcy5fdGltZXN0ZXBzW3RdLnRyZWUpO1xuICAgICAgbGV0IG5ld09yZGVyID0gdGhpcy5fX2dldE5ld09yZGVyKHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlKTtcbiAgICAgIGFwcGx5T3JkZXIodCwgbmV3T3JkZXIpO1xuICAgIH07XG5cbiAgICBsZXQgYXBwbHlPcmRlciA9ICh0LCBvcmRlcikgPT4ge1xuICAgICAgLy8gcmVvcmRlciBtYXRyaXggcm93c1xuICAgICAgaWYgKE1bdF0pIE1bdF0gPSBvcmRlci5tYXAoaSA9PiBNW3RdW2ldKTtcbiAgICAgIC8vIHJlb3JkZXIgc2FtZSBub2RlcyBpbiBwcmV2aW91cyBtYXRyaXggY29sdW1uc1xuICAgICAgaWYgKE1bdCAtIDFdKVxuICAgICAgICBNW3QgLSAxXS5mb3JFYWNoKChyb3csIGkpID0+IChNW3QgLSAxXVtpXSA9IG9yZGVyLm1hcChpID0+IHJvd1tpXSkpKTtcbiAgICAgIC8vIHJlb3JkZXIgbGVhZiBhcnJheVxuICAgICAgbGVhdmVzW3RdID0gb3JkZXIubWFwKGkgPT4gbGVhdmVzW3RdW2ldKTtcbiAgICB9O1xuXG4gICAgLy9zd2VlcCByaWdodCwgcmVvcmRlciBjb2x1bW5zIGJhc2VkIG9uIGJhcnljZW50ZXJzXG4gICAgbGV0IHBoYXNlMURvd24gPSAoKSA9PiB7XG4gICAgICBmb3IgKGxldCB0SWQgPSAxOyB0SWQgPCB0aW1lc3RlcHMubGVuZ3RoOyB0SWQrKykge1xuICAgICAgICBsZXQgdCA9IHRpbWVzdGVwc1t0SWRdO1xuICAgICAgICBjYWxjdWxhdGVCYXJ5Y2VudGVyQ29scyh0KTtcbiAgICAgICAgcmVvcmRlcih0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3dlZXAgbGVmdCwgcmVvcmRlciByb3dzXG4gICAgbGV0IHBoYXNlMVVwID0gKCkgPT4ge1xuICAgICAgZm9yIChsZXQgdElkID0gdGltZXN0ZXBzLmxlbmd0aCAtIDI7IHRJZCA+PSAwOyB0SWQtLSkge1xuICAgICAgICBsZXQgdCA9IHRpbWVzdGVwc1t0SWRdO1xuICAgICAgICBjYWxjdWxhdGVCYXJ5Y2VudGVyUm93cyh0KTtcbiAgICAgICAgcmVvcmRlcih0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3dlZXAgcmlnaHQsIHJldmVyc2Ugb3JkZXIgb2Ygbm9kZXMgd2l0aCBlcXVhbCBiYXJ5Y2VudGVyXG4gICAgbGV0IHBoYXNlMkRvd24gPSAoKSA9PiB7XG4gICAgICBmb3IgKGxldCB0SWQgPSAxOyB0SWQgPCB0aW1lc3RlcHMubGVuZ3RoOyB0SWQrKykge1xuICAgICAgICBsZXQgdCA9IHRpbWVzdGVwc1t0SWRdO1xuICAgICAgICBjYWxjdWxhdGVCYXJ5Y2VudGVyQ29scyh0KTtcbiAgICAgICAgdGhpcy5fX3JldmVyc2VFcXVhbEJhcnljZW50ZXJzKHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlKTtcbiAgICAgICAgbGV0IG5ld09yZGVyID0gdGhpcy5fX2dldE5ld09yZGVyKHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlKTtcbiAgICAgICAgYXBwbHlPcmRlcih0LCBuZXdPcmRlcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBwaGFzZTJVcCA9ICgpID0+IHtcbiAgICAgIGZvciAobGV0IHRJZCA9IHRpbWVzdGVwcy5sZW5ndGggLSAyOyB0SWQgPj0gMDsgdElkLS0pIHtcbiAgICAgICAgbGV0IHQgPSB0aW1lc3RlcHNbdElkXTtcbiAgICAgICAgY2FsY3VsYXRlQmFyeWNlbnRlclJvd3ModCk7XG4gICAgICAgIHRoaXMuX19yZXZlcnNlRXF1YWxCYXJ5Y2VudGVycyh0aGlzLl90aW1lc3RlcHNbdF0udHJlZSk7XG4gICAgICAgIGxldCBuZXdPcmRlciA9IHRoaXMuX19nZXROZXdPcmRlcih0aGlzLl90aW1lc3RlcHNbdF0udHJlZSk7XG4gICAgICAgIGFwcGx5T3JkZXIodCwgbmV3T3JkZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgaWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgcGhhc2UxRG93bigpO1xuICAgICAgICBwaGFzZTJEb3duKCk7XG4gICAgICAgIHBoYXNlMlVwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaGFzZTFVcCgpO1xuICAgICAgICBwaGFzZTJVcCgpO1xuICAgICAgICBwaGFzZTJEb3duKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHN0b3AgaWYgYWxsIHJvd3MgYW5kIGNvbHVtbnMgYXJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBubyBvcmRlciBjaGFuZ2VkIGluIGFuIGl0ZXJhdGlvblxuICAgIH1cbiAgfVxuXG4gIC8vIHRha2VzIGFuIGFycmF5IG9mIGJhcnljZW50ZXIgdmFsdWVzIGFzIGlucHV0XG4gIC8vIG91dHB1dHMgYW4gYXJyYXkgb2YgbmV3IGluZGljZXMsIHdoZXJlIGVsZW1lbnRzIHdpdGggZXF1YWwgdmFsdWVzIGFyZSByZXZlcnNlZFxuICBfX3JldmVyc2VJbmRpY2VzT2ZFcXVhbFZhbHVlcyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAvLyBjcmVhdGUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZm9yIGVhY2ggdmFsdWUgYW4gYXJyYXkgb2YgaW5kaWNlcyB0aGF0IGhhdmUgdGhpcyB2YWx1ZVxuICAgIGxldCBlcXVhbHMgPSB7fTtcbiAgICBhcnJheS5mb3JFYWNoKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgaWYgKCFlcXVhbHNbdmFsXSkgZXF1YWxzW3ZhbF0gPSBbXTtcbiAgICAgIGVxdWFsc1t2YWxdLnB1c2goaWR4KTtcbiAgICB9KTtcbiAgICAvLyBmb3IgZWFjaCB2YWx1ZSByZXZlcnNlIHRoZSBpbmRleCBvcmRlclxuICAgIGZvciAobGV0IHZhbCBpbiBlcXVhbHMpIHtcbiAgICAgIGxldCBpbmRpY2VzID0gZXF1YWxzW3ZhbF07XG4gICAgICBpbmRpY2VzLmZvckVhY2goKGlkeCwgaSkgPT4ge1xuICAgICAgICByZXN1bHRbaWR4XSA9IGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSBpIC0gMV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9fcmV2ZXJzZUVxdWFsQmFyeWNlbnRlcnModHJlZSkge1xuICAgIGxldCBudW1MZWF2ZXMgPSAwO1xuICAgIGxldCB0cmF2ZXJzZSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSBub2RlLmJjTWF0cml4UG9zaXRpb24gPSBudW1MZWF2ZXMrKztcbiAgICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdHJhdmVyc2UoY2hpbGQpKTtcbiAgICAgICAgLy8gZXh0cmFjdCBhbiBhcnJheSBvZiBiYXJ5Y2VudGVycyBpbiBvcmRlclxuICAgICAgICBsZXQgYmFyeWNlbnRlckFycmF5ID0gbm9kZS5jaGlsZHJlbi5tYXAoZCA9PiBkLmJhcnljZW50ZXIpO1xuICAgICAgICAvLyByZXZlcnNlIHRoZSBvcmRlciBvZiBlcXVhbCBiYXJ5Y2VudGVyc1xuICAgICAgICBsZXQgbmV3T3JkZXIgPSB0aGlzLl9fcmV2ZXJzZUluZGljZXNPZkVxdWFsVmFsdWVzKGJhcnljZW50ZXJBcnJheSk7XG4gICAgICAgIC8vIHJlb3JkZXIgY2hpbGRyZW5cbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ld09yZGVyLm1hcChpZHggPT4gbm9kZS5jaGlsZHJlbltpZHhdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyYXZlcnNlKHRyZWUpO1xuICB9XG5cbiAgX19nZXROZXdPcmRlcih0cmVlKSB7XG4gICAgbGV0IG9yZGVyID0gW107XG4gICAgbGV0IG5ld0xlYWZPcmRlciA9IG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBuZXdMZWFmT3JkZXIoY2hpbGQpKTtcbiAgICAgIGVsc2Ugb3JkZXIucHVzaChub2RlLmJjTWF0cml4UG9zaXRpb24pO1xuICAgIH07XG4gICAgbmV3TGVhZk9yZGVyKHRyZWUpO1xuICAgIHJldHVybiBvcmRlcjtcbiAgfVxuXG4gIC8vIGJjTWF0cml4UmFuZ2UgZGVmaW5lcyB0aGUgYXJlYSBvZiB0aGUgYWRqYWNlbmN5IG1hdHJpeCBpbiB3aGljaCB0aGUgbm9kZSBoYXMgaW5mbHVlbmNlXG4gIC8vIHRoaXMgaXMgbmVjZXNhc3J5IGJlY2F1c2Ugb2YgaGllcmFyY2h5IG5vZGVzIHRoYXQgc3BhbiBhIHdpZGVyIHJhbmdlXG4gIF9fb3JkZXJCeUJhcnljZW50ZXIodHJlZSkge1xuICAgIGxldCBudW1MZWF2ZXMgPSAwO1xuICAgIGxldCB0cmF2ZXJzZSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSBub2RlLmJjTWF0cml4UG9zaXRpb24gPSBudW1MZWF2ZXMrKztcbiAgICAgIGVsc2Uge1xuICAgICAgICBub2RlLmJhcnljZW50ZXIgPSAwOyAvLyBoaWVyYXJjaHkgbm9kZXMgZ2V0IHRoZSBhdmVyYWdlIG9mIHRoZWlyIGNoaWxkcmVucycgYmFyeWNlbnRlclxuICAgICAgICBsZXQgbnVtSW52b2x2ZWRDaGlsZHJlbiA9IDA7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICB0cmF2ZXJzZShjaGlsZCk7XG4gICAgICAgICAgLy8gY2hpbGQuaW5kZXggPSBpOyAvLyBzdG9yZSBwcmV2aW91cyBjaGlsZCBpbmRleFxuICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGNoaWxkLmJhcnljZW50ZXIpKSB7XG4gICAgICAgICAgICBub2RlLmJhcnljZW50ZXIgKz0gY2hpbGQuYmFyeWNlbnRlcjtcbiAgICAgICAgICAgIG51bUludm9sdmVkQ2hpbGRyZW4rKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobnVtSW52b2x2ZWRDaGlsZHJlbiA+IDApIG5vZGUuYmFyeWNlbnRlciAvPSBudW1JbnZvbHZlZENoaWxkcmVuO1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYS5iYXJ5Y2VudGVyKSB8fCBOdW1iZXIuaXNOYU4oYi5iYXJ5Y2VudGVyKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGlmIChhLmJhcnljZW50ZXIgPT0gYi5iYXJ5Y2VudGVyKSByZXR1cm4gMDtcbiAgICAgICAgICBlbHNlIHJldHVybiBhLmJhcnljZW50ZXIgPiBiLmJhcnljZW50ZXIgPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmF2ZXJzZSh0cmVlKTtcbiAgfVxuXG4gIF9fZ2V0TGVhZk5vZGVzKCkge1xuICAgIGxldCBsZWF2ZXMgPSB7fTtcbiAgICB0aGlzLl9fZm9yRWFjaE5vZGVEZXB0aEZpcnN0KChub2RlLCBkZXB0aCwgdCkgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbGVhdmVzW3RdKSBsZWF2ZXNbdF0gPSBbXTtcbiAgICAgICAgbGVhdmVzW3RdLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxuXG4gIF9fZ2V0QWRqYWNlbmN5TWF0cmljZXMobGVhdmVzKSB7XG4gICAgbGV0IE0gPSBbXTtcbiAgICBmb3IgKGxldCB0IGluIHRoaXMuX3RpbWVzdGVwcykge1xuICAgICAgbGV0IGxlZnQgPSBsZWF2ZXNbdF07XG4gICAgICBsZXQgcmlnaHQgPSBsZWF2ZXNbK3QgKyAxXTtcbiAgICAgIGlmIChyaWdodClcbiAgICAgICAgLy8gc2tpcCB0aGUgbGFzdCB0aW1lc3RlcFxuICAgICAgICBNW3RdID0gdGhpcy5fX2dldEFkamFjZW5jeU1hdHJpeChsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBNO1xuICB9XG5cbiAgX19nZXRBZGphY2VuY3lNYXRyaXgobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgdGFyZ2V0TG9va3VwID0ge307XG4gICAgbGV0IE0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIE1baV0gPSBBcnJheShyaWdodC5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJpZ2h0Lmxlbmd0aDsgaisrKSB0YXJnZXRMb29rdXBbcmlnaHRbal0uaWRdID0gajtcbiAgICAgIC8vIHNldCBlZGdlcyB0byAxXG4gICAgICBpZiAobGVmdFtpXS5uZXh0KVxuICAgICAgICBmb3IgKGxldCBuZXh0IG9mIGxlZnRbaV0ubmV4dCkge1xuICAgICAgICAgIC8vIG9ubHkgaWYgdGhlIGVkZ2UgZ29lcyB0byBvbmUgb2YgdGhlIGxlYWYgbm9kZXNcbiAgICAgICAgICBpZiAodHlwZW9mIE1baV1bdGFyZ2V0TG9va3VwW25leHQuaWRdXSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBNW2ldW3RhcmdldExvb2t1cFtuZXh0LmlkXV0gPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNO1xuICB9XG5cbiAgLy8gdmFyaWFibGUgbmFtZXMgbWF0Y2ggdGhlIGVxdWF0aW9uIGdpdmVuIGluIHRoZSBwYXBlciBieSBTdWdpeWFtYSBldCBhbC5cbiAgX19nZXROdW1Dcm9zc2luZ3MobWF0cml4KSB7XG4gICAgbGV0IGNyb3NzaW5ncyA9IDA7XG4gICAgbGV0IHAgPSBtYXRyaXgubGVuZ3RoOyAvLyByb3cgbGVuZ3RoIChudW0gb2YgbGVhdmVzIGluIHRoZSBsZWZ0IGxheWVyKVxuICAgIGxldCBxID0gbWF0cml4WzBdLmxlbmd0aDsgLy8gY29sdW1uIGxlbmd0aFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcCAtIDE7IGorKylcbiAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IHA7IGsrKylcbiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBxIC0gMTsgYSsrKVxuICAgICAgICAgIGZvciAobGV0IGIgPSBhICsgMTsgYiA8IHE7IGIrKylcbiAgICAgICAgICAgIGNyb3NzaW5ncyArPSBtYXRyaXhbal1bYl0gKiBtYXRyaXhba11bYV07XG4gICAgcmV0dXJuIGNyb3NzaW5ncztcbiAgfVxuXG4gIF9fZ2V0QmFyeWNlbnRlclJvdyhtYXRyaXgsIHJvdykge1xuICAgIGxldCBiYXJ5Y2VudGVyID0gMDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgcSA9IG1hdHJpeFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IHE7IGwrKykge1xuICAgICAgYmFyeWNlbnRlciArPSAobCArIDEpICogbWF0cml4W3Jvd11bbF07XG4gICAgICBzdW0gKz0gbWF0cml4W3Jvd11bbF07XG4gICAgfVxuICAgIHJldHVybiBiYXJ5Y2VudGVyIC8gc3VtOyAvLyB8fCAwO1xuICB9XG5cbiAgX19nZXRCYXJ5Y2VudGVyQ29sKG1hdHJpeCwgY29sKSB7XG4gICAgbGV0IGJhcnljZW50ZXIgPSAwO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBwID0gbWF0cml4Lmxlbmd0aDtcblxuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgcDsgbCsrKSB7XG4gICAgICBiYXJ5Y2VudGVyICs9IChsICsgMSkgKiBtYXRyaXhbbF1bY29sXTtcbiAgICAgIHN1bSArPSBtYXRyaXhbbF1bY29sXTtcbiAgICB9XG4gICAgcmV0dXJuIGJhcnljZW50ZXIgLyBzdW07IC8vfHwgMDtcbiAgfVxuXG4gIC8vIHNvcnQgYWxsIGNoaWxkcmVuIG9mIGEgbm9kZSBieSB0aGVpciBudW1iZXIgb2YgY2hpbGRyZW5cbiAgX19zb3J0Q2hpbGRyZW5CeU51bUNoaWxkcmVuKCkge1xuICAgIGZvciAobGV0IHQgaW4gdGhpcy5fdGltZXN0ZXBzKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlcztcbiAgICAgIGZvciAobGV0IGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaWRdO1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbilcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLmNoaWxkcmVuICYmIGIuY2hpbGRyZW4pXG4gICAgICAgICAgICAgIHJldHVybiBhLmNoaWxkcmVuLmxlbmd0aCA+IGIuY2hpbGRyZW4ubGVuZ3RoID8gMSA6IC0xO1xuICAgICAgICAgICAgZWxzZSBpZiAoYS5jaGlsZHJlbikgcmV0dXJuIDE7XG4gICAgICAgICAgICBlbHNlIHJldHVybiAtMTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SplitStreamInputData.js\n"
          );

          /***/
        },

      /***/ './src/SvgPath.js':
        /*!************************!*\
  !*** ./src/SvgPath.js ***!
  \************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SvgPath; });\nconst ACTION = {\n  MOVE: 0,\n  MOVE_D: 1,\n  LINE: 2,\n  LINE_D: 3,\n  HORIZONTAL: 4,\n  HORIZONTAL_D: 5,\n  VERTICAL: 6,\n  VERTICAL_D: 7,\n  BEZIER: 8,\n  BEZIER_D: 9,\n  ARC: 10\n};\n\nclass SvgPath {\n  constructor() {\n    this._path = '';\n    this._x;\n    this._y;\n    this._precision = 2;\n    this._lastAction;\n  }\n\n  // ignore a change, if its end coordinate is the same as its current position\n  _pathWillChange(x, y) {\n    if (Number.isNaN(x) || Number.isNaN(y)); //debugger;\n    if (x !== this._x || y !== this._y) {\n      this._x = x;\n      this._y = y;\n      return true;\n    }\n    return false;\n  }\n\n  _applyPrecision(...numbers) {\n    return numbers.map(d => +d.toFixed(this._precision));\n  }\n\n  get() {\n    return this._path;\n  }\n\n  move(x, y) {\n    [x, y] = this._applyPrecision(x, y);\n    if (this._pathWillChange(x, y)) {\n      if (this._lastAction == ACTION.MOVE)\n        // remove last move from string\n        this._path = this._path.slice(0, this._path.lastIndexOf('M'));\n      this._path += 'M ' + x + ' ' + y + ' ';\n      this._lastAction = ACTION.MOVE;\n    }\n  }\n\n  moveD(dx, dy) {\n    [dx, dy] = this._applyPrecision(dx, dy);\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\n      this._path += 'm ' + dx + ' ' + dy + ' ';\n      this._lastAction = ACTION.MOVE_D;\n    }\n  }\n\n  line(x, y) {\n    [x, y] = this._applyPrecision(x, y);\n    if (this._pathWillChange(x, y)) {\n      this._path += 'L ' + x + ' ' + y + ' ';\n      this._lastAction = ACTION.LINE;\n    }\n  }\n\n  lineD(dx, dy) {\n    [dx, dy] = this._applyPrecision(dx, dy);\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\n      this._path += 'l ' + dx + ' ' + dy + ' ';\n      this._lastAction = ACTION.LINE_D;\n    }\n  }\n\n  horizontal(x) {\n    [x] = this._applyPrecision(x);\n    if (this._pathWillChange(x, this._y)) {\n      if (this._lastAction == ACTION.HORIZONTAL)\n        // remove last move from string\n        this._path = this._path.slice(0, this._path.lastIndexOf('H'));\n      this._path += 'H ' + x + ' ';\n      this._lastAction = ACTION.HORIZONTAL;\n    }\n  }\n\n  horizontalD(dx) {\n    [dx] = this._applyPrecision(dx);\n    if (this._pathWillChange(this._x + dx, this._y)) {\n      this._path += 'h ' + dx + ' ';\n      this._lastAction = ACTION.HORIZONTAL_D;\n    }\n  }\n\n  vertical(y) {\n    [y] = this._applyPrecision(y);\n    if (this._pathWillChange(this._x, y)) {\n      if (this._lastAction == ACTION.VERTICAL)\n        // remove last move from string\n        this._path = this._path.slice(0, this._path.lastIndexOf('V'));\n      this._path += 'V ' + y + ' ';\n      this._lastAction = ACTION.VERTICAL;\n    }\n  }\n\n  verticalD(dy) {\n    [dy] = this._applyPrecision(dy);\n    if (this._pathWillChange(this._x, this._y + dy)) {\n      this._path += 'v ' + dy + ' ';\n      this._lastAction = ACTION.VERTICAL_D;\n    }\n  }\n\n  bezier(x1, y1, x2, y2, x, y) {\n    [x1, y1, x2, y2, x, y] = this._applyPrecision(x1, y1, x2, y2, x, y);\n    if (this._pathWillChange(x, y)) {\n      this._path +=\n        'C ' + x1 + ' ' + y1 + ', ' + x2 + ' ' + y2 + ', ' + x + ' ' + y + ' ';\n      this._lastAction = ACTION.BEZIER;\n    }\n  }\n\n  bezierD(dx1, dy1, dx2, dy2, dx, dy) {\n    [dx1, dy1, dx2, dy2, dx, dy] = this._applyPrecision(\n      dx1,\n      dy1,\n      dx2,\n      dy2,\n      dx,\n      dy\n    );\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\n      this._path +=\n        'c ' +\n        dx1 +\n        ' ' +\n        dy1 +\n        ', ' +\n        dx2 +\n        ' ' +\n        dy2 +\n        ', ' +\n        dx +\n        ' ' +\n        dy +\n        ' ';\n      this._lastAction = ACTION.BEZIER_D;\n    }\n  }\n\n  arc(rx, ry, rot, largeArcFlag, sweepFlag, x, y) {\n    [rx, ry, rot, largeArcFlag, sweepFlag, x, y] = this._applyPrecision(\n      rx,\n      ry,\n      rot,\n      largeArcFlag,\n      sweepFlag,\n      x,\n      y\n    );\n    if (this._pathWillChange(x, y)) {\n      this._path +=\n        'A ' +\n        rx +\n        ' ' +\n        ry +\n        ' ' +\n        rot +\n        ' ' +\n        largeArcFlag +\n        ' ' +\n        sweepFlag +\n        ' ' +\n        x +\n        ' ' +\n        y +\n        ' ';\n      this._lastAction = ACTION.ARC;\n    }\n  }\n\n  close() {\n    this._path += 'Z';\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3ZnUGF0aC5qcz9jYzc1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3ZnUGF0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEFDVElPTiA9IHtcbiAgTU9WRTogMCxcbiAgTU9WRV9EOiAxLFxuICBMSU5FOiAyLFxuICBMSU5FX0Q6IDMsXG4gIEhPUklaT05UQUw6IDQsXG4gIEhPUklaT05UQUxfRDogNSxcbiAgVkVSVElDQUw6IDYsXG4gIFZFUlRJQ0FMX0Q6IDcsXG4gIEJFWklFUjogOCxcbiAgQkVaSUVSX0Q6IDksXG4gIEFSQzogMTBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN2Z1BhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXRoID0gJyc7XG4gICAgdGhpcy5feDtcbiAgICB0aGlzLl95O1xuICAgIHRoaXMuX3ByZWNpc2lvbiA9IDI7XG4gICAgdGhpcy5fbGFzdEFjdGlvbjtcbiAgfVxuXG4gIC8vIGlnbm9yZSBhIGNoYW5nZSwgaWYgaXRzIGVuZCBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIGl0cyBjdXJyZW50IHBvc2l0aW9uXG4gIF9wYXRoV2lsbENoYW5nZSh4LCB5KSB7XG4gICAgaWYgKE51bWJlci5pc05hTih4KSB8fCBOdW1iZXIuaXNOYU4oeSkpOyAvL2RlYnVnZ2VyO1xuICAgIGlmICh4ICE9PSB0aGlzLl94IHx8IHkgIT09IHRoaXMuX3kpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX2FwcGx5UHJlY2lzaW9uKC4uLm51bWJlcnMpIHtcbiAgICByZXR1cm4gbnVtYmVycy5tYXAoZCA9PiArZC50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbikpO1xuICB9XG5cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICB9XG5cbiAgbW92ZSh4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeCwgeSk7XG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHgsIHkpKSB7XG4gICAgICBpZiAodGhpcy5fbGFzdEFjdGlvbiA9PSBBQ1RJT04uTU9WRSlcbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgbW92ZSBmcm9tIHN0cmluZ1xuICAgICAgICB0aGlzLl9wYXRoID0gdGhpcy5fcGF0aC5zbGljZSgwLCB0aGlzLl9wYXRoLmxhc3RJbmRleE9mKCdNJykpO1xuICAgICAgdGhpcy5fcGF0aCArPSAnTSAnICsgeCArICcgJyArIHkgKyAnICc7XG4gICAgICB0aGlzLl9sYXN0QWN0aW9uID0gQUNUSU9OLk1PVkU7XG4gICAgfVxuICB9XG5cbiAgbW92ZUQoZHgsIGR5KSB7XG4gICAgW2R4LCBkeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihkeCwgZHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94ICsgZHgsIHRoaXMuX3kgKyBkeSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz0gJ20gJyArIGR4ICsgJyAnICsgZHkgKyAnICc7XG4gICAgICB0aGlzLl9sYXN0QWN0aW9uID0gQUNUSU9OLk1PVkVfRDtcbiAgICB9XG4gIH1cblxuICBsaW5lKHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbih4LCB5KTtcbiAgICBpZiAodGhpcy5fcGF0aFdpbGxDaGFuZ2UoeCwgeSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz0gJ0wgJyArIHggKyAnICcgKyB5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5MSU5FO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVEKGR4LCBkeSkge1xuICAgIFtkeCwgZHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oZHgsIGR5KTtcbiAgICBpZiAodGhpcy5fcGF0aFdpbGxDaGFuZ2UodGhpcy5feCArIGR4LCB0aGlzLl95ICsgZHkpKSB7XG4gICAgICB0aGlzLl9wYXRoICs9ICdsICcgKyBkeCArICcgJyArIGR5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5MSU5FX0Q7XG4gICAgfVxuICB9XG5cbiAgaG9yaXpvbnRhbCh4KSB7XG4gICAgW3hdID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeCk7XG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHgsIHRoaXMuX3kpKSB7XG4gICAgICBpZiAodGhpcy5fbGFzdEFjdGlvbiA9PSBBQ1RJT04uSE9SSVpPTlRBTClcbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgbW92ZSBmcm9tIHN0cmluZ1xuICAgICAgICB0aGlzLl9wYXRoID0gdGhpcy5fcGF0aC5zbGljZSgwLCB0aGlzLl9wYXRoLmxhc3RJbmRleE9mKCdIJykpO1xuICAgICAgdGhpcy5fcGF0aCArPSAnSCAnICsgeCArICcgJztcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uSE9SSVpPTlRBTDtcbiAgICB9XG4gIH1cblxuICBob3Jpem9udGFsRChkeCkge1xuICAgIFtkeF0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihkeCk7XG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHRoaXMuX3ggKyBkeCwgdGhpcy5feSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz0gJ2ggJyArIGR4ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5IT1JJWk9OVEFMX0Q7XG4gICAgfVxuICB9XG5cbiAgdmVydGljYWwoeSkge1xuICAgIFt5XSA9IHRoaXMuX2FwcGx5UHJlY2lzaW9uKHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94LCB5KSkge1xuICAgICAgaWYgKHRoaXMuX2xhc3RBY3Rpb24gPT0gQUNUSU9OLlZFUlRJQ0FMKVxuICAgICAgICAvLyByZW1vdmUgbGFzdCBtb3ZlIGZyb20gc3RyaW5nXG4gICAgICAgIHRoaXMuX3BhdGggPSB0aGlzLl9wYXRoLnNsaWNlKDAsIHRoaXMuX3BhdGgubGFzdEluZGV4T2YoJ1YnKSk7XG4gICAgICB0aGlzLl9wYXRoICs9ICdWICcgKyB5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5WRVJUSUNBTDtcbiAgICB9XG4gIH1cblxuICB2ZXJ0aWNhbEQoZHkpIHtcbiAgICBbZHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oZHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94LCB0aGlzLl95ICsgZHkpKSB7XG4gICAgICB0aGlzLl9wYXRoICs9ICd2ICcgKyBkeSArICcgJztcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uVkVSVElDQUxfRDtcbiAgICB9XG4gIH1cblxuICBiZXppZXIoeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICBbeDEsIHkxLCB4MiwgeTIsIHgsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh4LCB5KSkge1xuICAgICAgdGhpcy5fcGF0aCArPVxuICAgICAgICAnQyAnICsgeDEgKyAnICcgKyB5MSArICcsICcgKyB4MiArICcgJyArIHkyICsgJywgJyArIHggKyAnICcgKyB5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5CRVpJRVI7XG4gICAgfVxuICB9XG5cbiAgYmV6aWVyRChkeDEsIGR5MSwgZHgyLCBkeTIsIGR4LCBkeSkge1xuICAgIFtkeDEsIGR5MSwgZHgyLCBkeTIsIGR4LCBkeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihcbiAgICAgIGR4MSxcbiAgICAgIGR5MSxcbiAgICAgIGR4MixcbiAgICAgIGR5MixcbiAgICAgIGR4LFxuICAgICAgZHlcbiAgICApO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94ICsgZHgsIHRoaXMuX3kgKyBkeSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz1cbiAgICAgICAgJ2MgJyArXG4gICAgICAgIGR4MSArXG4gICAgICAgICcgJyArXG4gICAgICAgIGR5MSArXG4gICAgICAgICcsICcgK1xuICAgICAgICBkeDIgK1xuICAgICAgICAnICcgK1xuICAgICAgICBkeTIgK1xuICAgICAgICAnLCAnICtcbiAgICAgICAgZHggK1xuICAgICAgICAnICcgK1xuICAgICAgICBkeSArXG4gICAgICAgICcgJztcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uQkVaSUVSX0Q7XG4gICAgfVxuICB9XG5cbiAgYXJjKHJ4LCByeSwgcm90LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICAgIFtyeCwgcnksIHJvdCwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oXG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgcm90LFxuICAgICAgbGFyZ2VBcmNGbGFnLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICApO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh4LCB5KSkge1xuICAgICAgdGhpcy5fcGF0aCArPVxuICAgICAgICAnQSAnICtcbiAgICAgICAgcnggK1xuICAgICAgICAnICcgK1xuICAgICAgICByeSArXG4gICAgICAgICcgJyArXG4gICAgICAgIHJvdCArXG4gICAgICAgICcgJyArXG4gICAgICAgIGxhcmdlQXJjRmxhZyArXG4gICAgICAgICcgJyArXG4gICAgICAgIHN3ZWVwRmxhZyArXG4gICAgICAgICcgJyArXG4gICAgICAgIHggK1xuICAgICAgICAnICcgK1xuICAgICAgICB5ICtcbiAgICAgICAgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5BUkM7XG4gICAgfVxuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5fcGF0aCArPSAnWic7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SvgPath.js\n"
          );

          /***/
        },

      /***/ './src/TransformData.js':
        /*!******************************!*\
  !*** ./src/TransformData.js ***!
  \******************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SplitStreamInputData.js */ \"./src/SplitStreamInputData.js\");\n\r\n\r\nconst TransformData = {\r\n  viscous: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    // add nodes\r\n    for (let id in data.N) {\r\n      let node = data.N[id];\r\n      format.addNode(node.t, id, node.w);\r\n    }\r\n    // add tree structure\r\n    for (let t in data.EN) {\r\n      for (let id in data.EN[t]) {\r\n        let childArray = data.EN[t][id];\r\n        for (let childId of childArray) {\r\n          format.addParent(t, childId, id);\r\n        }\r\n      }\r\n    }\r\n    // add timeline\r\n    for (let stream in data.ET) {\r\n      for (let nodeId in data.ET[stream]) {\r\n        let t = data.N[nodeId].t;\r\n        for (let nextId of data.ET[stream][nodeId]) {\r\n          format.addNext(t, nodeId, nextId);\r\n        }\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  gumtree: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    let idx = 0;\r\n\r\n    // follow the data format's post-order DFS approach\r\n    let traverse = (t, node) => {\r\n      if (!!node.children)\r\n        for (let i = 0; i < node.children.length; i++)\r\n          traverse(t, node.children[i]);\r\n\r\n      node.id = idx++;\r\n      format.addNode(t, node.id, node.length, node.pos, {\r\n        label: node.label,\r\n        type: node.type,\r\n        typeLabel: node.typeLabel\r\n      });\r\n\r\n      // children need to be added in a second step, becaues ID is not known beforehand\r\n      if (!!node.children)\r\n        for (let i = 0; i < node.children.length; i++)\r\n          format.addParent(t, node.children[i].id, node.id);\r\n    };\r\n\r\n    for (let t in data.timesteps) {\r\n      idx = 0;\r\n      // add nodes and tree structure\r\n      traverse(t, data.timesteps[t].root);\r\n\r\n      // add timeline (start with second, because data needs to be written before being modified)\r\n      if (t > 0) {\r\n        if (!!data.changes[t - 1].matches)\r\n          for (let match of data.changes[t - 1].matches) {\r\n            format.addNext(t - 1, match.src, match.dest);\r\n          }\r\n\r\n        // find added, deleted nodes\r\n        // if (!!data.changes[t-1].actions)\r\n        // \tfor (let action of data.changes[t-1].actions) {\r\n        // \t\tif (action.action == \"delete\")\r\n        // \t\t\tcurrentTimestep.deleted[action.tree] = previousTimestep.references[action.tree];\r\n\r\n        // \t\t/*if (action.action == \"insert\") {\r\n        // \t\t\tcurrentTimestep.references[action.tree].insertAt = action.at;\r\n        // \t\t}*/\r\n        //     }\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  titan: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    let t = -1;\r\n    let lastDate;\r\n    for (let entry of data) {\r\n      // when timestamp changes, create a new timestep\r\n      if (entry['observation_time'] != lastDate) {\r\n        lastDate = entry['observation_time'];\r\n        t++;\r\n      }\r\n      format.addNode(t, entry.id, +entry['cell_volume (km3)']);\r\n    }\r\n\r\n    t = -1;\r\n    for (let entry of data) {\r\n      if (entry['observation_time'] != lastDate) {\r\n        lastDate = entry['observation_time'];\r\n        t++;\r\n      }\r\n      let children = entry['IDs of children '];\r\n      if (!!children) {\r\n        if (typeof children == 'string') {\r\n          let next = children.split(', ');\r\n          if (next[0] != '')\r\n            next.forEach(nextId => format.addNext(t, entry.id, nextId));\r\n        } // single ID as number\r\n        else format.addNext(t, entry.id, children);\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  allen: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](/*{forceFakeRoot: true}*/);\r\n    let timesteps = {\r\n      '2': 0,\r\n      '3': 1,\r\n      '5': 2,\r\n      '6': 3,\r\n      '7': 4,\r\n      '8': 5\r\n    };\r\n    let time = t => timesteps[t];\r\n\r\n    for (let structureId in data) {\r\n      let structure = data[structureId];\r\n      for (let step in structure.timesteps) {\r\n        let { id, timesteps, name, acronym, color, parent } = structure;\r\n        format.addNode(time(step), id, timesteps[step], undefined, {\r\n          name,\r\n          acronym,\r\n          color\r\n        });\r\n      }\r\n    }\r\n\r\n    for (let structureId in data) {\r\n      let structure = data[structureId];\r\n      for (let step in structure.timesteps) {\r\n        let { id, timesteps, name, acronym, color, parent } = structure;\r\n        format.addParent(time(step), id, parent);\r\n      }\r\n    }\r\n\r\n    format.connectEqualIds();\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  storyline: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const characters = [];\r\n    const locations = [];\r\n    for (let char of data.characters)\r\n      characters[char.id] = char.name.replace(/\\s+/g, '');\r\n    for (let loc of data.locations)\r\n      locations[loc.id] = loc.name.replace(/\\s+/g, '');\r\n\r\n    for (let session of data.sessions) {\r\n      for (let t = session.start; t < session.end; t++) {\r\n        format.addNode(\r\n          t,\r\n          locations[session.location],\r\n          undefined,\r\n          undefined,\r\n          locations[session.location]\r\n        );\r\n        for (let member of session.members) {\r\n          format.addNode(\r\n            t,\r\n            characters[member],\r\n            undefined,\r\n            undefined,\r\n            characters[member]\r\n          );\r\n          format.addParent(t, characters[member], locations[session.location]);\r\n        }\r\n      }\r\n    }\r\n\r\n    format.connectEqualIds();\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  treemap: function(data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    for (let entry of data) {\r\n      let id = entry[0];\r\n      let parentId = entry[1];\r\n      for (let t = 2; t < entry.length; t++) {\r\n        if (entry[t] > 0) {\r\n          format.addNode(t, id, entry[t]);\r\n          format.addNode(t, parentId);\r\n          format.addParent(t, id, parentId);\r\n        }\r\n      }\r\n    }\r\n    format.connectEqualIds();\r\n    format.finalize();\r\n    return format;\r\n  }\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TransformData);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvVHJhbnNmb3JtRGF0YS5qcz9lNDk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBNkQ7O0FBRTdEO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixnRUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixnRUFBb0IsSUFBSSxvQkFBb0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFCQUFxQixnRUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsNEVBQWEsRUFBQyIsImZpbGUiOiIuL3NyYy9UcmFuc2Zvcm1EYXRhLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNwbGl0U3RyZWFtSW5wdXREYXRhIGZyb20gJy4vU3BsaXRTdHJlYW1JbnB1dERhdGEuanMnO1xyXG5cclxuY29uc3QgVHJhbnNmb3JtRGF0YSA9IHtcclxuICB2aXNjb3VzOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICAvLyBhZGQgbm9kZXNcclxuICAgIGZvciAobGV0IGlkIGluIGRhdGEuTikge1xyXG4gICAgICBsZXQgbm9kZSA9IGRhdGEuTltpZF07XHJcbiAgICAgIGZvcm1hdC5hZGROb2RlKG5vZGUudCwgaWQsIG5vZGUudyk7XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgdHJlZSBzdHJ1Y3R1cmVcclxuICAgIGZvciAobGV0IHQgaW4gZGF0YS5FTikge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiBkYXRhLkVOW3RdKSB7XHJcbiAgICAgICAgbGV0IGNoaWxkQXJyYXkgPSBkYXRhLkVOW3RdW2lkXTtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZElkIG9mIGNoaWxkQXJyYXkpIHtcclxuICAgICAgICAgIGZvcm1hdC5hZGRQYXJlbnQodCwgY2hpbGRJZCwgaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIHRpbWVsaW5lXHJcbiAgICBmb3IgKGxldCBzdHJlYW0gaW4gZGF0YS5FVCkge1xyXG4gICAgICBmb3IgKGxldCBub2RlSWQgaW4gZGF0YS5FVFtzdHJlYW1dKSB7XHJcbiAgICAgICAgbGV0IHQgPSBkYXRhLk5bbm9kZUlkXS50O1xyXG4gICAgICAgIGZvciAobGV0IG5leHRJZCBvZiBkYXRhLkVUW3N0cmVhbV1bbm9kZUlkXSkge1xyXG4gICAgICAgICAgZm9ybWF0LmFkZE5leHQodCwgbm9kZUlkLCBuZXh0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9LFxyXG5cclxuICBndW10cmVlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICBsZXQgaWR4ID0gMDtcclxuXHJcbiAgICAvLyBmb2xsb3cgdGhlIGRhdGEgZm9ybWF0J3MgcG9zdC1vcmRlciBERlMgYXBwcm9hY2hcclxuICAgIGxldCB0cmF2ZXJzZSA9ICh0LCBub2RlKSA9PiB7XHJcbiAgICAgIGlmICghIW5vZGUuY2hpbGRyZW4pXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgdHJhdmVyc2UodCwgbm9kZS5jaGlsZHJlbltpXSk7XHJcblxyXG4gICAgICBub2RlLmlkID0gaWR4Kys7XHJcbiAgICAgIGZvcm1hdC5hZGROb2RlKHQsIG5vZGUuaWQsIG5vZGUubGVuZ3RoLCBub2RlLnBvcywge1xyXG4gICAgICAgIGxhYmVsOiBub2RlLmxhYmVsLFxyXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcclxuICAgICAgICB0eXBlTGFiZWw6IG5vZGUudHlwZUxhYmVsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gY2hpbGRyZW4gbmVlZCB0byBiZSBhZGRlZCBpbiBhIHNlY29uZCBzdGVwLCBiZWNhdWVzIElEIGlzIG5vdCBrbm93biBiZWZvcmVoYW5kXHJcbiAgICAgIGlmICghIW5vZGUuY2hpbGRyZW4pXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgZm9ybWF0LmFkZFBhcmVudCh0LCBub2RlLmNoaWxkcmVuW2ldLmlkLCBub2RlLmlkKTtcclxuICAgIH07XHJcblxyXG4gICAgZm9yIChsZXQgdCBpbiBkYXRhLnRpbWVzdGVwcykge1xyXG4gICAgICBpZHggPSAwO1xyXG4gICAgICAvLyBhZGQgbm9kZXMgYW5kIHRyZWUgc3RydWN0dXJlXHJcbiAgICAgIHRyYXZlcnNlKHQsIGRhdGEudGltZXN0ZXBzW3RdLnJvb3QpO1xyXG5cclxuICAgICAgLy8gYWRkIHRpbWVsaW5lIChzdGFydCB3aXRoIHNlY29uZCwgYmVjYXVzZSBkYXRhIG5lZWRzIHRvIGJlIHdyaXR0ZW4gYmVmb3JlIGJlaW5nIG1vZGlmaWVkKVxyXG4gICAgICBpZiAodCA+IDApIHtcclxuICAgICAgICBpZiAoISFkYXRhLmNoYW5nZXNbdCAtIDFdLm1hdGNoZXMpXHJcbiAgICAgICAgICBmb3IgKGxldCBtYXRjaCBvZiBkYXRhLmNoYW5nZXNbdCAtIDFdLm1hdGNoZXMpIHtcclxuICAgICAgICAgICAgZm9ybWF0LmFkZE5leHQodCAtIDEsIG1hdGNoLnNyYywgbWF0Y2guZGVzdCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmQgYWRkZWQsIGRlbGV0ZWQgbm9kZXNcclxuICAgICAgICAvLyBpZiAoISFkYXRhLmNoYW5nZXNbdC0xXS5hY3Rpb25zKVxyXG4gICAgICAgIC8vIFx0Zm9yIChsZXQgYWN0aW9uIG9mIGRhdGEuY2hhbmdlc1t0LTFdLmFjdGlvbnMpIHtcclxuICAgICAgICAvLyBcdFx0aWYgKGFjdGlvbi5hY3Rpb24gPT0gXCJkZWxldGVcIilcclxuICAgICAgICAvLyBcdFx0XHRjdXJyZW50VGltZXN0ZXAuZGVsZXRlZFthY3Rpb24udHJlZV0gPSBwcmV2aW91c1RpbWVzdGVwLnJlZmVyZW5jZXNbYWN0aW9uLnRyZWVdO1xyXG5cclxuICAgICAgICAvLyBcdFx0LyppZiAoYWN0aW9uLmFjdGlvbiA9PSBcImluc2VydFwiKSB7XHJcbiAgICAgICAgLy8gXHRcdFx0Y3VycmVudFRpbWVzdGVwLnJlZmVyZW5jZXNbYWN0aW9uLnRyZWVdLmluc2VydEF0ID0gYWN0aW9uLmF0O1xyXG4gICAgICAgIC8vIFx0XHR9Ki9cclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0LmZpbmFsaXplKCk7XHJcbiAgICByZXR1cm4gZm9ybWF0O1xyXG4gIH0sXHJcblxyXG4gIHRpdGFuOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICBsZXQgZm9ybWF0ID0gbmV3IFNwbGl0U3RyZWFtSW5wdXREYXRhKCk7XHJcbiAgICBsZXQgdCA9IC0xO1xyXG4gICAgbGV0IGxhc3REYXRlO1xyXG4gICAgZm9yIChsZXQgZW50cnkgb2YgZGF0YSkge1xyXG4gICAgICAvLyB3aGVuIHRpbWVzdGFtcCBjaGFuZ2VzLCBjcmVhdGUgYSBuZXcgdGltZXN0ZXBcclxuICAgICAgaWYgKGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ10gIT0gbGFzdERhdGUpIHtcclxuICAgICAgICBsYXN0RGF0ZSA9IGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ107XHJcbiAgICAgICAgdCsrO1xyXG4gICAgICB9XHJcbiAgICAgIGZvcm1hdC5hZGROb2RlKHQsIGVudHJ5LmlkLCArZW50cnlbJ2NlbGxfdm9sdW1lIChrbTMpJ10pO1xyXG4gICAgfVxyXG5cclxuICAgIHQgPSAtMTtcclxuICAgIGZvciAobGV0IGVudHJ5IG9mIGRhdGEpIHtcclxuICAgICAgaWYgKGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ10gIT0gbGFzdERhdGUpIHtcclxuICAgICAgICBsYXN0RGF0ZSA9IGVudHJ5WydvYnNlcnZhdGlvbl90aW1lJ107XHJcbiAgICAgICAgdCsrO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBjaGlsZHJlbiA9IGVudHJ5WydJRHMgb2YgY2hpbGRyZW4gJ107XHJcbiAgICAgIGlmICghIWNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbi5zcGxpdCgnLCAnKTtcclxuICAgICAgICAgIGlmIChuZXh0WzBdICE9ICcnKVxyXG4gICAgICAgICAgICBuZXh0LmZvckVhY2gobmV4dElkID0+IGZvcm1hdC5hZGROZXh0KHQsIGVudHJ5LmlkLCBuZXh0SWQpKTtcclxuICAgICAgICB9IC8vIHNpbmdsZSBJRCBhcyBudW1iZXJcclxuICAgICAgICBlbHNlIGZvcm1hdC5hZGROZXh0KHQsIGVudHJ5LmlkLCBjaGlsZHJlbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3JtYXQuZmluYWxpemUoKTtcclxuICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgfSxcclxuXHJcbiAgYWxsZW46IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoLyp7Zm9yY2VGYWtlUm9vdDogdHJ1ZX0qLyk7XHJcbiAgICBsZXQgdGltZXN0ZXBzID0ge1xyXG4gICAgICAnMic6IDAsXHJcbiAgICAgICczJzogMSxcclxuICAgICAgJzUnOiAyLFxyXG4gICAgICAnNic6IDMsXHJcbiAgICAgICc3JzogNCxcclxuICAgICAgJzgnOiA1XHJcbiAgICB9O1xyXG4gICAgbGV0IHRpbWUgPSB0ID0+IHRpbWVzdGVwc1t0XTtcclxuXHJcbiAgICBmb3IgKGxldCBzdHJ1Y3R1cmVJZCBpbiBkYXRhKSB7XHJcbiAgICAgIGxldCBzdHJ1Y3R1cmUgPSBkYXRhW3N0cnVjdHVyZUlkXTtcclxuICAgICAgZm9yIChsZXQgc3RlcCBpbiBzdHJ1Y3R1cmUudGltZXN0ZXBzKSB7XHJcbiAgICAgICAgbGV0IHsgaWQsIHRpbWVzdGVwcywgbmFtZSwgYWNyb255bSwgY29sb3IsIHBhcmVudCB9ID0gc3RydWN0dXJlO1xyXG4gICAgICAgIGZvcm1hdC5hZGROb2RlKHRpbWUoc3RlcCksIGlkLCB0aW1lc3RlcHNbc3RlcF0sIHVuZGVmaW5lZCwge1xyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGFjcm9ueW0sXHJcbiAgICAgICAgICBjb2xvclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgc3RydWN0dXJlSWQgaW4gZGF0YSkge1xyXG4gICAgICBsZXQgc3RydWN0dXJlID0gZGF0YVtzdHJ1Y3R1cmVJZF07XHJcbiAgICAgIGZvciAobGV0IHN0ZXAgaW4gc3RydWN0dXJlLnRpbWVzdGVwcykge1xyXG4gICAgICAgIGxldCB7IGlkLCB0aW1lc3RlcHMsIG5hbWUsIGFjcm9ueW0sIGNvbG9yLCBwYXJlbnQgfSA9IHN0cnVjdHVyZTtcclxuICAgICAgICBmb3JtYXQuYWRkUGFyZW50KHRpbWUoc3RlcCksIGlkLCBwYXJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0LmNvbm5lY3RFcXVhbElkcygpO1xyXG4gICAgZm9ybWF0LmZpbmFsaXplKCk7XHJcbiAgICByZXR1cm4gZm9ybWF0O1xyXG4gIH0sXHJcblxyXG4gIHN0b3J5bGluZTogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgbGV0IGZvcm1hdCA9IG5ldyBTcGxpdFN0cmVhbUlucHV0RGF0YSgpO1xyXG4gICAgY29uc3QgY2hhcmFjdGVycyA9IFtdO1xyXG4gICAgY29uc3QgbG9jYXRpb25zID0gW107XHJcbiAgICBmb3IgKGxldCBjaGFyIG9mIGRhdGEuY2hhcmFjdGVycylcclxuICAgICAgY2hhcmFjdGVyc1tjaGFyLmlkXSA9IGNoYXIubmFtZS5yZXBsYWNlKC9cXHMrL2csICcnKTtcclxuICAgIGZvciAobGV0IGxvYyBvZiBkYXRhLmxvY2F0aW9ucylcclxuICAgICAgbG9jYXRpb25zW2xvYy5pZF0gPSBsb2MubmFtZS5yZXBsYWNlKC9cXHMrL2csICcnKTtcclxuXHJcbiAgICBmb3IgKGxldCBzZXNzaW9uIG9mIGRhdGEuc2Vzc2lvbnMpIHtcclxuICAgICAgZm9yIChsZXQgdCA9IHNlc3Npb24uc3RhcnQ7IHQgPCBzZXNzaW9uLmVuZDsgdCsrKSB7XHJcbiAgICAgICAgZm9ybWF0LmFkZE5vZGUoXHJcbiAgICAgICAgICB0LFxyXG4gICAgICAgICAgbG9jYXRpb25zW3Nlc3Npb24ubG9jYXRpb25dLFxyXG4gICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgbG9jYXRpb25zW3Nlc3Npb24ubG9jYXRpb25dXHJcbiAgICAgICAgKTtcclxuICAgICAgICBmb3IgKGxldCBtZW1iZXIgb2Ygc2Vzc2lvbi5tZW1iZXJzKSB7XHJcbiAgICAgICAgICBmb3JtYXQuYWRkTm9kZShcclxuICAgICAgICAgICAgdCxcclxuICAgICAgICAgICAgY2hhcmFjdGVyc1ttZW1iZXJdLFxyXG4gICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY2hhcmFjdGVyc1ttZW1iZXJdXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgZm9ybWF0LmFkZFBhcmVudCh0LCBjaGFyYWN0ZXJzW21lbWJlcl0sIGxvY2F0aW9uc1tzZXNzaW9uLmxvY2F0aW9uXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0LmNvbm5lY3RFcXVhbElkcygpO1xyXG4gICAgZm9ybWF0LmZpbmFsaXplKCk7XHJcbiAgICByZXR1cm4gZm9ybWF0O1xyXG4gIH0sXHJcblxyXG4gIHRyZWVtYXA6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoKTtcclxuICAgIGZvciAobGV0IGVudHJ5IG9mIGRhdGEpIHtcclxuICAgICAgbGV0IGlkID0gZW50cnlbMF07XHJcbiAgICAgIGxldCBwYXJlbnRJZCA9IGVudHJ5WzFdO1xyXG4gICAgICBmb3IgKGxldCB0ID0gMjsgdCA8IGVudHJ5Lmxlbmd0aDsgdCsrKSB7XHJcbiAgICAgICAgaWYgKGVudHJ5W3RdID4gMCkge1xyXG4gICAgICAgICAgZm9ybWF0LmFkZE5vZGUodCwgaWQsIGVudHJ5W3RdKTtcclxuICAgICAgICAgIGZvcm1hdC5hZGROb2RlKHQsIHBhcmVudElkKTtcclxuICAgICAgICAgIGZvcm1hdC5hZGRQYXJlbnQodCwgaWQsIHBhcmVudElkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvcm1hdC5jb25uZWN0RXF1YWxJZHMoKTtcclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm1EYXRhO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/TransformData.js\n"
          );

          /***/
        },

      /***/ './src/functions.js':
        /*!**************************!*\
  !*** ./src/functions.js ***!
  \**************************/
        /*! exports provided: loadJSON, getRandomColor, saveSvg, savePng, saveJson, addLoadingSpinner, removeLoadingSpinner */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJSON\", function() { return loadJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRandomColor\", function() { return getRandomColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveSvg\", function() { return saveSvg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"savePng\", function() { return savePng; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveJson\", function() { return saveJson; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLoadingSpinner\", function() { return addLoadingSpinner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeLoadingSpinner\", function() { return removeLoadingSpinner; });\n/* harmony import */ var save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! save-svg-as-png */ \"./node_modules/save-svg-as-png/lib/saveSvgAsPng.js\");\n/* harmony import */ var save_svg_as_png__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction loadJSON(file, callback) {\n  var xobj = new XMLHttpRequest();\n  xobj.overrideMimeType('application/json');\n  xobj.open('GET', file, true); // Replace 'my_data' with the path to your file\n  xobj.onreadystatechange = function() {\n    if (xobj.readyState == 4 && xobj.status == '200') {\n      // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode\n      callback(xobj.responseText);\n    }\n  };\n  xobj.send(null);\n}\n\nfunction getRandomColor() {\n  var letters = '0123456789ABCDEF';\n  var color = '#';\n  for (var i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n}\n\n/* Modified from https://stackoverflow.com/questions/23218174/how-do-i-save-export-an-svg-file-after-creating-an-svg-with-d3-js-ie-safari-an */\nfunction saveSvg(svgEl, name) {\n  svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  var svgData = svgEl.outerHTML;\n  var preface = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n';\n  var svgBlob = new Blob([preface, svgData], {\n    type: 'image/svg+xml;charset=utf-8'\n  });\n  var svgUrl = URL.createObjectURL(svgBlob);\n  var downloadLink = document.createElement('a');\n  downloadLink.href = svgUrl;\n  downloadLink.download = name + '.svg';\n  document.body.appendChild(downloadLink);\n  downloadLink.click();\n  document.body.removeChild(downloadLink);\n}\n\nasync function savePng(svgEl, name) {\n  // store image in 16K+ res\n  // this can take a lot of time\n  addLoadingSpinner(document.querySelector('#wrapper'));\n  let scaleFactor = Math.ceil(15360 / svgEl.clientWidth);\n  await save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__[\"saveSvgAsPng\"](svgEl, name + '.png', {\n    backgroundColor: 'white',\n    encoderOptions: 1,\n    scale: scaleFactor\n  });\n  removeLoadingSpinner(document.querySelector('#wrapper'));\n}\n\n/* Modified from https://stackoverflow.com/questions/19721439/download-json-object-as-a-file-from-browser */\nfunction saveJson(exportObj, exportName) {\n  var dataStr =\n    'data:text/json;charset=utf-8,' +\n    encodeURIComponent(JSON.stringify(exportObj));\n  var downloadAnchorNode = document.createElement('a');\n  downloadAnchorNode.setAttribute('href', dataStr);\n  downloadAnchorNode.setAttribute('download', exportName + '.json');\n  document.body.appendChild(downloadAnchorNode); // required for firefox\n  downloadAnchorNode.click();\n  downloadAnchorNode.remove();\n}\n\nfunction addLoadingSpinner(div) {\n  if (!div) {\n    console.log('addLoadingSpinner: div does not exist');\n    return;\n  }\n\n  if (!div.classList.contains('loading')) {\n    div.classList.add('loading');\n\n    let loader = document.createElement('div');\n    loader.classList = 'loader';\n    loader.style.top = div.scrollTop + 'px'; // position it correctly on scrollable divs\n    loader.onscroll = function(e) {\n      e.preventDefault();\n    };\n    div.appendChild(loader);\n\n    let spinner = document.createElement('div');\n    spinner.classList = 'spinner';\n    let size =\n      0.3 *\n      (loader.clientHeight > loader.clientWidth\n        ? loader.clientWidth\n        : loader.clientHeight);\n    spinner.style.width = size + 'px';\n    spinner.style.height = size + 'px';\n    spinner.style.borderWidth = 0.1 * size + 'px';\n    loader.appendChild(spinner);\n  }\n}\n\nfunction removeLoadingSpinner(div) {\n  if (!div) return;\n\n  let loader = div.querySelector('.loader');\n  if (!!loader) {\n    div.removeChild(loader);\n    div.classList.remove('loading');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvZnVuY3Rpb25zLmpzPzlmMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7O0FBRWhDO0FBQ1A7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9mdW5jdGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzdmcgZnJvbSAnc2F2ZS1zdmctYXMtcG5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRKU09OKGZpbGUsIGNhbGxiYWNrKSB7XG4gIHZhciB4b2JqID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHhvYmoub3ZlcnJpZGVNaW1lVHlwZSgnYXBwbGljYXRpb24vanNvbicpO1xuICB4b2JqLm9wZW4oJ0dFVCcsIGZpbGUsIHRydWUpOyAvLyBSZXBsYWNlICdteV9kYXRhJyB3aXRoIHRoZSBwYXRoIHRvIHlvdXIgZmlsZVxuICB4b2JqLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh4b2JqLnJlYWR5U3RhdGUgPT0gNCAmJiB4b2JqLnN0YXR1cyA9PSAnMjAwJykge1xuICAgICAgLy8gUmVxdWlyZWQgdXNlIG9mIGFuIGFub255bW91cyBjYWxsYmFjayBhcyAub3BlbiB3aWxsIE5PVCByZXR1cm4gYSB2YWx1ZSBidXQgc2ltcGx5IHJldHVybnMgdW5kZWZpbmVkIGluIGFzeW5jaHJvbm91cyBtb2RlXG4gICAgICBjYWxsYmFjayh4b2JqLnJlc3BvbnNlVGV4dCk7XG4gICAgfVxuICB9O1xuICB4b2JqLnNlbmQobnVsbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21Db2xvcigpIHtcbiAgdmFyIGxldHRlcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRic7XG4gIHZhciBjb2xvciA9ICcjJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICBjb2xvciArPSBsZXR0ZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KV07XG4gIH1cbiAgcmV0dXJuIGNvbG9yO1xufVxuXG4vKiBNb2RpZmllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIzMjE4MTc0L2hvdy1kby1pLXNhdmUtZXhwb3J0LWFuLXN2Zy1maWxlLWFmdGVyLWNyZWF0aW5nLWFuLXN2Zy13aXRoLWQzLWpzLWllLXNhZmFyaS1hbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTdmcoc3ZnRWwsIG5hbWUpIHtcbiAgc3ZnRWwuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuICB2YXIgc3ZnRGF0YSA9IHN2Z0VsLm91dGVySFRNTDtcbiAgdmFyIHByZWZhY2UgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIHN0YW5kYWxvbmU9XCJub1wiPz5cXHJcXG4nO1xuICB2YXIgc3ZnQmxvYiA9IG5ldyBCbG9iKFtwcmVmYWNlLCBzdmdEYXRhXSwge1xuICAgIHR5cGU6ICdpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgnXG4gIH0pO1xuICB2YXIgc3ZnVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdmdCbG9iKTtcbiAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgZG93bmxvYWRMaW5rLmhyZWYgPSBzdmdVcmw7XG4gIGRvd25sb2FkTGluay5kb3dubG9hZCA9IG5hbWUgKyAnLnN2Zyc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgZG93bmxvYWRMaW5rLmNsaWNrKCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRMaW5rKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVQbmcoc3ZnRWwsIG5hbWUpIHtcbiAgLy8gc3RvcmUgaW1hZ2UgaW4gMTZLKyByZXNcbiAgLy8gdGhpcyBjYW4gdGFrZSBhIGxvdCBvZiB0aW1lXG4gIGFkZExvYWRpbmdTcGlubmVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN3cmFwcGVyJykpO1xuICBsZXQgc2NhbGVGYWN0b3IgPSBNYXRoLmNlaWwoMTUzNjAgLyBzdmdFbC5jbGllbnRXaWR0aCk7XG4gIGF3YWl0IHN2Zy5zYXZlU3ZnQXNQbmcoc3ZnRWwsIG5hbWUgKyAnLnBuZycsIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgZW5jb2Rlck9wdGlvbnM6IDEsXG4gICAgc2NhbGU6IHNjYWxlRmFjdG9yXG4gIH0pO1xuICByZW1vdmVMb2FkaW5nU3Bpbm5lcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd3JhcHBlcicpKTtcbn1cblxuLyogTW9kaWZpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMTQzOS9kb3dubG9hZC1qc29uLW9iamVjdC1hcy1hLWZpbGUtZnJvbS1icm93c2VyICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUpzb24oZXhwb3J0T2JqLCBleHBvcnROYW1lKSB7XG4gIHZhciBkYXRhU3RyID1cbiAgICAnZGF0YTp0ZXh0L2pzb247Y2hhcnNldD11dGYtOCwnICtcbiAgICBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZXhwb3J0T2JqKSk7XG4gIHZhciBkb3dubG9hZEFuY2hvck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGRvd25sb2FkQW5jaG9yTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBkYXRhU3RyKTtcbiAgZG93bmxvYWRBbmNob3JOb2RlLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBleHBvcnROYW1lICsgJy5qc29uJyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRBbmNob3JOb2RlKTsgLy8gcmVxdWlyZWQgZm9yIGZpcmVmb3hcbiAgZG93bmxvYWRBbmNob3JOb2RlLmNsaWNrKCk7XG4gIGRvd25sb2FkQW5jaG9yTm9kZS5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExvYWRpbmdTcGlubmVyKGRpdikge1xuICBpZiAoIWRpdikge1xuICAgIGNvbnNvbGUubG9nKCdhZGRMb2FkaW5nU3Bpbm5lcjogZGl2IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFkaXYuY2xhc3NMaXN0LmNvbnRhaW5zKCdsb2FkaW5nJykpIHtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZCgnbG9hZGluZycpO1xuXG4gICAgbGV0IGxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxvYWRlci5jbGFzc0xpc3QgPSAnbG9hZGVyJztcbiAgICBsb2FkZXIuc3R5bGUudG9wID0gZGl2LnNjcm9sbFRvcCArICdweCc7IC8vIHBvc2l0aW9uIGl0IGNvcnJlY3RseSBvbiBzY3JvbGxhYmxlIGRpdnNcbiAgICBsb2FkZXIub25zY3JvbGwgPSBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQobG9hZGVyKTtcblxuICAgIGxldCBzcGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3Bpbm5lci5jbGFzc0xpc3QgPSAnc3Bpbm5lcic7XG4gICAgbGV0IHNpemUgPVxuICAgICAgMC4zICpcbiAgICAgIChsb2FkZXIuY2xpZW50SGVpZ2h0ID4gbG9hZGVyLmNsaWVudFdpZHRoXG4gICAgICAgID8gbG9hZGVyLmNsaWVudFdpZHRoXG4gICAgICAgIDogbG9hZGVyLmNsaWVudEhlaWdodCk7XG4gICAgc3Bpbm5lci5zdHlsZS53aWR0aCA9IHNpemUgKyAncHgnO1xuICAgIHNwaW5uZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZSArICdweCc7XG4gICAgc3Bpbm5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IDAuMSAqIHNpemUgKyAncHgnO1xuICAgIGxvYWRlci5hcHBlbmRDaGlsZChzcGlubmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTG9hZGluZ1NwaW5uZXIoZGl2KSB7XG4gIGlmICghZGl2KSByZXR1cm47XG5cbiAgbGV0IGxvYWRlciA9IGRpdi5xdWVyeVNlbGVjdG9yKCcubG9hZGVyJyk7XG4gIGlmICghIWxvYWRlcikge1xuICAgIGRpdi5yZW1vdmVDaGlsZChsb2FkZXIpO1xuICAgIGRpdi5jbGFzc0xpc3QucmVtb3ZlKCdsb2FkaW5nJyk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/functions.js\n"
          );

          /***/
        },

      /***/ './src/lib.js':
        /*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
        /*! exports provided: SplitStream, SplitStreamInputData, SplitStreamFilter, TransformData */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SplitStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SplitStream */ "./src/SplitStream.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStream", function() { return _SplitStream__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _SplitStreamInputData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SplitStreamInputData */ "./src/SplitStreamInputData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStreamInputData", function() { return _SplitStreamInputData__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _SplitStreamFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SplitStreamFilter */ "./src/SplitStreamFilter.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStreamFilter", function() { return _SplitStreamFilter__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _TransformData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TransformData */ "./src/TransformData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformData", function() { return _TransformData__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvbGliLmpzPzM0ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBd0M7QUFDa0I7QUFDTjtBQUNSOztBQUVtQyIsImZpbGUiOiIuL3NyYy9saWIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3BsaXRTdHJlYW0gZnJvbSAnLi9TcGxpdFN0cmVhbSc7XHJcbmltcG9ydCBTcGxpdFN0cmVhbUlucHV0RGF0YSBmcm9tICcuL1NwbGl0U3RyZWFtSW5wdXREYXRhJztcclxuaW1wb3J0IFNwbGl0U3RyZWFtRmlsdGVyIGZyb20gJy4vU3BsaXRTdHJlYW1GaWx0ZXInO1xyXG5pbXBvcnQgVHJhbnNmb3JtRGF0YSBmcm9tICcuL1RyYW5zZm9ybURhdGEnO1xyXG5cclxuZXhwb3J0IHsgU3BsaXRTdHJlYW0sIFNwbGl0U3RyZWFtSW5wdXREYXRhLCBTcGxpdFN0cmVhbUZpbHRlciwgVHJhbnNmb3JtRGF0YSB9O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib.js\n'
          );

          /***/
        },

      /***/ d3:
        /*!*********************!*\
  !*** external "d3" ***!
  \*********************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            'module.exports = __WEBPACK_EXTERNAL_MODULE_d3__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvZXh0ZXJuYWwgXCJkM1wiPzQzNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiZDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZDNfXzsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///d3\n'
          );

          /***/
        }

      /******/
    }
  );
});
