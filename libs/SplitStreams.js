(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require('d3'));
  else if (typeof define === 'function' && define.amd) define(['d3'], factory);
  else if (typeof exports === 'object')
    exports['SplitStreams'] = factory(require('d3'));
  else root['SplitStreams'] = factory(root['d3']);
})(window, function(__WEBPACK_EXTERNAL_MODULE_d3__) {
  return /******/ (function(modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {}; // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports;
        /******/
      } // Create a new module (and put it into the cache)
      /******/ /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {}
        /******/
      }); // Execute the module function
      /******/
      /******/ /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      ); // Flag the module as loaded
      /******/
      /******/ /******/ module.l = true; // Return the exports of the module
      /******/
      /******/ /******/ return module.exports;
      /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules; // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter
        });
        /******/
      }
      /******/
    }; // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function(exports) {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
      value,
      mode
    ) {
      /******/ if (mode & 1) value = __webpack_require__(value);
      /******/ if (mode & 8) return value;
      /******/ if (
        mode & 4 &&
        typeof value === 'object' &&
        value &&
        value.__esModule
      )
        return value;
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ Object.defineProperty(ns, 'default', {
        enumerable: true,
        value: value
      });
      /******/ if (mode & 2 && typeof value != 'string')
        for (var key in value)
          __webpack_require__.d(
            ns,
            key,
            function(key) {
              return value[key];
            }.bind(null, key)
          );
      /******/ return ns;
      /******/
    }; // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function(module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module['default'];
            }
          : /******/ function getModuleExports() {
              return module;
            };
      /******/ __webpack_require__.d(getter, 'a', getter);
      /******/ return getter;
      /******/
    }; // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }; // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = ''; // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__(
      (__webpack_require__.s = './src/lib.js')
    );
    /******/
  })(
    /************************************************************************/
    /******/ {
      /***/ './css/SplitStream.css':
        /*!*****************************!*\
  !*** ./css/SplitStream.css ***!
  \*****************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./SplitStream.css */ "./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css");\n\nif (typeof content === \'string\') {\n  content = [[module.i, content, \'\']];\n}\n\nvar options = {}\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9jc3MvU3BsaXRTdHJlYW0uY3NzPzA3ZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDhIQUE0RDs7QUFFbEY7QUFDQSxjQUFjLFFBQVM7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsbUpBQXdFOztBQUU3RjtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9jc3MvU3BsaXRTdHJlYW0uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL1NwbGl0U3RyZWFtLmNzc1wiKTtcblxuaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG59XG5cbnZhciBvcHRpb25zID0ge31cblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/SplitStream.css\n'
          );

          /***/
        },

      /***/ './libs/d3svgfilters/src/d3-svg-filters.js':
        /*!*************************************************!*\
  !*** ./libs/d3svgfilters/src/d3-svg-filters.js ***!
  \*************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'const d3 =  true ? __webpack_require__(/*! d3 */ "d3") : undefined;\n\nclass SVGFilter {\n  constructor(spec) {}\n\n  set id(id) {\n    this._id = id;\n  }\n  get id() {\n    return this._id;\n  }\n}\n\nclass SVGFilterManagerLibrary {\n  constructor() {\n    this._library = {}; // name : { generate: (defs) => (args) => {  appends filter to defs }, signature: (args) => key}\n  }\n\n  static GenerateID() {\n    if (!this.__ID) this.__ID = 0;\n\n    return ++this.__ID;\n  }\n\n  addFilter(name, fns) {\n    this._library[name] = fns;\n  }\n\n  signature(filterName, args) {\n    return this._library[filterName]\n      .signature(args)\n      .replace(/\\:|\\,|\\.|\\;/g, \'_\')\n      .replace(/ /g, \'\')\n      .replace(/\\#/g, \'h\')\n      .replace(/\\(/g, \'l\')\n      .replace(/\\)/g, \'r\');\n  }\n\n  generate(defs, filterName, args) {\n    const signature = this.signature(filterName, args);\n    const ctx = { signature, defs };\n    const theFilter = this._library[filterName].generate.call(ctx, {\n      ...args,\n      id: SVGFilterManagerLibrary.GenerateID()\n    });\n\n    defs.node().__filters__.push({ signature, filter: theFilter });\n  }\n\n  static Suffix() {\n    if (!this._suffix) this._suffix = 0;\n    return this._suffix++;\n  }\n\n  makeUnique(filterText) {\n    const varNames = /result=(.+?)/g.test(filterText);\n  }\n}\n\nconst GenSVGFilters = (...filters) => {};\n\nconst Lib = new SVGFilterManagerLibrary();\nLib.addFilter(\'drop-shadow\', {\n  generate: function({ color, dx, dy, blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    const theDropShadow = this.defs.html(\n      this.defs.html() +\n        `\n            <feDropShadow\n                id=\'${key}\'\n                dx=\'${dx}\'\n                dy=\'${dy}\'\n                stdDeviation=\'${blur}\'\n                flood-color=${color} />\n        `\n    );\n\n    return theDropShadow;\n  },\n  signature: ({ color, dx, dy, blur }) => `ds_${color}_${blur}_${dx}_${dy}`\n});\n\nLib.addFilter(\'blur\', {\n  generate: function({ blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    const theBlur = this.defs\n      .append(\'feGaussianBlur\')\n      .attr(\'stdDeviation\', blur);\n\n    return theBlur;\n  },\n  signature: ({ blur }) => `gbl_${blur}`\n});\n\nLib.addFilter(\'inner-shadow\', {\n  generate: function({ id, color, dx, dy, blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    this.defs.html(\n      this.defs.html() +\n        `\n            <feGaussianBlur in=\'SourceAlpha\' stdDeviation=\'${blur}\' result=\'blur${id}\'/>\n            <feOffset dx=${dx} dy=${dy}/>\n            <feComposite in2=\'SourceAlpha\' operator=\'arithmetic\' k2=-1 k3=1 result=\'shadowDiff${id}\'/>\n            <feFlood flood-color=${color}/>\n            <feComposite in2=\'shadowDiff${id}\' operator=\'in\'/> \n            <feComposite in2=\'SourceGraphic\' operator=\'over\' result=\'firstFilter${id}\'/>\n            <feComposite in2=\'shadowDiff${id}\' operator=\'in\'/>\n            <feComposite in2=\'firstFilter${id}\' operator=\'over\'/>\n        `\n    );\n  },\n  signature: ({ color, dx, dy, blur }) => `ids_${color}_${blur}_${dx}_${dy}`\n});\n\nLib.addFilter(\'double-inner-shadow\', {\n  generate: function({ id, color, dx, dy, blur }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    this.defs.html(\n      this.defs.html() +\n        `\n            <feComponentTransfer in=SourceAlpha result="invert${id}">\n                <feFuncA type="table" tableValues="1 0"/>\n            </feComponentTransfer>\n            <feGaussianBlur in="invert${id}" stdDeviation="${blur}" result="blur${id}"/>\n            <feOffset in="blur${id}" dx="${dx}" dy="${dy}" result="offsetblur1${id}"/>\n            <feOffset in="blur${id}" dy="${-dy}" result="offsetblur2${id}"/>\n            <feFlood flood-color="${color}"/> \n            <feComposite in2="offsetblur1${id}" operator="in" result="offsetblur1cut${id}"/>\n            <feFlood flood-color="${color}"/> \n            <feComposite in2="offsetblur2${id}" operator="in" result="offsetblur2cut${id}"/>\n            <feMerge>\n                <feMergeNode in="SourceGraphic" />\n                <feMergeNode in="offsetblur1${id}" />\n                <feMergeNode in="offsetblur2${id}" />\n            </feMerge>\n            <feComposite in2="SourceAlpha" operator="in"/>\n        `\n    );\n  },\n  signature: ({ color, dx, dy, blur }) => `dids_${color}_${blur}_${dx}_${dy}`\n});\n\nLib.addFilter(\'art\', {\n  generate: function({ id }) {\n    const key = this.signature;\n    const existing = this.defs.select(`#${key}`);\n\n    if (!existing.empty()) return existing;\n\n    this.defs.html(\n      this.defs.html() +\n        `\n        <!-- stripy noise -->\n        <feTurbulence type="fractalNoise" baseFrequency="0.005 0.05" numOctaves="10" result="noisy" />\n        <feColorMatrix type="saturate" values="0" result="noisyGrey"/>\n        <feComponentTransfer>\n          <feFuncA type="linear" slope="0.5"></feFuncA>\n        </feComponentTransfer>\n        <feComposite in2="SourceGraphic" operator="in" />\n        <!-- limit noise to paths -->\n        <!-- <feComposite in2="SourceGraphic" operator="over" /> -->\n\n        <!-- <feBlend in2="SourceGraphic" mode="color-dodge" /> -->\n        <!-- <feBlend in2="SourceGraphic" mode="color-burn" /> -->\n        <feBlend in2="SourceGraphic" mode="luminosity" />\n        <feColorMatrix type="saturate" values="1.3" result="handDrawn"/>\n\n        \n        <!-- paper noise -->\n        <!-- <feTurbulence type="turbulence" baseFrequency=\'0.01 0.1\' numOctaves="2" result=\'noise\' />\n        <feDiffuseLighting in=\'noise\' lighting-color=\'white\' surfaceScale=\'2\' result="light">\n              <feDistantLight azimuth=\'45\' elevation=\'60\' />\n        </feDiffuseLighting>\n        <feComposite in2="SourceGraphic" operator="in" />\n        <feComponentTransfer>\n          <feFuncA type="linear" slope="0.5"></feFuncA>\n        </feComponentTransfer>\n        <feBlend in2="SourceGraphic" mode="multiply" />\n        <feColorMatrix type="saturate" values="1.3" result="handDrawn"/> -->\n\n        <!-- inner shadow test (not working)-->\n        <feMorphology operator=\'erode\' radius=7 result="inner"></feMorphology>\n        <feComposite in="SourceGraphic" in2="inner" operator="out" result="outer"/>\n        <feFlood flood-color="black"></feFlood>\n        <feComposite in2="outer" operator="in"></feComposite>\n        <feMorphology operator=\'dilate\' radius=1 result="outer2"></feMorphology>\n        <feGaussianBlur stdDeviation="5" result="innerShadow"></feGaussianBlur>\n\n        <!-- top shadow -->\n        <feFlood flood-color="black"></feFlood>\n        <feComposite in2="SourceGraphic" operator="in"></feComposite>\n        <feGaussianBlur stdDeviation="5" result="blur"></feGaussianBlur>\n        <feOffset dy="3" dx="3"></feOffset>\n        <feComposite in2="SourceGraphic" operator="arithmetic" k2="-1" k3="1" result="shadowDiff"></feComposite>\n        <feFlood flood-color="#000" flood-opacity="0.75"></feFlood>\n        <feComposite in2="shadowDiff" operator="in" result="innerShadowTop"></feComposite>\n        <!-- bottom shadow -->\n        <feFlood flood-color="black"></feFlood>\n        <feComposite in2="SourceGraphic" operator="in"></feComposite>\n        <feGaussianBlur stdDeviation="5" result="blur"></feGaussianBlur>\n        <feOffset dy="-5" dx="3"></feOffset>\n        <feComposite in2="SourceGraphic" operator="arithmetic" k2="-1" k3="1" result="shadowDiff"></feComposite>\n        <feFlood flood-color="#000" flood-opacity="1"></feFlood>\n        <feComposite in2="shadowDiff" operator="in" result="innerShadowBottom"></feComposite>\n\n        <!-- original top/bottom mix -->\n        <feFlood flood-color="black"></feFlood>\n        <feComposite in2="SourceGraphic" operator="in"></feComposite>\n        <feGaussianBlur stdDeviation="5" result="blur"></feGaussianBlur>\n        <feOffset dy="7" dx="3"></feOffset>\n        <feComposite in2="handDrawn" operator="arithmetic" k2="-1" k3="1" result="shadowDiff"></feComposite>\n        <feFlood flood-color="#000" flood-opacity="1"></feFlood>\n        <feComposite in2="shadowDiff" operator="in" result="firstFilter"></feComposite>\n        <feComposite in2="handDrawn" operator="over" result="firstFilter"/>\n        <feGaussianBlur in="firstFilter" stdDeviation="3" result="blur2"></feGaussianBlur>\n        <feOffset dy="-7" dx="-3"></feOffset>\n        <feComposite in2="firstFilter" operator="arithmetic" k2="-1" k3="1" result="shadowDiff"></feComposite>\n        <feFlood flood-color="#000" flood-opacity="0.75"></feFlood>\n        <feComposite in2="shadowDiff" operator="in"></feComposite>\n        <feComposite in2="firstFilter" operator="over" result="innerShadow"></feComposite>\n\n        <!-- stroke -->\n        <feFlood in="SourceGraphic" flood-color="black"></feFlood>\n        <feComposite in2="SourceGraphic" operator="in"></feComposite>\n        <feMorphology operator=\'dilate\' radius=3></feMorphology>\n        <feComposite in2="SourceGraphic" operator="out" result="stroke"></feComposite>\n\n        <!-- outer shadow -->\n        <feFlood flood-color="black"></feFlood>\n        <feComposite in2="SourceGraphic" operator="in"></feComposite>\n        <feMorphology operator=\'dilate\' radius=3></feMorphology>\n        <feGaussianBlur stdDeviation="5" result="shadow"></feGaussianBlur>\n\n        <!-- combine all filters -->\n        <feBlend in="handDrawn" in2="shadow"/>\n        <!-- <feBlend in="innerShadow"/> -->\n        <!-- <feBlend in="innerShadowTop"/> -->\n        <feBlend in="innerShadowBottom"/>\n        <feBlend in="stroke"/>\n        `\n    );\n  },\n  signature: ({ color, dx, dy, blur }) => `art_`\n});\n\nclass SVGFilterManager {\n  constructor(defs) {\n    this._filters = {\n      boxShadow: {}\n    }; // Type : filterKey : id\n\n    this._defs = defs;\n    this._ids = {};\n\n    this._bindings = {}; // id : [DOMNode]\n  }\n\n  _bind(selection, id) {\n    const bindings = this._bindings[id];\n\n    selection.each(function(d, i) {\n      bindings.push(this);\n    });\n  }\n\n  _unbind(selection, id) {\n    const bindings = this._bindings[id];\n\n    const toRemove = [];\n    selection.each(function(d, i) {\n      toRemove.push(this);\n    });\n\n    bindings[id] = bindings.filter(node => !toRemove.includes(node));\n\n    if (bindings[id].length === 0) this._deleteFilter(id);\n  }\n\n  _deleteFilter(id) {\n    let toDelete;\n    Object.entries(this._ids).forEach(([signature, theID]) => {\n      if (theID === id) {\n        toDelete = signature;\n        return false;\n      }\n    });\n\n    delete this._ids[toDelete];\n    delete this._bindings[id];\n    this._defs.select(\'#\' + id).remove();\n  }\n\n  hasFilter(signature) {\n    return !!this._ids[signature];\n    // return !this._defs.select(\'#\' + signature).empty();\n  }\n\n  signature(...args) {\n    // [\'name\', arg, \'name2\', arg]\n    // [\'\', ]\n    return (\n      \'F_\' +\n      args\n        .map((arg, i) => (i % 2 === 0 ? \'\' : Lib.signature(args[i - 1], arg)))\n        .filter(v => v !== \'\')\n        .join(\'_\')\n    );\n  }\n\n  /**\n   * Creates a filter from the list of filters in the format\n   * (filter-name-1, args1, filter-name-2, args2, ... , filter-name-N, argsN)\n   *\n   * @param {*} args\n   * @memberof SVGFilterManager\n   */\n  createFilter(...args) {\n    // 1. Compute signature and see if it already exists\n    const signature = this.signature(...args);\n\n    if (this.hasFilter(signature)) return this.getFilterID(signature);\n\n    const theID = (this._ids[signature] = SVGFilterManager._genID());\n    this._bindings[theID] = [];\n\n    const filterEntry = this._defs\n      .append(\'filter\')\n      .attr(\'id\', theID)\n      .attr(\'height\', \'300%\')\n      .attr(\'width\', \'300%\')\n      .attr(\'x\', \'-100%\')\n      .attr(\'y\', \'-100%\');\n\n    filterEntry.node().__filters__ = [];\n\n    args.forEach((arg, i) => {\n      if (i % 2 === 0) return Lib.generate(filterEntry, arg, args[i + 1]);\n    });\n\n    return theID;\n  }\n\n  static _genID() {\n    if (!this.__idc__) this.__idc__ = 0;\n    return `FILTER_${this.__idc__++}`;\n  }\n\n  // _genID() {\n  // }\n\n  getFilterID(signature) {\n    return this._ids[signature];\n  }\n}\n\nd3.selection.prototype.svgFilter = function(...filters) {\n  // name, args, name1, args1, ... ,nameN, argsN\n  // If no defs entry, generate one at the root and set it @ the svg filter manager\n  // create a new svg filter manager for that svg\n\n  // 1. Find topmost SVG\n  // let svg = d3.select(this.node().farthestViewportElement || this.node().closest(\'svg\'));\n\n  // // 2. Ensure the defs entry exists\n  // let defs = svg.select(\':scope>defs.svg-custom-filters\');\n  // if (defs.empty()) {\n  //     defs = svg.append(\'defs\').attr(\'class\', \'svg-custom-filters\');\n  //     defs.node()._svgFilterManager = new SVGFilterManager(defs);\n  // }\n\n  const defs = this.svgFilterDefs();\n\n  const filterManager = defs.node()._svgFilterManager;\n  const filterID = filterManager.createFilter(...filters);\n\n  this.each(function(d) {\n    const sel = d3.select(this);\n    if (filterID === sel.getFilterID()) return;\n    sel.clearFilter();\n\n    sel.attr(\'filter\', `url(#${filterID})`);\n    filterManager._bind(sel, filterID);\n  });\n\n  // 3. Generate a filter manager if not existing\n\n  // TheFilterManager._defs;\n  // const ids = GenSVGFilters(filters);\n};\n\nd3.selection.prototype.svgFilterDefs = function() {\n  // 1. Find topmost SVG\n  let svg = d3.select(\n    this.node().farthestViewportElement || this.node().closest(\'svg\')\n  );\n\n  // 2. Ensure the defs entry exists\n  let defs = svg.select(\':scope>defs.svg-custom-filters\');\n  if (defs.empty()) {\n    defs = svg.append(\'defs\').attr(\'class\', \'svg-custom-filters\');\n    defs.node()._svgFilterManager = new SVGFilterManager(defs);\n  }\n\n  return defs;\n};\n\nd3.selection.prototype.getFilterID = function() {\n  const filterAttr = this.attr(\'filter\');\n\n  let filterID;\n  if (!!filterAttr) filterID = /\\(\\#(.+)\\)/.exec(filterAttr)[1];\n\n  return filterID;\n};\n\nd3.selection.prototype.clearFilter = function() {\n  this.each(function(d, i) {\n    const sel = d3.select(this);\n    const filterID = sel.getFilterID();\n    if (!filterID) return;\n\n    const defs = sel.svgFilterDefs();\n    const filterManager = defs.node()._svgFilterManager;\n\n    sel.attr(\'filter\', null);\n    filterManager._unbind(sel, filterID);\n  });\n\n  return this;\n};\n\nd3.svgFilterLib = Lib;\n\n// const originalRemove = d3.selection.prototype.remove;\n// d3.selection.prototype.remove = function () { // Add in clear filter to remove fn!\n//     this.selectAll(\'*\').clearFilter();\n//     originalRemove.call(this, ...arguments);\n// }\n\n// d3.svgFilter = (name, args) => lib.filter(name)(args);\n\n// Example usage\nconst selection = {};\n\n// selection\n//     .svgFilter(\n//         d3.svgFilterBoxShadow({\n//             dx: \'5%\',\n//             dy: \'5%\',\n//             blur: \'25%\'\n//         }),\n//         d3.svgFilterBoxShadowInset({\n//             dx: \'5%\',\n//             dy: \'5%\',\n//             blur: \'25%\'\n//         })\n//     );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9saWJzL2Qzc3ZnZmlsdGVycy9zcmMvZDMtc3ZnLWZpbHRlcnMuanM/NDRkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLEtBQTZCLEdBQUcsbUJBQU8sQ0FBQyxjQUFJLElBQUksU0FBUzs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksZ0NBQWdDLDBCQUEwQjtBQUM3Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxrQ0FBa0MsK0JBQStCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUIsc0JBQXNCLEdBQUc7QUFDekIsc0JBQXNCLEdBQUc7QUFDekIsZ0NBQWdDLEtBQUs7QUFDckMsOEJBQThCLE1BQU07QUFDcEM7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxlQUFlLHNCQUFzQixXQUFXLE1BQU0sR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDMUUsQ0FBQzs7QUFFRDtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxlQUFlLE9BQU8sWUFBWSxLQUFLO0FBQ3ZDLENBQUM7O0FBRUQ7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0EsMENBQTBDLElBQUk7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxLQUFLLGdCQUFnQixHQUFHO0FBQ3JGLDJCQUEyQixHQUFHLE1BQU0sR0FBRztBQUN2QyxnR0FBZ0csR0FBRztBQUNuRyxtQ0FBbUMsTUFBTTtBQUN6QywwQ0FBMEMsR0FBRztBQUM3QyxrRkFBa0YsR0FBRztBQUNyRiwwQ0FBMEMsR0FBRztBQUM3QywyQ0FBMkMsR0FBRztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCLFlBQVksTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztBQUMzRSxDQUFDOztBQUVEO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBLDBDQUEwQyxJQUFJOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRztBQUNuRTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUcsa0JBQWtCLEtBQUssZ0JBQWdCLEdBQUc7QUFDckYsZ0NBQWdDLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyx1QkFBdUIsR0FBRztBQUNuRixnQ0FBZ0MsR0FBRyxRQUFRLElBQUksdUJBQXVCLEdBQUc7QUFDekUsb0NBQW9DLE1BQU07QUFDMUMsMkNBQTJDLEdBQUcsd0NBQXdDLEdBQUc7QUFDekYsb0NBQW9DLE1BQU07QUFDMUMsMkNBQTJDLEdBQUcsd0NBQXdDLEdBQUc7QUFDekY7QUFDQTtBQUNBLDhDQUE4QyxHQUFHO0FBQ2pELDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsc0JBQXNCLGFBQWEsTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRztBQUM1RSxDQUFDOztBQUVEO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQSwwQ0FBMEMsSUFBSTs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLHNCQUFzQjtBQUNyQyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJmaWxlIjoiLi9saWJzL2Qzc3ZnZmlsdGVycy9zcmMvZDMtc3ZnLWZpbHRlcnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkMyA9IHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gcmVxdWlyZSgnZDMnKSA6IHdpbmRvdy5kMztcblxuY2xhc3MgU1ZHRmlsdGVyIHtcbiAgY29uc3RydWN0b3Ioc3BlYykge31cblxuICBzZXQgaWQoaWQpIHtcbiAgICB0aGlzLl9pZCA9IGlkO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cbn1cblxuY2xhc3MgU1ZHRmlsdGVyTWFuYWdlckxpYnJhcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9saWJyYXJ5ID0ge307IC8vIG5hbWUgOiB7IGdlbmVyYXRlOiAoZGVmcykgPT4gKGFyZ3MpID0+IHsgIGFwcGVuZHMgZmlsdGVyIHRvIGRlZnMgfSwgc2lnbmF0dXJlOiAoYXJncykgPT4ga2V5fVxuICB9XG5cbiAgc3RhdGljIEdlbmVyYXRlSUQoKSB7XG4gICAgaWYgKCF0aGlzLl9fSUQpIHRoaXMuX19JRCA9IDA7XG5cbiAgICByZXR1cm4gKyt0aGlzLl9fSUQ7XG4gIH1cblxuICBhZGRGaWx0ZXIobmFtZSwgZm5zKSB7XG4gICAgdGhpcy5fbGlicmFyeVtuYW1lXSA9IGZucztcbiAgfVxuXG4gIHNpZ25hdHVyZShmaWx0ZXJOYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpYnJhcnlbZmlsdGVyTmFtZV1cbiAgICAgIC5zaWduYXR1cmUoYXJncylcbiAgICAgIC5yZXBsYWNlKC9cXDp8XFwsfFxcLnxcXDsvZywgJ18nKVxuICAgICAgLnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAucmVwbGFjZSgvXFwjL2csICdoJylcbiAgICAgIC5yZXBsYWNlKC9cXCgvZywgJ2wnKVxuICAgICAgLnJlcGxhY2UoL1xcKS9nLCAncicpO1xuICB9XG5cbiAgZ2VuZXJhdGUoZGVmcywgZmlsdGVyTmFtZSwgYXJncykge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbmF0dXJlKGZpbHRlck5hbWUsIGFyZ3MpO1xuICAgIGNvbnN0IGN0eCA9IHsgc2lnbmF0dXJlLCBkZWZzIH07XG4gICAgY29uc3QgdGhlRmlsdGVyID0gdGhpcy5fbGlicmFyeVtmaWx0ZXJOYW1lXS5nZW5lcmF0ZS5jYWxsKGN0eCwge1xuICAgICAgLi4uYXJncyxcbiAgICAgIGlkOiBTVkdGaWx0ZXJNYW5hZ2VyTGlicmFyeS5HZW5lcmF0ZUlEKClcbiAgICB9KTtcblxuICAgIGRlZnMubm9kZSgpLl9fZmlsdGVyc19fLnB1c2goeyBzaWduYXR1cmUsIGZpbHRlcjogdGhlRmlsdGVyIH0pO1xuICB9XG5cbiAgc3RhdGljIFN1ZmZpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3N1ZmZpeCkgdGhpcy5fc3VmZml4ID0gMDtcbiAgICByZXR1cm4gdGhpcy5fc3VmZml4Kys7XG4gIH1cblxuICBtYWtlVW5pcXVlKGZpbHRlclRleHQpIHtcbiAgICBjb25zdCB2YXJOYW1lcyA9IC9yZXN1bHQ9KC4rPykvZy50ZXN0KGZpbHRlclRleHQpO1xuICB9XG59XG5cbmNvbnN0IEdlblNWR0ZpbHRlcnMgPSAoLi4uZmlsdGVycykgPT4ge307XG5cbmNvbnN0IExpYiA9IG5ldyBTVkdGaWx0ZXJNYW5hZ2VyTGlicmFyeSgpO1xuTGliLmFkZEZpbHRlcignZHJvcC1zaGFkb3cnLCB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGNvbG9yLCBkeCwgZHksIGJsdXIgfSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5kZWZzLnNlbGVjdChgIyR7a2V5fWApO1xuXG4gICAgaWYgKCFleGlzdGluZy5lbXB0eSgpKSByZXR1cm4gZXhpc3Rpbmc7XG5cbiAgICBjb25zdCB0aGVEcm9wU2hhZG93ID0gdGhpcy5kZWZzLmh0bWwoXG4gICAgICB0aGlzLmRlZnMuaHRtbCgpICtcbiAgICAgICAgYFxuICAgICAgICAgICAgPGZlRHJvcFNoYWRvd1xuICAgICAgICAgICAgICAgIGlkPScke2tleX0nXG4gICAgICAgICAgICAgICAgZHg9JyR7ZHh9J1xuICAgICAgICAgICAgICAgIGR5PScke2R5fSdcbiAgICAgICAgICAgICAgICBzdGREZXZpYXRpb249JyR7Ymx1cn0nXG4gICAgICAgICAgICAgICAgZmxvb2QtY29sb3I9JHtjb2xvcn0gLz5cbiAgICAgICAgYFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhlRHJvcFNoYWRvdztcbiAgfSxcbiAgc2lnbmF0dXJlOiAoeyBjb2xvciwgZHgsIGR5LCBibHVyIH0pID0+IGBkc18ke2NvbG9yfV8ke2JsdXJ9XyR7ZHh9XyR7ZHl9YFxufSk7XG5cbkxpYi5hZGRGaWx0ZXIoJ2JsdXInLCB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGJsdXIgfSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5kZWZzLnNlbGVjdChgIyR7a2V5fWApO1xuXG4gICAgaWYgKCFleGlzdGluZy5lbXB0eSgpKSByZXR1cm4gZXhpc3Rpbmc7XG5cbiAgICBjb25zdCB0aGVCbHVyID0gdGhpcy5kZWZzXG4gICAgICAuYXBwZW5kKCdmZUdhdXNzaWFuQmx1cicpXG4gICAgICAuYXR0cignc3RkRGV2aWF0aW9uJywgYmx1cik7XG5cbiAgICByZXR1cm4gdGhlQmx1cjtcbiAgfSxcbiAgc2lnbmF0dXJlOiAoeyBibHVyIH0pID0+IGBnYmxfJHtibHVyfWBcbn0pO1xuXG5MaWIuYWRkRmlsdGVyKCdpbm5lci1zaGFkb3cnLCB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbih7IGlkLCBjb2xvciwgZHgsIGR5LCBibHVyIH0pIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnNpZ25hdHVyZTtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZGVmcy5zZWxlY3QoYCMke2tleX1gKTtcblxuICAgIGlmICghZXhpc3RpbmcuZW1wdHkoKSkgcmV0dXJuIGV4aXN0aW5nO1xuXG4gICAgdGhpcy5kZWZzLmh0bWwoXG4gICAgICB0aGlzLmRlZnMuaHRtbCgpICtcbiAgICAgICAgYFxuICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIGluPSdTb3VyY2VBbHBoYScgc3RkRGV2aWF0aW9uPScke2JsdXJ9JyByZXN1bHQ9J2JsdXIke2lkfScvPlxuICAgICAgICAgICAgPGZlT2Zmc2V0IGR4PSR7ZHh9IGR5PSR7ZHl9Lz5cbiAgICAgICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9J1NvdXJjZUFscGhhJyBvcGVyYXRvcj0nYXJpdGhtZXRpYycgazI9LTEgazM9MSByZXN1bHQ9J3NoYWRvd0RpZmYke2lkfScvPlxuICAgICAgICAgICAgPGZlRmxvb2QgZmxvb2QtY29sb3I9JHtjb2xvcn0vPlxuICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluMj0nc2hhZG93RGlmZiR7aWR9JyBvcGVyYXRvcj0naW4nLz4gXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPSdTb3VyY2VHcmFwaGljJyBvcGVyYXRvcj0nb3ZlcicgcmVzdWx0PSdmaXJzdEZpbHRlciR7aWR9Jy8+XG4gICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPSdzaGFkb3dEaWZmJHtpZH0nIG9wZXJhdG9yPSdpbicvPlxuICAgICAgICAgICAgPGZlQ29tcG9zaXRlIGluMj0nZmlyc3RGaWx0ZXIke2lkfScgb3BlcmF0b3I9J292ZXInLz5cbiAgICAgICAgYFxuICAgICk7XG4gIH0sXG4gIHNpZ25hdHVyZTogKHsgY29sb3IsIGR4LCBkeSwgYmx1ciB9KSA9PiBgaWRzXyR7Y29sb3J9XyR7Ymx1cn1fJHtkeH1fJHtkeX1gXG59KTtcblxuTGliLmFkZEZpbHRlcignZG91YmxlLWlubmVyLXNoYWRvdycsIHtcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHsgaWQsIGNvbG9yLCBkeCwgZHksIGJsdXIgfSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5kZWZzLnNlbGVjdChgIyR7a2V5fWApO1xuXG4gICAgaWYgKCFleGlzdGluZy5lbXB0eSgpKSByZXR1cm4gZXhpc3Rpbmc7XG5cbiAgICB0aGlzLmRlZnMuaHRtbChcbiAgICAgIHRoaXMuZGVmcy5odG1sKCkgK1xuICAgICAgICBgXG4gICAgICAgICAgICA8ZmVDb21wb25lbnRUcmFuc2ZlciBpbj1Tb3VyY2VBbHBoYSByZXN1bHQ9XCJpbnZlcnQke2lkfVwiPlxuICAgICAgICAgICAgICAgIDxmZUZ1bmNBIHR5cGU9XCJ0YWJsZVwiIHRhYmxlVmFsdWVzPVwiMSAwXCIvPlxuICAgICAgICAgICAgPC9mZUNvbXBvbmVudFRyYW5zZmVyPlxuICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIGluPVwiaW52ZXJ0JHtpZH1cIiBzdGREZXZpYXRpb249XCIke2JsdXJ9XCIgcmVzdWx0PVwiYmx1ciR7aWR9XCIvPlxuICAgICAgICAgICAgPGZlT2Zmc2V0IGluPVwiYmx1ciR7aWR9XCIgZHg9XCIke2R4fVwiIGR5PVwiJHtkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyMSR7aWR9XCIvPlxuICAgICAgICAgICAgPGZlT2Zmc2V0IGluPVwiYmx1ciR7aWR9XCIgZHk9XCIkey1keX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyMiR7aWR9XCIvPlxuICAgICAgICAgICAgPGZlRmxvb2QgZmxvb2QtY29sb3I9XCIke2NvbG9yfVwiLz4gXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1cjEke2lkfVwiIG9wZXJhdG9yPVwiaW5cIiByZXN1bHQ9XCJvZmZzZXRibHVyMWN1dCR7aWR9XCIvPlxuICAgICAgICAgICAgPGZlRmxvb2QgZmxvb2QtY29sb3I9XCIke2NvbG9yfVwiLz4gXG4gICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1cjIke2lkfVwiIG9wZXJhdG9yPVwiaW5cIiByZXN1bHQ9XCJvZmZzZXRibHVyMmN1dCR7aWR9XCIvPlxuICAgICAgICAgICAgPGZlTWVyZ2U+XG4gICAgICAgICAgICAgICAgPGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiIC8+XG4gICAgICAgICAgICAgICAgPGZlTWVyZ2VOb2RlIGluPVwib2Zmc2V0Ymx1cjEke2lkfVwiIC8+XG4gICAgICAgICAgICAgICAgPGZlTWVyZ2VOb2RlIGluPVwib2Zmc2V0Ymx1cjIke2lkfVwiIC8+XG4gICAgICAgICAgICA8L2ZlTWVyZ2U+XG4gICAgICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwiU291cmNlQWxwaGFcIiBvcGVyYXRvcj1cImluXCIvPlxuICAgICAgICBgXG4gICAgKTtcbiAgfSxcbiAgc2lnbmF0dXJlOiAoeyBjb2xvciwgZHgsIGR5LCBibHVyIH0pID0+IGBkaWRzXyR7Y29sb3J9XyR7Ymx1cn1fJHtkeH1fJHtkeX1gXG59KTtcblxuTGliLmFkZEZpbHRlcignYXJ0Jywge1xuICBnZW5lcmF0ZTogZnVuY3Rpb24oeyBpZCB9KSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5zaWduYXR1cmU7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmRlZnMuc2VsZWN0KGAjJHtrZXl9YCk7XG5cbiAgICBpZiAoIWV4aXN0aW5nLmVtcHR5KCkpIHJldHVybiBleGlzdGluZztcblxuICAgIHRoaXMuZGVmcy5odG1sKFxuICAgICAgdGhpcy5kZWZzLmh0bWwoKSArXG4gICAgICAgIGBcbiAgICAgICAgPCEtLSBzdHJpcHkgbm9pc2UgLS0+XG4gICAgICAgIDxmZVR1cmJ1bGVuY2UgdHlwZT1cImZyYWN0YWxOb2lzZVwiIGJhc2VGcmVxdWVuY3k9XCIwLjAwNSAwLjA1XCIgbnVtT2N0YXZlcz1cIjEwXCIgcmVzdWx0PVwibm9pc3lcIiAvPlxuICAgICAgICA8ZmVDb2xvck1hdHJpeCB0eXBlPVwic2F0dXJhdGVcIiB2YWx1ZXM9XCIwXCIgcmVzdWx0PVwibm9pc3lHcmV5XCIvPlxuICAgICAgICA8ZmVDb21wb25lbnRUcmFuc2Zlcj5cbiAgICAgICAgICA8ZmVGdW5jQSB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIwLjVcIj48L2ZlRnVuY0E+XG4gICAgICAgIDwvZmVDb21wb25lbnRUcmFuc2Zlcj5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cIlNvdXJjZUdyYXBoaWNcIiBvcGVyYXRvcj1cImluXCIgLz5cbiAgICAgICAgPCEtLSBsaW1pdCBub2lzZSB0byBwYXRocyAtLT5cbiAgICAgICAgPCEtLSA8ZmVDb21wb3NpdGUgaW4yPVwiU291cmNlR3JhcGhpY1wiIG9wZXJhdG9yPVwib3ZlclwiIC8+IC0tPlxuXG4gICAgICAgIDwhLS0gPGZlQmxlbmQgaW4yPVwiU291cmNlR3JhcGhpY1wiIG1vZGU9XCJjb2xvci1kb2RnZVwiIC8+IC0tPlxuICAgICAgICA8IS0tIDxmZUJsZW5kIGluMj1cIlNvdXJjZUdyYXBoaWNcIiBtb2RlPVwiY29sb3ItYnVyblwiIC8+IC0tPlxuICAgICAgICA8ZmVCbGVuZCBpbjI9XCJTb3VyY2VHcmFwaGljXCIgbW9kZT1cImx1bWlub3NpdHlcIiAvPlxuICAgICAgICA8ZmVDb2xvck1hdHJpeCB0eXBlPVwic2F0dXJhdGVcIiB2YWx1ZXM9XCIxLjNcIiByZXN1bHQ9XCJoYW5kRHJhd25cIi8+XG5cbiAgICAgICAgXG4gICAgICAgIDwhLS0gcGFwZXIgbm9pc2UgLS0+XG4gICAgICAgIDwhLS0gPGZlVHVyYnVsZW5jZSB0eXBlPVwidHVyYnVsZW5jZVwiIGJhc2VGcmVxdWVuY3k9JzAuMDEgMC4xJyBudW1PY3RhdmVzPVwiMlwiIHJlc3VsdD0nbm9pc2UnIC8+XG4gICAgICAgIDxmZURpZmZ1c2VMaWdodGluZyBpbj0nbm9pc2UnIGxpZ2h0aW5nLWNvbG9yPSd3aGl0ZScgc3VyZmFjZVNjYWxlPScyJyByZXN1bHQ9XCJsaWdodFwiPlxuICAgICAgICAgICAgICA8ZmVEaXN0YW50TGlnaHQgYXppbXV0aD0nNDUnIGVsZXZhdGlvbj0nNjAnIC8+XG4gICAgICAgIDwvZmVEaWZmdXNlTGlnaHRpbmc+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJTb3VyY2VHcmFwaGljXCIgb3BlcmF0b3I9XCJpblwiIC8+XG4gICAgICAgIDxmZUNvbXBvbmVudFRyYW5zZmVyPlxuICAgICAgICAgIDxmZUZ1bmNBIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIjAuNVwiPjwvZmVGdW5jQT5cbiAgICAgICAgPC9mZUNvbXBvbmVudFRyYW5zZmVyPlxuICAgICAgICA8ZmVCbGVuZCBpbjI9XCJTb3VyY2VHcmFwaGljXCIgbW9kZT1cIm11bHRpcGx5XCIgLz5cbiAgICAgICAgPGZlQ29sb3JNYXRyaXggdHlwZT1cInNhdHVyYXRlXCIgdmFsdWVzPVwiMS4zXCIgcmVzdWx0PVwiaGFuZERyYXduXCIvPiAtLT5cblxuICAgICAgICA8IS0tIGlubmVyIHNoYWRvdyB0ZXN0IChub3Qgd29ya2luZyktLT5cbiAgICAgICAgPGZlTW9ycGhvbG9neSBvcGVyYXRvcj0nZXJvZGUnIHJhZGl1cz03IHJlc3VsdD1cImlubmVyXCI+PC9mZU1vcnBob2xvZ3k+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbj1cIlNvdXJjZUdyYXBoaWNcIiBpbjI9XCJpbm5lclwiIG9wZXJhdG9yPVwib3V0XCIgcmVzdWx0PVwib3V0ZXJcIi8+XG4gICAgICAgIDxmZUZsb29kIGZsb29kLWNvbG9yPVwiYmxhY2tcIj48L2ZlRmxvb2Q+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJvdXRlclwiIG9wZXJhdG9yPVwiaW5cIj48L2ZlQ29tcG9zaXRlPlxuICAgICAgICA8ZmVNb3JwaG9sb2d5IG9wZXJhdG9yPSdkaWxhdGUnIHJhZGl1cz0xIHJlc3VsdD1cIm91dGVyMlwiPjwvZmVNb3JwaG9sb2d5PlxuICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPVwiNVwiIHJlc3VsdD1cImlubmVyU2hhZG93XCI+PC9mZUdhdXNzaWFuQmx1cj5cblxuICAgICAgICA8IS0tIHRvcCBzaGFkb3cgLS0+XG4gICAgICAgIDxmZUZsb29kIGZsb29kLWNvbG9yPVwiYmxhY2tcIj48L2ZlRmxvb2Q+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJTb3VyY2VHcmFwaGljXCIgb3BlcmF0b3I9XCJpblwiPjwvZmVDb21wb3NpdGU+XG4gICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCI1XCIgcmVzdWx0PVwiYmx1clwiPjwvZmVHYXVzc2lhbkJsdXI+XG4gICAgICAgIDxmZU9mZnNldCBkeT1cIjNcIiBkeD1cIjNcIj48L2ZlT2Zmc2V0PlxuICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwiU291cmNlR3JhcGhpY1wiIG9wZXJhdG9yPVwiYXJpdGhtZXRpY1wiIGsyPVwiLTFcIiBrMz1cIjFcIiByZXN1bHQ9XCJzaGFkb3dEaWZmXCI+PC9mZUNvbXBvc2l0ZT5cbiAgICAgICAgPGZlRmxvb2QgZmxvb2QtY29sb3I9XCIjMDAwXCIgZmxvb2Qtb3BhY2l0eT1cIjAuNzVcIj48L2ZlRmxvb2Q+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJzaGFkb3dEaWZmXCIgb3BlcmF0b3I9XCJpblwiIHJlc3VsdD1cImlubmVyU2hhZG93VG9wXCI+PC9mZUNvbXBvc2l0ZT5cbiAgICAgICAgPCEtLSBib3R0b20gc2hhZG93IC0tPlxuICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cImJsYWNrXCI+PC9mZUZsb29kPlxuICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwiU291cmNlR3JhcGhpY1wiIG9wZXJhdG9yPVwiaW5cIj48L2ZlQ29tcG9zaXRlPlxuICAgICAgICA8ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPVwiNVwiIHJlc3VsdD1cImJsdXJcIj48L2ZlR2F1c3NpYW5CbHVyPlxuICAgICAgICA8ZmVPZmZzZXQgZHk9XCItNVwiIGR4PVwiM1wiPjwvZmVPZmZzZXQ+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJTb3VyY2VHcmFwaGljXCIgb3BlcmF0b3I9XCJhcml0aG1ldGljXCIgazI9XCItMVwiIGszPVwiMVwiIHJlc3VsdD1cInNoYWRvd0RpZmZcIj48L2ZlQ29tcG9zaXRlPlxuICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiMwMDBcIiBmbG9vZC1vcGFjaXR5PVwiMVwiPjwvZmVGbG9vZD5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cInNoYWRvd0RpZmZcIiBvcGVyYXRvcj1cImluXCIgcmVzdWx0PVwiaW5uZXJTaGFkb3dCb3R0b21cIj48L2ZlQ29tcG9zaXRlPlxuXG4gICAgICAgIDwhLS0gb3JpZ2luYWwgdG9wL2JvdHRvbSBtaXggLS0+XG4gICAgICAgIDxmZUZsb29kIGZsb29kLWNvbG9yPVwiYmxhY2tcIj48L2ZlRmxvb2Q+XG4gICAgICAgIDxmZUNvbXBvc2l0ZSBpbjI9XCJTb3VyY2VHcmFwaGljXCIgb3BlcmF0b3I9XCJpblwiPjwvZmVDb21wb3NpdGU+XG4gICAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCI1XCIgcmVzdWx0PVwiYmx1clwiPjwvZmVHYXVzc2lhbkJsdXI+XG4gICAgICAgIDxmZU9mZnNldCBkeT1cIjdcIiBkeD1cIjNcIj48L2ZlT2Zmc2V0PlxuICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwiaGFuZERyYXduXCIgb3BlcmF0b3I9XCJhcml0aG1ldGljXCIgazI9XCItMVwiIGszPVwiMVwiIHJlc3VsdD1cInNoYWRvd0RpZmZcIj48L2ZlQ29tcG9zaXRlPlxuICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiMwMDBcIiBmbG9vZC1vcGFjaXR5PVwiMVwiPjwvZmVGbG9vZD5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cInNoYWRvd0RpZmZcIiBvcGVyYXRvcj1cImluXCIgcmVzdWx0PVwiZmlyc3RGaWx0ZXJcIj48L2ZlQ29tcG9zaXRlPlxuICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwiaGFuZERyYXduXCIgb3BlcmF0b3I9XCJvdmVyXCIgcmVzdWx0PVwiZmlyc3RGaWx0ZXJcIi8+XG4gICAgICAgIDxmZUdhdXNzaWFuQmx1ciBpbj1cImZpcnN0RmlsdGVyXCIgc3RkRGV2aWF0aW9uPVwiM1wiIHJlc3VsdD1cImJsdXIyXCI+PC9mZUdhdXNzaWFuQmx1cj5cbiAgICAgICAgPGZlT2Zmc2V0IGR5PVwiLTdcIiBkeD1cIi0zXCI+PC9mZU9mZnNldD5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cImZpcnN0RmlsdGVyXCIgb3BlcmF0b3I9XCJhcml0aG1ldGljXCIgazI9XCItMVwiIGszPVwiMVwiIHJlc3VsdD1cInNoYWRvd0RpZmZcIj48L2ZlQ29tcG9zaXRlPlxuICAgICAgICA8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiMwMDBcIiBmbG9vZC1vcGFjaXR5PVwiMC43NVwiPjwvZmVGbG9vZD5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cInNoYWRvd0RpZmZcIiBvcGVyYXRvcj1cImluXCI+PC9mZUNvbXBvc2l0ZT5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cImZpcnN0RmlsdGVyXCIgb3BlcmF0b3I9XCJvdmVyXCIgcmVzdWx0PVwiaW5uZXJTaGFkb3dcIj48L2ZlQ29tcG9zaXRlPlxuXG4gICAgICAgIDwhLS0gc3Ryb2tlIC0tPlxuICAgICAgICA8ZmVGbG9vZCBpbj1cIlNvdXJjZUdyYXBoaWNcIiBmbG9vZC1jb2xvcj1cImJsYWNrXCI+PC9mZUZsb29kPlxuICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwiU291cmNlR3JhcGhpY1wiIG9wZXJhdG9yPVwiaW5cIj48L2ZlQ29tcG9zaXRlPlxuICAgICAgICA8ZmVNb3JwaG9sb2d5IG9wZXJhdG9yPSdkaWxhdGUnIHJhZGl1cz0zPjwvZmVNb3JwaG9sb2d5PlxuICAgICAgICA8ZmVDb21wb3NpdGUgaW4yPVwiU291cmNlR3JhcGhpY1wiIG9wZXJhdG9yPVwib3V0XCIgcmVzdWx0PVwic3Ryb2tlXCI+PC9mZUNvbXBvc2l0ZT5cblxuICAgICAgICA8IS0tIG91dGVyIHNoYWRvdyAtLT5cbiAgICAgICAgPGZlRmxvb2QgZmxvb2QtY29sb3I9XCJibGFja1wiPjwvZmVGbG9vZD5cbiAgICAgICAgPGZlQ29tcG9zaXRlIGluMj1cIlNvdXJjZUdyYXBoaWNcIiBvcGVyYXRvcj1cImluXCI+PC9mZUNvbXBvc2l0ZT5cbiAgICAgICAgPGZlTW9ycGhvbG9neSBvcGVyYXRvcj0nZGlsYXRlJyByYWRpdXM9Mz48L2ZlTW9ycGhvbG9neT5cbiAgICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj1cIjVcIiByZXN1bHQ9XCJzaGFkb3dcIj48L2ZlR2F1c3NpYW5CbHVyPlxuXG4gICAgICAgIDwhLS0gY29tYmluZSBhbGwgZmlsdGVycyAtLT5cbiAgICAgICAgPGZlQmxlbmQgaW49XCJoYW5kRHJhd25cIiBpbjI9XCJzaGFkb3dcIi8+XG4gICAgICAgIDwhLS0gPGZlQmxlbmQgaW49XCJpbm5lclNoYWRvd1wiLz4gLS0+XG4gICAgICAgIDwhLS0gPGZlQmxlbmQgaW49XCJpbm5lclNoYWRvd1RvcFwiLz4gLS0+XG4gICAgICAgIDxmZUJsZW5kIGluPVwiaW5uZXJTaGFkb3dCb3R0b21cIi8+XG4gICAgICAgIDxmZUJsZW5kIGluPVwic3Ryb2tlXCIvPlxuICAgICAgICBgXG4gICAgKTtcbiAgfSxcbiAgc2lnbmF0dXJlOiAoeyBjb2xvciwgZHgsIGR5LCBibHVyIH0pID0+IGBhcnRfYFxufSk7XG5cbmNsYXNzIFNWR0ZpbHRlck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkZWZzKSB7XG4gICAgdGhpcy5fZmlsdGVycyA9IHtcbiAgICAgIGJveFNoYWRvdzoge31cbiAgICB9OyAvLyBUeXBlIDogZmlsdGVyS2V5IDogaWRcblxuICAgIHRoaXMuX2RlZnMgPSBkZWZzO1xuICAgIHRoaXMuX2lkcyA9IHt9O1xuXG4gICAgdGhpcy5fYmluZGluZ3MgPSB7fTsgLy8gaWQgOiBbRE9NTm9kZV1cbiAgfVxuXG4gIF9iaW5kKHNlbGVjdGlvbiwgaWQpIHtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzW2lkXTtcblxuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIGJpbmRpbmdzLnB1c2godGhpcyk7XG4gICAgfSk7XG4gIH1cblxuICBfdW5iaW5kKHNlbGVjdGlvbiwgaWQpIHtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzW2lkXTtcblxuICAgIGNvbnN0IHRvUmVtb3ZlID0gW107XG4gICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgdG9SZW1vdmUucHVzaCh0aGlzKTtcbiAgICB9KTtcblxuICAgIGJpbmRpbmdzW2lkXSA9IGJpbmRpbmdzLmZpbHRlcihub2RlID0+ICF0b1JlbW92ZS5pbmNsdWRlcyhub2RlKSk7XG5cbiAgICBpZiAoYmluZGluZ3NbaWRdLmxlbmd0aCA9PT0gMCkgdGhpcy5fZGVsZXRlRmlsdGVyKGlkKTtcbiAgfVxuXG4gIF9kZWxldGVGaWx0ZXIoaWQpIHtcbiAgICBsZXQgdG9EZWxldGU7XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5faWRzKS5mb3JFYWNoKChbc2lnbmF0dXJlLCB0aGVJRF0pID0+IHtcbiAgICAgIGlmICh0aGVJRCA9PT0gaWQpIHtcbiAgICAgICAgdG9EZWxldGUgPSBzaWduYXR1cmU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlbGV0ZSB0aGlzLl9pZHNbdG9EZWxldGVdO1xuICAgIGRlbGV0ZSB0aGlzLl9iaW5kaW5nc1tpZF07XG4gICAgdGhpcy5fZGVmcy5zZWxlY3QoJyMnICsgaWQpLnJlbW92ZSgpO1xuICB9XG5cbiAgaGFzRmlsdGVyKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiAhIXRoaXMuX2lkc1tzaWduYXR1cmVdO1xuICAgIC8vIHJldHVybiAhdGhpcy5fZGVmcy5zZWxlY3QoJyMnICsgc2lnbmF0dXJlKS5lbXB0eSgpO1xuICB9XG5cbiAgc2lnbmF0dXJlKC4uLmFyZ3MpIHtcbiAgICAvLyBbJ25hbWUnLCBhcmcsICduYW1lMicsIGFyZ11cbiAgICAvLyBbJycsIF1cbiAgICByZXR1cm4gKFxuICAgICAgJ0ZfJyArXG4gICAgICBhcmdzXG4gICAgICAgIC5tYXAoKGFyZywgaSkgPT4gKGkgJSAyID09PSAwID8gJycgOiBMaWIuc2lnbmF0dXJlKGFyZ3NbaSAtIDFdLCBhcmcpKSlcbiAgICAgICAgLmZpbHRlcih2ID0+IHYgIT09ICcnKVxuICAgICAgICAuam9pbignXycpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmlsdGVyIGZyb20gdGhlIGxpc3Qgb2YgZmlsdGVycyBpbiB0aGUgZm9ybWF0XG4gICAqIChmaWx0ZXItbmFtZS0xLCBhcmdzMSwgZmlsdGVyLW5hbWUtMiwgYXJnczIsIC4uLiAsIGZpbHRlci1uYW1lLU4sIGFyZ3NOKVxuICAgKlxuICAgKiBAcGFyYW0geyp9IGFyZ3NcbiAgICogQG1lbWJlcm9mIFNWR0ZpbHRlck1hbmFnZXJcbiAgICovXG4gIGNyZWF0ZUZpbHRlciguLi5hcmdzKSB7XG4gICAgLy8gMS4gQ29tcHV0ZSBzaWduYXR1cmUgYW5kIHNlZSBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbmF0dXJlKC4uLmFyZ3MpO1xuXG4gICAgaWYgKHRoaXMuaGFzRmlsdGVyKHNpZ25hdHVyZSkpIHJldHVybiB0aGlzLmdldEZpbHRlcklEKHNpZ25hdHVyZSk7XG5cbiAgICBjb25zdCB0aGVJRCA9ICh0aGlzLl9pZHNbc2lnbmF0dXJlXSA9IFNWR0ZpbHRlck1hbmFnZXIuX2dlbklEKCkpO1xuICAgIHRoaXMuX2JpbmRpbmdzW3RoZUlEXSA9IFtdO1xuXG4gICAgY29uc3QgZmlsdGVyRW50cnkgPSB0aGlzLl9kZWZzXG4gICAgICAuYXBwZW5kKCdmaWx0ZXInKVxuICAgICAgLmF0dHIoJ2lkJywgdGhlSUQpXG4gICAgICAuYXR0cignaGVpZ2h0JywgJzMwMCUnKVxuICAgICAgLmF0dHIoJ3dpZHRoJywgJzMwMCUnKVxuICAgICAgLmF0dHIoJ3gnLCAnLTEwMCUnKVxuICAgICAgLmF0dHIoJ3knLCAnLTEwMCUnKTtcblxuICAgIGZpbHRlckVudHJ5Lm5vZGUoKS5fX2ZpbHRlcnNfXyA9IFtdO1xuXG4gICAgYXJncy5mb3JFYWNoKChhcmcsIGkpID0+IHtcbiAgICAgIGlmIChpICUgMiA9PT0gMCkgcmV0dXJuIExpYi5nZW5lcmF0ZShmaWx0ZXJFbnRyeSwgYXJnLCBhcmdzW2kgKyAxXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhlSUQ7XG4gIH1cblxuICBzdGF0aWMgX2dlbklEKCkge1xuICAgIGlmICghdGhpcy5fX2lkY19fKSB0aGlzLl9faWRjX18gPSAwO1xuICAgIHJldHVybiBgRklMVEVSXyR7dGhpcy5fX2lkY19fKyt9YDtcbiAgfVxuXG4gIC8vIF9nZW5JRCgpIHtcbiAgLy8gfVxuXG4gIGdldEZpbHRlcklEKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB0aGlzLl9pZHNbc2lnbmF0dXJlXTtcbiAgfVxufVxuXG5kMy5zZWxlY3Rpb24ucHJvdG90eXBlLnN2Z0ZpbHRlciA9IGZ1bmN0aW9uKC4uLmZpbHRlcnMpIHtcbiAgLy8gbmFtZSwgYXJncywgbmFtZTEsIGFyZ3MxLCAuLi4gLG5hbWVOLCBhcmdzTlxuICAvLyBJZiBubyBkZWZzIGVudHJ5LCBnZW5lcmF0ZSBvbmUgYXQgdGhlIHJvb3QgYW5kIHNldCBpdCBAIHRoZSBzdmcgZmlsdGVyIG1hbmFnZXJcbiAgLy8gY3JlYXRlIGEgbmV3IHN2ZyBmaWx0ZXIgbWFuYWdlciBmb3IgdGhhdCBzdmdcblxuICAvLyAxLiBGaW5kIHRvcG1vc3QgU1ZHXG4gIC8vIGxldCBzdmcgPSBkMy5zZWxlY3QodGhpcy5ub2RlKCkuZmFydGhlc3RWaWV3cG9ydEVsZW1lbnQgfHwgdGhpcy5ub2RlKCkuY2xvc2VzdCgnc3ZnJykpO1xuXG4gIC8vIC8vIDIuIEVuc3VyZSB0aGUgZGVmcyBlbnRyeSBleGlzdHNcbiAgLy8gbGV0IGRlZnMgPSBzdmcuc2VsZWN0KCc6c2NvcGU+ZGVmcy5zdmctY3VzdG9tLWZpbHRlcnMnKTtcbiAgLy8gaWYgKGRlZnMuZW1wdHkoKSkge1xuICAvLyAgICAgZGVmcyA9IHN2Zy5hcHBlbmQoJ2RlZnMnKS5hdHRyKCdjbGFzcycsICdzdmctY3VzdG9tLWZpbHRlcnMnKTtcbiAgLy8gICAgIGRlZnMubm9kZSgpLl9zdmdGaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR0ZpbHRlck1hbmFnZXIoZGVmcyk7XG4gIC8vIH1cblxuICBjb25zdCBkZWZzID0gdGhpcy5zdmdGaWx0ZXJEZWZzKCk7XG5cbiAgY29uc3QgZmlsdGVyTWFuYWdlciA9IGRlZnMubm9kZSgpLl9zdmdGaWx0ZXJNYW5hZ2VyO1xuICBjb25zdCBmaWx0ZXJJRCA9IGZpbHRlck1hbmFnZXIuY3JlYXRlRmlsdGVyKC4uLmZpbHRlcnMpO1xuXG4gIHRoaXMuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgY29uc3Qgc2VsID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgIGlmIChmaWx0ZXJJRCA9PT0gc2VsLmdldEZpbHRlcklEKCkpIHJldHVybjtcbiAgICBzZWwuY2xlYXJGaWx0ZXIoKTtcblxuICAgIHNlbC5hdHRyKCdmaWx0ZXInLCBgdXJsKCMke2ZpbHRlcklEfSlgKTtcbiAgICBmaWx0ZXJNYW5hZ2VyLl9iaW5kKHNlbCwgZmlsdGVySUQpO1xuICB9KTtcblxuICAvLyAzLiBHZW5lcmF0ZSBhIGZpbHRlciBtYW5hZ2VyIGlmIG5vdCBleGlzdGluZ1xuXG4gIC8vIFRoZUZpbHRlck1hbmFnZXIuX2RlZnM7XG4gIC8vIGNvbnN0IGlkcyA9IEdlblNWR0ZpbHRlcnMoZmlsdGVycyk7XG59O1xuXG5kMy5zZWxlY3Rpb24ucHJvdG90eXBlLnN2Z0ZpbHRlckRlZnMgPSBmdW5jdGlvbigpIHtcbiAgLy8gMS4gRmluZCB0b3Btb3N0IFNWR1xuICBsZXQgc3ZnID0gZDMuc2VsZWN0KFxuICAgIHRoaXMubm9kZSgpLmZhcnRoZXN0Vmlld3BvcnRFbGVtZW50IHx8IHRoaXMubm9kZSgpLmNsb3Nlc3QoJ3N2ZycpXG4gICk7XG5cbiAgLy8gMi4gRW5zdXJlIHRoZSBkZWZzIGVudHJ5IGV4aXN0c1xuICBsZXQgZGVmcyA9IHN2Zy5zZWxlY3QoJzpzY29wZT5kZWZzLnN2Zy1jdXN0b20tZmlsdGVycycpO1xuICBpZiAoZGVmcy5lbXB0eSgpKSB7XG4gICAgZGVmcyA9IHN2Zy5hcHBlbmQoJ2RlZnMnKS5hdHRyKCdjbGFzcycsICdzdmctY3VzdG9tLWZpbHRlcnMnKTtcbiAgICBkZWZzLm5vZGUoKS5fc3ZnRmlsdGVyTWFuYWdlciA9IG5ldyBTVkdGaWx0ZXJNYW5hZ2VyKGRlZnMpO1xuICB9XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5kMy5zZWxlY3Rpb24ucHJvdG90eXBlLmdldEZpbHRlcklEID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGZpbHRlckF0dHIgPSB0aGlzLmF0dHIoJ2ZpbHRlcicpO1xuXG4gIGxldCBmaWx0ZXJJRDtcbiAgaWYgKCEhZmlsdGVyQXR0cikgZmlsdGVySUQgPSAvXFwoXFwjKC4rKVxcKS8uZXhlYyhmaWx0ZXJBdHRyKVsxXTtcblxuICByZXR1cm4gZmlsdGVySUQ7XG59O1xuXG5kMy5zZWxlY3Rpb24ucHJvdG90eXBlLmNsZWFyRmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgY29uc3Qgc2VsID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgIGNvbnN0IGZpbHRlcklEID0gc2VsLmdldEZpbHRlcklEKCk7XG4gICAgaWYgKCFmaWx0ZXJJRCkgcmV0dXJuO1xuXG4gICAgY29uc3QgZGVmcyA9IHNlbC5zdmdGaWx0ZXJEZWZzKCk7XG4gICAgY29uc3QgZmlsdGVyTWFuYWdlciA9IGRlZnMubm9kZSgpLl9zdmdGaWx0ZXJNYW5hZ2VyO1xuXG4gICAgc2VsLmF0dHIoJ2ZpbHRlcicsIG51bGwpO1xuICAgIGZpbHRlck1hbmFnZXIuX3VuYmluZChzZWwsIGZpbHRlcklEKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5kMy5zdmdGaWx0ZXJMaWIgPSBMaWI7XG5cbi8vIGNvbnN0IG9yaWdpbmFsUmVtb3ZlID0gZDMuc2VsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmU7XG4vLyBkMy5zZWxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHsgLy8gQWRkIGluIGNsZWFyIGZpbHRlciB0byByZW1vdmUgZm4hXG4vLyAgICAgdGhpcy5zZWxlY3RBbGwoJyonKS5jbGVhckZpbHRlcigpO1xuLy8gICAgIG9yaWdpbmFsUmVtb3ZlLmNhbGwodGhpcywgLi4uYXJndW1lbnRzKTtcbi8vIH1cblxuLy8gZDMuc3ZnRmlsdGVyID0gKG5hbWUsIGFyZ3MpID0+IGxpYi5maWx0ZXIobmFtZSkoYXJncyk7XG5cbi8vIEV4YW1wbGUgdXNhZ2VcbmNvbnN0IHNlbGVjdGlvbiA9IHt9O1xuXG4vLyBzZWxlY3Rpb25cbi8vICAgICAuc3ZnRmlsdGVyKFxuLy8gICAgICAgICBkMy5zdmdGaWx0ZXJCb3hTaGFkb3coe1xuLy8gICAgICAgICAgICAgZHg6ICc1JScsXG4vLyAgICAgICAgICAgICBkeTogJzUlJyxcbi8vICAgICAgICAgICAgIGJsdXI6ICcyNSUnXG4vLyAgICAgICAgIH0pLFxuLy8gICAgICAgICBkMy5zdmdGaWx0ZXJCb3hTaGFkb3dJbnNldCh7XG4vLyAgICAgICAgICAgICBkeDogJzUlJyxcbi8vICAgICAgICAgICAgIGR5OiAnNSUnLFxuLy8gICAgICAgICAgICAgYmx1cjogJzI1JSdcbi8vICAgICAgICAgfSlcbi8vICAgICApO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/d3svgfilters/src/d3-svg-filters.js\n'
          );

          /***/
        },

      /***/ './node_modules/css-loader/dist/cjs.js!./css/SplitStream.css':
        /*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css ***!
  \*******************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          eval(
            'exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);\n// Module\nexports.push([module.i, "", ""]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9jc3MvU3BsaXRTdHJlYW0uY3NzPzUxYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMscUdBQWdEO0FBQ25GO0FBQ0EsY0FBYyxRQUFTIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9jc3MvU3BsaXRTdHJlYW0uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./css/SplitStream.css\n'
          );

          /***/
        },

      /***/ './node_modules/css-loader/dist/runtime/api.js':
        /*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            '\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], "{").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwie1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW19pXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCIoXCIuY29uY2F0KGl0ZW1bMl0sIFwiKSBhbmQgKFwiKS5jb25jYXQobWVkaWFRdWVyeSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n'
          );

          /***/
        },

      /***/ './node_modules/flatted/esm/index.js':
        /*!*******************************************!*\
  !*** ./node_modules/flatted/esm/index.js ***!
  \*******************************************/
        /*! exports provided: default, parse, stringify */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\nvar Flatted = (function (Primitive, primitive) {\n\n  /*!\n   * ISC License\n   *\n   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection\n   *\n   * Permission to use, copy, modify, and/or distribute this software for any\n   * purpose with or without fee is hereby granted, provided that the above\n   * copyright notice and this permission notice appear in all copies.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n   * PERFORMANCE OF THIS SOFTWARE.\n   */\n\n  var Flatted = {\n\n    parse: function parse(text, reviver) {\n      var input = JSON.parse(text, Primitives).map(primitives);\n      var value = input[0];\n      var $ = reviver || noop;\n      var tmp = typeof value === 'object' && value ?\n                  revive(input, new Set, value, $) :\n                  value;\n      return $.call({'': tmp}, '', tmp);\n    },\n\n    stringify: function stringify(value, replacer, space) {\n      for (var\n        firstRun,\n        known = new Map,\n        input = [],\n        output = [],\n        $ = replacer && typeof replacer === typeof input ?\n              function (k, v) {\n                if (k === '' || -1 < replacer.indexOf(k)) return v;\n              } :\n              (replacer || noop),\n        i = +set(known, input, $.call({'': value}, '', value)),\n        replace = function (key, value) {\n          if (firstRun) {\n            firstRun = !firstRun;\n            return value;\n            // this was invoking twice each root object\n            // return i < 1 ? value : $.call(this, key, value);\n          }\n          var after = $.call(this, key, value);\n          switch (typeof after) {\n            case 'object':\n              if (after === null) return after;\n            case primitive:\n              return known.get(after) || set(known, input, after);\n          }\n          return after;\n        };\n        i < input.length; i++\n      ) {\n        firstRun = true;\n        output[i] = JSON.stringify(input[i], replace, space);\n      }\n      return '[' + output.join(',') + ']';\n    }\n\n  };\n\n  return Flatted;\n\n  function noop(key, value) {\n    return value;\n  }\n\n  function revive(input, parsed, output, $) {\n    return Object.keys(output).reduce(\n      function (output, key) {\n        var value = output[key];\n        if (value instanceof Primitive) {\n          var tmp = input[value];\n          if (typeof tmp === 'object' && !parsed.has(tmp)) {\n            parsed.add(tmp);\n            output[key] = $.call(output, key, revive(input, parsed, tmp, $));\n          } else {\n            output[key] = $.call(output, key, tmp);\n          }\n        } else\n          output[key] = $.call(output, key, value);\n        return output;\n      },\n      output\n    );\n  }\n\n  function set(known, input, value) {\n    var index = Primitive(input.push(value) - 1);\n    known.set(value, index);\n    return index;\n  }\n\n  // the two kinds of primitives\n  //  1. the real one\n  //  2. the wrapped one\n\n  function primitives(value) {\n    return value instanceof Primitive ? Primitive(value) : value;\n  }\n\n  function Primitives(key, value) {\n    return typeof value === primitive ? new Primitive(value) : value;\n  }\n\n}(String, 'string'));\n/* harmony default export */ __webpack_exports__[\"default\"] = (Flatted);\nvar parse = Flatted.parse;\nvar stringify = Flatted.stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvZmxhdHRlZC9lc20vaW5kZXguanM/NWJjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNjLHNFQUFPLEVBQUM7QUFDaEI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9mbGF0dGVkL2VzbS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBGbGF0dGVkID0gKGZ1bmN0aW9uIChQcmltaXRpdmUsIHByaW1pdGl2ZSkge1xuXG4gIC8qIVxuICAgKiBJU0MgTGljZW5zZVxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTgsIEFuZHJlYSBHaWFtbWFyY2hpLCBAV2ViUmVmbGVjdGlvblxuICAgKlxuICAgKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAgICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICAgKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICAgKlxuICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG4gICAqIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuICAgKiBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG4gICAqIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuICAgKiBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRVxuICAgKiBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG4gICAqIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gICAqL1xuXG4gIHZhciBGbGF0dGVkID0ge1xuXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRleHQsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnB1dCA9IEpTT04ucGFyc2UodGV4dCwgUHJpbWl0aXZlcykubWFwKHByaW1pdGl2ZXMpO1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbMF07XG4gICAgICB2YXIgJCA9IHJldml2ZXIgfHwgbm9vcDtcbiAgICAgIHZhciB0bXAgPSB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlID9cbiAgICAgICAgICAgICAgICAgIHJldml2ZShpbnB1dCwgbmV3IFNldCwgdmFsdWUsICQpIDpcbiAgICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgcmV0dXJuICQuY2FsbCh7Jyc6IHRtcH0sICcnLCB0bXApO1xuICAgIH0sXG5cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICBmb3IgKHZhclxuICAgICAgICBmaXJzdFJ1bixcbiAgICAgICAga25vd24gPSBuZXcgTWFwLFxuICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICBvdXRwdXQgPSBbXSxcbiAgICAgICAgJCA9IHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciA9PT0gdHlwZW9mIGlucHV0ID9cbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJycgfHwgLTEgPCByZXBsYWNlci5pbmRleE9mKGspKSByZXR1cm4gdjtcbiAgICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgIChyZXBsYWNlciB8fCBub29wKSxcbiAgICAgICAgaSA9ICtzZXQoa25vd24sIGlucHV0LCAkLmNhbGwoeycnOiB2YWx1ZX0sICcnLCB2YWx1ZSkpLFxuICAgICAgICByZXBsYWNlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoZmlyc3RSdW4pIHtcbiAgICAgICAgICAgIGZpcnN0UnVuID0gIWZpcnN0UnVuO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy8gdGhpcyB3YXMgaW52b2tpbmcgdHdpY2UgZWFjaCByb290IG9iamVjdFxuICAgICAgICAgICAgLy8gcmV0dXJuIGkgPCAxID8gdmFsdWUgOiAkLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhZnRlciA9ICQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhZnRlcikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgaWYgKGFmdGVyID09PSBudWxsKSByZXR1cm4gYWZ0ZXI7XG4gICAgICAgICAgICBjYXNlIHByaW1pdGl2ZTpcbiAgICAgICAgICAgICAgcmV0dXJuIGtub3duLmdldChhZnRlcikgfHwgc2V0KGtub3duLCBpbnB1dCwgYWZ0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGkgPCBpbnB1dC5sZW5ndGg7IGkrK1xuICAgICAgKSB7XG4gICAgICAgIGZpcnN0UnVuID0gdHJ1ZTtcbiAgICAgICAgb3V0cHV0W2ldID0gSlNPTi5zdHJpbmdpZnkoaW5wdXRbaV0sIHJlcGxhY2UsIHNwYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnWycgKyBvdXRwdXQuam9pbignLCcpICsgJ10nO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBGbGF0dGVkO1xuXG4gIGZ1bmN0aW9uIG5vb3Aoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldml2ZShpbnB1dCwgcGFyc2VkLCBvdXRwdXQsICQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob3V0cHV0KS5yZWR1Y2UoXG4gICAgICBmdW5jdGlvbiAob3V0cHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3V0cHV0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByaW1pdGl2ZSkge1xuICAgICAgICAgIHZhciB0bXAgPSBpbnB1dFt2YWx1ZV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB0bXAgPT09ICdvYmplY3QnICYmICFwYXJzZWQuaGFzKHRtcCkpIHtcbiAgICAgICAgICAgIHBhcnNlZC5hZGQodG1wKTtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gJC5jYWxsKG91dHB1dCwga2V5LCByZXZpdmUoaW5wdXQsIHBhcnNlZCwgdG1wLCAkKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gJC5jYWxsKG91dHB1dCwga2V5LCB0bXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgb3V0cHV0W2tleV0gPSAkLmNhbGwob3V0cHV0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0sXG4gICAgICBvdXRwdXRcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KGtub3duLCBpbnB1dCwgdmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSBQcmltaXRpdmUoaW5wdXQucHVzaCh2YWx1ZSkgLSAxKTtcbiAgICBrbm93bi5zZXQodmFsdWUsIGluZGV4KTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvLyB0aGUgdHdvIGtpbmRzIG9mIHByaW1pdGl2ZXNcbiAgLy8gIDEuIHRoZSByZWFsIG9uZVxuICAvLyAgMi4gdGhlIHdyYXBwZWQgb25lXG5cbiAgZnVuY3Rpb24gcHJpbWl0aXZlcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFByaW1pdGl2ZSA/IFByaW1pdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByaW1pdGl2ZXMoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IHByaW1pdGl2ZSA/IG5ldyBQcmltaXRpdmUodmFsdWUpIDogdmFsdWU7XG4gIH1cblxufShTdHJpbmcsICdzdHJpbmcnKSk7XG5leHBvcnQgZGVmYXVsdCBGbGF0dGVkO1xuZXhwb3J0IHZhciBwYXJzZSA9IEZsYXR0ZWQucGFyc2U7XG5leHBvcnQgdmFyIHN0cmluZ2lmeSA9IEZsYXR0ZWQuc3RyaW5naWZ5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/flatted/esm/index.js\n"
          );

          /***/
        },

      /***/ './node_modules/save-svg-as-png/lib/saveSvgAsPng.js':
        /*!**********************************************************!*\
  !*** ./node_modules/save-svg-as-png/lib/saveSvgAsPng.js ***!
  \**********************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            "var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n(function () {\n  var out$ =  true && exports ||  true && {} || this || window;\n  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return out$;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  out$.default = out$;\n\n  var xmlNs = 'http://www.w3.org/2000/xmlns/';\n  var xhtmlNs = 'http://www.w3.org/1999/xhtml';\n  var svgNs = 'http://www.w3.org/2000/svg';\n  var doctype = '<?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [<!ENTITY nbsp \"&#160;\">]>';\n  var urlRegex = /url\\([\"']?(.+?)[\"']?\\)/;\n  var fontFormats = {\n    woff2: 'font/woff2',\n    woff: 'font/woff',\n    otf: 'application/x-font-opentype',\n    ttf: 'application/x-font-ttf',\n    eot: 'application/vnd.ms-fontobject',\n    sfnt: 'application/font-sfnt',\n    svg: 'image/svg+xml'\n  };\n\n  var isElement = function isElement(obj) {\n    return obj instanceof HTMLElement || obj instanceof SVGElement;\n  };\n  var requireDomNode = function requireDomNode(el) {\n    if (!isElement(el)) throw new Error('an HTMLElement or SVGElement is required; got ' + el);\n  };\n  var requireDomNodePromise = function requireDomNodePromise(el) {\n    return new Promise(function (resolve, reject) {\n      if (isElement(el)) resolve(el);else reject(new Error('an HTMLElement or SVGElement is required; got ' + el));\n    });\n  };\n  var isExternal = function isExternal(url) {\n    return url && url.lastIndexOf('http', 0) === 0 && url.lastIndexOf(window.location.host) === -1;\n  };\n\n  var getFontMimeTypeFromUrl = function getFontMimeTypeFromUrl(fontUrl) {\n    var formats = Object.keys(fontFormats).filter(function (extension) {\n      return fontUrl.indexOf('.' + extension) > 0;\n    }).map(function (extension) {\n      return fontFormats[extension];\n    });\n    if (formats) return formats[0];\n    console.error('Unknown font format for ' + fontUrl + '. Fonts may not be working correctly.');\n    return 'application/octet-stream';\n  };\n\n  var arrayBufferToBase64 = function arrayBufferToBase64(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    for (var i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }return window.btoa(binary);\n  };\n\n  var getDimension = function getDimension(el, clone, dim) {\n    var v = el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim] || clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim)) || el.getBoundingClientRect()[dim] || parseInt(clone.style[dim]) || parseInt(window.getComputedStyle(el).getPropertyValue(dim));\n    return typeof v === 'undefined' || v === null || isNaN(parseFloat(v)) ? 0 : v;\n  };\n\n  var getDimensions = function getDimensions(el, clone, width, height) {\n    if (el.tagName === 'svg') return {\n      width: width || getDimension(el, clone, 'width'),\n      height: height || getDimension(el, clone, 'height')\n    };else if (el.getBBox) {\n      var _el$getBBox = el.getBBox(),\n          x = _el$getBBox.x,\n          y = _el$getBBox.y,\n          _width = _el$getBBox.width,\n          _height = _el$getBBox.height;\n\n      return {\n        width: x + _width,\n        height: y + _height\n      };\n    }\n  };\n\n  var reEncode = function reEncode(data) {\n    return decodeURIComponent(encodeURIComponent(data).replace(/%([0-9A-F]{2})/g, function (match, p1) {\n      var c = String.fromCharCode('0x' + p1);\n      return c === '%' ? '%25' : c;\n    }));\n  };\n\n  var uriToBlob = function uriToBlob(uri) {\n    var byteString = window.atob(uri.split(',')[1]);\n    var mimeString = uri.split(',')[0].split(':')[1].split(';')[0];\n    var buffer = new ArrayBuffer(byteString.length);\n    var intArray = new Uint8Array(buffer);\n    for (var i = 0; i < byteString.length; i++) {\n      intArray[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([buffer], { type: mimeString });\n  };\n\n  var query = function query(el, selector) {\n    if (!selector) return;\n    try {\n      return el.querySelector(selector) || el.parentNode && el.parentNode.querySelector(selector);\n    } catch (err) {\n      console.warn('Invalid CSS selector \"' + selector + '\"', err);\n    }\n  };\n\n  var detectCssFont = function detectCssFont(rule, href) {\n    // Match CSS font-face rules to external links.\n    // @font-face {\n    //   src: local('Abel'), url(https://fonts.gstatic.com/s/abel/v6/UzN-iejR1VoXU2Oc-7LsbvesZW2xOQ-xsNqO47m55DA.woff2);\n    // }\n    var match = rule.cssText.match(urlRegex);\n    var url = match && match[1] || '';\n    if (!url || url.match(/^data:/) || url === 'about:blank') return;\n    var fullUrl = url.startsWith('../') ? href + '/../' + url : url.startsWith('./') ? href + '/.' + url : url;\n    return {\n      text: rule.cssText,\n      format: getFontMimeTypeFromUrl(fullUrl),\n      url: fullUrl\n    };\n  };\n\n  var inlineImages = function inlineImages(el) {\n    return Promise.all(Array.from(el.querySelectorAll('image')).map(function (image) {\n      var href = image.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || image.getAttribute('href');\n      if (!href) return Promise.resolve(null);\n      if (isExternal(href)) {\n        href += (href.indexOf('?') === -1 ? '?' : '&') + 't=' + new Date().valueOf();\n      }\n      return new Promise(function (resolve, reject) {\n        var canvas = document.createElement('canvas');\n        var img = new Image();\n        img.crossOrigin = 'anonymous';\n        img.src = href;\n        img.onerror = function () {\n          return reject(new Error('Could not load ' + href));\n        };\n        img.onload = function () {\n          canvas.width = img.width;\n          canvas.height = img.height;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', canvas.toDataURL('image/png'));\n          resolve(true);\n        };\n      });\n    }));\n  };\n\n  var cachedFonts = {};\n  var inlineFonts = function inlineFonts(fonts) {\n    return Promise.all(fonts.map(function (font) {\n      return new Promise(function (resolve, reject) {\n        if (cachedFonts[font.url]) return resolve(cachedFonts[font.url]);\n\n        var req = new XMLHttpRequest();\n        req.addEventListener('load', function () {\n          // TODO: it may also be worth it to wait until fonts are fully loaded before\n          // attempting to rasterize them. (e.g. use https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet)\n          var fontInBase64 = arrayBufferToBase64(req.response);\n          var fontUri = font.text.replace(urlRegex, 'url(\"data:' + font.format + ';base64,' + fontInBase64 + '\")') + '\\n';\n          cachedFonts[font.url] = fontUri;\n          resolve(fontUri);\n        });\n        req.addEventListener('error', function (e) {\n          console.warn('Failed to load font from: ' + font.url, e);\n          cachedFonts[font.url] = null;\n          resolve(null);\n        });\n        req.addEventListener('abort', function (e) {\n          console.warn('Aborted loading font from: ' + font.url, e);\n          resolve(null);\n        });\n        req.open('GET', font.url);\n        req.responseType = 'arraybuffer';\n        req.send();\n      });\n    })).then(function (fontCss) {\n      return fontCss.filter(function (x) {\n        return x;\n      }).join('');\n    });\n  };\n\n  var cachedRules = null;\n  var styleSheetRules = function styleSheetRules() {\n    if (cachedRules) return cachedRules;\n    return cachedRules = Array.from(document.styleSheets).map(function (sheet) {\n      try {\n        return { rules: sheet.cssRules, href: sheet.href };\n      } catch (e) {\n        console.warn('Stylesheet could not be loaded: ' + sheet.href, e);\n        return {};\n      }\n    });\n  };\n\n  var inlineCss = function inlineCss(el, options) {\n    var _ref = options || {},\n        selectorRemap = _ref.selectorRemap,\n        modifyStyle = _ref.modifyStyle,\n        modifyCss = _ref.modifyCss,\n        fonts = _ref.fonts;\n\n    var generateCss = modifyCss || function (selector, properties) {\n      var sel = selectorRemap ? selectorRemap(selector) : selector;\n      var props = modifyStyle ? modifyStyle(properties) : properties;\n      return sel + '{' + props + '}\\n';\n    };\n    var css = [];\n    var detectFonts = typeof fonts === 'undefined';\n    var fontList = fonts || [];\n    styleSheetRules().forEach(function (_ref2) {\n      var rules = _ref2.rules,\n          href = _ref2.href;\n\n      if (!rules) return;\n      Array.from(rules).forEach(function (rule) {\n        if (typeof rule.style != 'undefined') {\n          if (query(el, rule.selectorText)) css.push(generateCss(rule.selectorText, rule.style.cssText));else if (detectFonts && rule.cssText.match(/^@font-face/)) {\n            var font = detectCssFont(rule, href);\n            if (font) fontList.push(font);\n          } else css.push(rule.cssText);\n        }\n      });\n    });\n\n    return inlineFonts(fontList).then(function (fontCss) {\n      return css.join('\\n') + fontCss;\n    });\n  };\n\n  var downloadOptions = function downloadOptions() {\n    if (!navigator.msSaveOrOpenBlob && !('download' in document.createElement('a'))) {\n      return { popup: window.open() };\n    }\n  };\n\n  out$.prepareSvg = function (el, options, done) {\n    requireDomNode(el);\n\n    var _ref3 = options || {},\n        _ref3$left = _ref3.left,\n        left = _ref3$left === undefined ? 0 : _ref3$left,\n        _ref3$top = _ref3.top,\n        top = _ref3$top === undefined ? 0 : _ref3$top,\n        w = _ref3.width,\n        h = _ref3.height,\n        _ref3$scale = _ref3.scale,\n        scale = _ref3$scale === undefined ? 1 : _ref3$scale,\n        _ref3$responsive = _ref3.responsive,\n        responsive = _ref3$responsive === undefined ? false : _ref3$responsive;\n\n    return inlineImages(el).then(function () {\n      var clone = el.cloneNode(true);\n      clone.style.backgroundColor = (options || {}).backgroundColor || el.style.backgroundColor;\n\n      var _getDimensions = getDimensions(el, clone, w, h),\n          width = _getDimensions.width,\n          height = _getDimensions.height;\n\n      if (el.tagName !== 'svg') {\n        if (el.getBBox) {\n          if (clone.getAttribute('transform') != null) {\n            clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\\(.*?\\)/, ''));\n          }\n          var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n          svg.appendChild(clone);\n          clone = svg;\n        } else {\n          console.error('Attempted to render non-SVG element', el);\n          return;\n        }\n      }\n\n      clone.setAttribute('version', '1.1');\n      clone.setAttribute('viewBox', [left, top, width, height].join(' '));\n      if (!clone.getAttribute('xmlns')) clone.setAttributeNS(xmlNs, 'xmlns', svgNs);\n      if (!clone.getAttribute('xmlns:xlink')) clone.setAttributeNS(xmlNs, 'xmlns:xlink', 'http://www.w3.org/1999/xlink');\n\n      if (responsive) {\n        clone.removeAttribute('width');\n        clone.removeAttribute('height');\n        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n      } else {\n        clone.setAttribute('width', width * scale);\n        clone.setAttribute('height', height * scale);\n      }\n\n      Array.from(clone.querySelectorAll('foreignObject > *')).forEach(function (foreignObject) {\n        foreignObject.setAttributeNS(xmlNs, 'xmlns', foreignObject.tagName === 'svg' ? svgNs : xhtmlNs);\n      });\n\n      return inlineCss(el, options).then(function (css) {\n        var style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.innerHTML = '<![CDATA[\\n' + css + '\\n]]>';\n\n        var defs = document.createElement('defs');\n        defs.appendChild(style);\n        clone.insertBefore(defs, clone.firstChild);\n\n        var outer = document.createElement('div');\n        outer.appendChild(clone);\n        var src = outer.innerHTML.replace(/NS\\d+:href/gi, 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href');\n\n        if (typeof done === 'function') done(src, width, height);else return { src: src, width: width, height: height };\n      });\n    });\n  };\n\n  out$.svgAsDataUri = function (el, options, done) {\n    requireDomNode(el);\n    return out$.prepareSvg(el, options).then(function (_ref4) {\n      var src = _ref4.src,\n          width = _ref4.width,\n          height = _ref4.height;\n\n      var svgXml = 'data:image/svg+xml;base64,' + window.btoa(reEncode(doctype + src));\n      if (typeof done === 'function') {\n        done(svgXml, width, height);\n      }\n      return svgXml;\n    });\n  };\n\n  out$.svgAsPngUri = function (el, options, done) {\n    requireDomNode(el);\n\n    var _ref5 = options || {},\n        _ref5$encoderType = _ref5.encoderType,\n        encoderType = _ref5$encoderType === undefined ? 'image/png' : _ref5$encoderType,\n        _ref5$encoderOptions = _ref5.encoderOptions,\n        encoderOptions = _ref5$encoderOptions === undefined ? 0.8 : _ref5$encoderOptions,\n        canvg = _ref5.canvg;\n\n    var convertToPng = function convertToPng(_ref6) {\n      var src = _ref6.src,\n          width = _ref6.width,\n          height = _ref6.height;\n\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      var pixelRatio = window.devicePixelRatio || 1;\n\n      canvas.width = width * pixelRatio;\n      canvas.height = height * pixelRatio;\n      canvas.style.width = canvas.width + 'px';\n      canvas.style.height = canvas.height + 'px';\n      context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n      if (canvg) canvg(canvas, src);else context.drawImage(src, 0, 0);\n\n      var png = void 0;\n      try {\n        png = canvas.toDataURL(encoderType, encoderOptions);\n      } catch (e) {\n        if (typeof SecurityError !== 'undefined' && e instanceof SecurityError || e.name === 'SecurityError') {\n          console.error('Rendered SVG images cannot be downloaded in this browser.');\n          return;\n        } else throw e;\n      }\n      if (typeof done === 'function') done(png, canvas.width, canvas.height);\n      return Promise.resolve(png);\n    };\n\n    if (canvg) return out$.prepareSvg(el, options).then(convertToPng);else return out$.svgAsDataUri(el, options).then(function (uri) {\n      return new Promise(function (resolve, reject) {\n        var image = new Image();\n        image.onload = function () {\n          return resolve(convertToPng({\n            src: image,\n            width: image.width,\n            height: image.height\n          }));\n        };\n        image.onerror = function () {\n          reject('There was an error loading the data URI as an image on the following SVG\\n' + window.atob(uri.slice(26)) + 'Open the following link to see browser\\'s diagnosis\\n' + uri);\n        };\n        image.src = uri;\n      });\n    });\n  };\n\n  out$.download = function (name, uri, options) {\n    if (navigator.msSaveOrOpenBlob) navigator.msSaveOrOpenBlob(uriToBlob(uri), name);else {\n      var saveLink = document.createElement('a');\n      if ('download' in saveLink) {\n        saveLink.download = name;\n        saveLink.style.display = 'none';\n        document.body.appendChild(saveLink);\n        try {\n          var blob = uriToBlob(uri);\n          var url = URL.createObjectURL(blob);\n          saveLink.href = url;\n          saveLink.onclick = function () {\n            return requestAnimationFrame(function () {\n              return URL.revokeObjectURL(url);\n            });\n          };\n        } catch (e) {\n          console.error(e);\n          console.warn('Error while getting object URL. Falling back to string URL.');\n          saveLink.href = uri;\n        }\n        saveLink.click();\n        document.body.removeChild(saveLink);\n      } else if (options && options.popup) {\n        options.popup.document.title = name;\n        options.popup.location.replace(uri);\n      }\n    }\n  };\n\n  out$.saveSvg = function (el, name, options) {\n    var downloadOpts = downloadOptions(); // don't inline, can't be async\n    return requireDomNodePromise(el).then(function (el) {\n      return out$.svgAsDataUri(el, options || {});\n    }).then(function (uri) {\n      return out$.download(name, uri, downloadOpts);\n    });\n  };\n\n  out$.saveSvgAsPng = function (el, name, options) {\n    var downloadOpts = downloadOptions(); // don't inline, can't be async\n    return requireDomNodePromise(el).then(function (el) {\n      return out$.svgAsPngUri(el, options || {});\n    }).then(function (uri) {\n      return out$.download(name, uri, downloadOpts);\n    });\n  };\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvc2F2ZS1zdmctYXMtcG5nL2xpYi9zYXZlU3ZnQXNQbmcuanM/YmMwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnRUFBYTs7QUFFYjtBQUNBLGFBQWEsS0FBNkIsZUFBZSxLQUE0QixNQUFNO0FBQzNGLE1BQU0sSUFBNkIsRUFBRSxpQ0FBMEIsRUFBRSxtQ0FBRTtBQUNuRTtBQUNBLEdBQUc7QUFBQSxvR0FBQztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhLQUE4SztBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0VBQWdFO0FBQ3JHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxFQUFFO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUUsYUFBYTtBQUM5RSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGdEQUFnRDtBQUNoRCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSwrQ0FBK0M7QUFDL0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zYXZlLXN2Zy1hcy1wbmcvbGliL3NhdmVTdmdBc1BuZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCQgPSB0eXBlb2YgZXhwb3J0cyAhPSAndW5kZWZpbmVkJyAmJiBleHBvcnRzIHx8IHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYge30gfHwgdGhpcyB8fCB3aW5kb3c7XG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJykgZGVmaW5lKCdzYXZlLXN2Zy1hcy1wbmcnLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvdXQkO1xuICB9KTtcbiAgb3V0JC5kZWZhdWx0ID0gb3V0JDtcblxuICB2YXIgeG1sTnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuICB2YXIgeGh0bWxOcyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgdmFyIHN2Z05zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIGRvY3R5cGUgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIHN0YW5kYWxvbmU9XCJub1wiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIiBbPCFFTlRJVFkgbmJzcCBcIiYjMTYwO1wiPl0+JztcbiAgdmFyIHVybFJlZ2V4ID0gL3VybFxcKFtcIiddPyguKz8pW1wiJ10/XFwpLztcbiAgdmFyIGZvbnRGb3JtYXRzID0ge1xuICAgIHdvZmYyOiAnZm9udC93b2ZmMicsXG4gICAgd29mZjogJ2ZvbnQvd29mZicsXG4gICAgb3RmOiAnYXBwbGljYXRpb24veC1mb250LW9wZW50eXBlJyxcbiAgICB0dGY6ICdhcHBsaWNhdGlvbi94LWZvbnQtdHRmJyxcbiAgICBlb3Q6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgc2ZudDogJ2FwcGxpY2F0aW9uL2ZvbnQtc2ZudCcsXG4gICAgc3ZnOiAnaW1hZ2Uvc3ZnK3htbCdcbiAgfTtcblxuICB2YXIgaXNFbGVtZW50ID0gZnVuY3Rpb24gaXNFbGVtZW50KG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBvYmogaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuICB9O1xuICB2YXIgcmVxdWlyZURvbU5vZGUgPSBmdW5jdGlvbiByZXF1aXJlRG9tTm9kZShlbCkge1xuICAgIGlmICghaXNFbGVtZW50KGVsKSkgdGhyb3cgbmV3IEVycm9yKCdhbiBIVE1MRWxlbWVudCBvciBTVkdFbGVtZW50IGlzIHJlcXVpcmVkOyBnb3QgJyArIGVsKTtcbiAgfTtcbiAgdmFyIHJlcXVpcmVEb21Ob2RlUHJvbWlzZSA9IGZ1bmN0aW9uIHJlcXVpcmVEb21Ob2RlUHJvbWlzZShlbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KGVsKSkgcmVzb2x2ZShlbCk7ZWxzZSByZWplY3QobmV3IEVycm9yKCdhbiBIVE1MRWxlbWVudCBvciBTVkdFbGVtZW50IGlzIHJlcXVpcmVkOyBnb3QgJyArIGVsKSk7XG4gICAgfSk7XG4gIH07XG4gIHZhciBpc0V4dGVybmFsID0gZnVuY3Rpb24gaXNFeHRlcm5hbCh1cmwpIHtcbiAgICByZXR1cm4gdXJsICYmIHVybC5sYXN0SW5kZXhPZignaHR0cCcsIDApID09PSAwICYmIHVybC5sYXN0SW5kZXhPZih3aW5kb3cubG9jYXRpb24uaG9zdCkgPT09IC0xO1xuICB9O1xuXG4gIHZhciBnZXRGb250TWltZVR5cGVGcm9tVXJsID0gZnVuY3Rpb24gZ2V0Rm9udE1pbWVUeXBlRnJvbVVybChmb250VXJsKSB7XG4gICAgdmFyIGZvcm1hdHMgPSBPYmplY3Qua2V5cyhmb250Rm9ybWF0cykuZmlsdGVyKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBmb250VXJsLmluZGV4T2YoJy4nICsgZXh0ZW5zaW9uKSA+IDA7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBmb250Rm9ybWF0c1tleHRlbnNpb25dO1xuICAgIH0pO1xuICAgIGlmIChmb3JtYXRzKSByZXR1cm4gZm9ybWF0c1swXTtcbiAgICBjb25zb2xlLmVycm9yKCdVbmtub3duIGZvbnQgZm9ybWF0IGZvciAnICsgZm9udFVybCArICcuIEZvbnRzIG1heSBub3QgYmUgd29ya2luZyBjb3JyZWN0bHkuJyk7XG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICB9O1xuXG4gIHZhciBhcnJheUJ1ZmZlclRvQmFzZTY0ID0gZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICB2YXIgYmluYXJ5ID0gJyc7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1yZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbiAgfTtcblxuICB2YXIgZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uKGVsLCBjbG9uZSwgZGltKSB7XG4gICAgdmFyIHYgPSBlbC52aWV3Qm94ICYmIGVsLnZpZXdCb3guYmFzZVZhbCAmJiBlbC52aWV3Qm94LmJhc2VWYWxbZGltXSB8fCBjbG9uZS5nZXRBdHRyaWJ1dGUoZGltKSAhPT0gbnVsbCAmJiAhY2xvbmUuZ2V0QXR0cmlidXRlKGRpbSkubWF0Y2goLyUkLykgJiYgcGFyc2VJbnQoY2xvbmUuZ2V0QXR0cmlidXRlKGRpbSkpIHx8IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbV0gfHwgcGFyc2VJbnQoY2xvbmUuc3R5bGVbZGltXSkgfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUoZGltKSk7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyB8fCB2ID09PSBudWxsIHx8IGlzTmFOKHBhcnNlRmxvYXQodikpID8gMCA6IHY7XG4gIH07XG5cbiAgdmFyIGdldERpbWVuc2lvbnMgPSBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsLCBjbG9uZSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmIChlbC50YWdOYW1lID09PSAnc3ZnJykgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCB8fCBnZXREaW1lbnNpb24oZWwsIGNsb25lLCAnd2lkdGgnKSxcbiAgICAgIGhlaWdodDogaGVpZ2h0IHx8IGdldERpbWVuc2lvbihlbCwgY2xvbmUsICdoZWlnaHQnKVxuICAgIH07ZWxzZSBpZiAoZWwuZ2V0QkJveCkge1xuICAgICAgdmFyIF9lbCRnZXRCQm94ID0gZWwuZ2V0QkJveCgpLFxuICAgICAgICAgIHggPSBfZWwkZ2V0QkJveC54LFxuICAgICAgICAgIHkgPSBfZWwkZ2V0QkJveC55LFxuICAgICAgICAgIF93aWR0aCA9IF9lbCRnZXRCQm94LndpZHRoLFxuICAgICAgICAgIF9oZWlnaHQgPSBfZWwkZ2V0QkJveC5oZWlnaHQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB4ICsgX3dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHkgKyBfaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVFbmNvZGUgPSBmdW5jdGlvbiByZUVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBwMSkge1xuICAgICAgdmFyIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCcweCcgKyBwMSk7XG4gICAgICByZXR1cm4gYyA9PT0gJyUnID8gJyUyNScgOiBjO1xuICAgIH0pKTtcbiAgfTtcblxuICB2YXIgdXJpVG9CbG9iID0gZnVuY3Rpb24gdXJpVG9CbG9iKHVyaSkge1xuICAgIHZhciBieXRlU3RyaW5nID0gd2luZG93LmF0b2IodXJpLnNwbGl0KCcsJylbMV0pO1xuICAgIHZhciBtaW1lU3RyaW5nID0gdXJpLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRBcnJheVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6IG1pbWVTdHJpbmcgfSk7XG4gIH07XG5cbiAgdmFyIHF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgfHwgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIENTUyBzZWxlY3RvciBcIicgKyBzZWxlY3RvciArICdcIicsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZXRlY3RDc3NGb250ID0gZnVuY3Rpb24gZGV0ZWN0Q3NzRm9udChydWxlLCBocmVmKSB7XG4gICAgLy8gTWF0Y2ggQ1NTIGZvbnQtZmFjZSBydWxlcyB0byBleHRlcm5hbCBsaW5rcy5cbiAgICAvLyBAZm9udC1mYWNlIHtcbiAgICAvLyAgIHNyYzogbG9jYWwoJ0FiZWwnKSwgdXJsKGh0dHBzOi8vZm9udHMuZ3N0YXRpYy5jb20vcy9hYmVsL3Y2L1V6Ti1pZWpSMVZvWFUyT2MtN0xzYnZlc1pXMnhPUS14c05xTzQ3bTU1REEud29mZjIpO1xuICAgIC8vIH1cbiAgICB2YXIgbWF0Y2ggPSBydWxlLmNzc1RleHQubWF0Y2godXJsUmVnZXgpO1xuICAgIHZhciB1cmwgPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICBpZiAoIXVybCB8fCB1cmwubWF0Y2goL15kYXRhOi8pIHx8IHVybCA9PT0gJ2Fib3V0OmJsYW5rJykgcmV0dXJuO1xuICAgIHZhciBmdWxsVXJsID0gdXJsLnN0YXJ0c1dpdGgoJy4uLycpID8gaHJlZiArICcvLi4vJyArIHVybCA6IHVybC5zdGFydHNXaXRoKCcuLycpID8gaHJlZiArICcvLicgKyB1cmwgOiB1cmw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHJ1bGUuY3NzVGV4dCxcbiAgICAgIGZvcm1hdDogZ2V0Rm9udE1pbWVUeXBlRnJvbVVybChmdWxsVXJsKSxcbiAgICAgIHVybDogZnVsbFVybFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGlubGluZUltYWdlcyA9IGZ1bmN0aW9uIGlubGluZUltYWdlcyhlbCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltYWdlJykpLm1hcChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHZhciBocmVmID0gaW1hZ2UuZ2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicpIHx8IGltYWdlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgaWYgKCFocmVmKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgaWYgKGlzRXh0ZXJuYWwoaHJlZikpIHtcbiAgICAgICAgaHJlZiArPSAoaHJlZi5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArICd0PScgKyBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgaW1nLnNyYyA9IGhyZWY7XG4gICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgaHJlZikpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykpO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH07XG5cbiAgdmFyIGNhY2hlZEZvbnRzID0ge307XG4gIHZhciBpbmxpbmVGb250cyA9IGZ1bmN0aW9uIGlubGluZUZvbnRzKGZvbnRzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZvbnRzLm1hcChmdW5jdGlvbiAoZm9udCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKGNhY2hlZEZvbnRzW2ZvbnQudXJsXSkgcmV0dXJuIHJlc29sdmUoY2FjaGVkRm9udHNbZm9udC51cmxdKTtcblxuICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRPRE86IGl0IG1heSBhbHNvIGJlIHdvcnRoIGl0IHRvIHdhaXQgdW50aWwgZm9udHMgYXJlIGZ1bGx5IGxvYWRlZCBiZWZvcmVcbiAgICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHJhc3Rlcml6ZSB0aGVtLiAoZS5nLiB1c2UgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZvbnRGYWNlU2V0KVxuICAgICAgICAgIHZhciBmb250SW5CYXNlNjQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KHJlcS5yZXNwb25zZSk7XG4gICAgICAgICAgdmFyIGZvbnRVcmkgPSBmb250LnRleHQucmVwbGFjZSh1cmxSZWdleCwgJ3VybChcImRhdGE6JyArIGZvbnQuZm9ybWF0ICsgJztiYXNlNjQsJyArIGZvbnRJbkJhc2U2NCArICdcIiknKSArICdcXG4nO1xuICAgICAgICAgIGNhY2hlZEZvbnRzW2ZvbnQudXJsXSA9IGZvbnRVcmk7XG4gICAgICAgICAgcmVzb2x2ZShmb250VXJpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBmb250IGZyb206ICcgKyBmb250LnVybCwgZSk7XG4gICAgICAgICAgY2FjaGVkRm9udHNbZm9udC51cmxdID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Fib3J0ZWQgbG9hZGluZyBmb250IGZyb206ICcgKyBmb250LnVybCwgZSk7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vcGVuKCdHRVQnLCBmb250LnVybCk7XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgfSk7XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKGZvbnRDc3MpIHtcbiAgICAgIHJldHVybiBmb250Q3NzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjYWNoZWRSdWxlcyA9IG51bGw7XG4gIHZhciBzdHlsZVNoZWV0UnVsZXMgPSBmdW5jdGlvbiBzdHlsZVNoZWV0UnVsZXMoKSB7XG4gICAgaWYgKGNhY2hlZFJ1bGVzKSByZXR1cm4gY2FjaGVkUnVsZXM7XG4gICAgcmV0dXJuIGNhY2hlZFJ1bGVzID0gQXJyYXkuZnJvbShkb2N1bWVudC5zdHlsZVNoZWV0cykubWFwKGZ1bmN0aW9uIChzaGVldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgcnVsZXM6IHNoZWV0LmNzc1J1bGVzLCBocmVmOiBzaGVldC5ocmVmIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU3R5bGVzaGVldCBjb3VsZCBub3QgYmUgbG9hZGVkOiAnICsgc2hlZXQuaHJlZiwgZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgaW5saW5lQ3NzID0gZnVuY3Rpb24gaW5saW5lQ3NzKGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBzZWxlY3RvclJlbWFwID0gX3JlZi5zZWxlY3RvclJlbWFwLFxuICAgICAgICBtb2RpZnlTdHlsZSA9IF9yZWYubW9kaWZ5U3R5bGUsXG4gICAgICAgIG1vZGlmeUNzcyA9IF9yZWYubW9kaWZ5Q3NzLFxuICAgICAgICBmb250cyA9IF9yZWYuZm9udHM7XG5cbiAgICB2YXIgZ2VuZXJhdGVDc3MgPSBtb2RpZnlDc3MgfHwgZnVuY3Rpb24gKHNlbGVjdG9yLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgc2VsID0gc2VsZWN0b3JSZW1hcCA/IHNlbGVjdG9yUmVtYXAoc2VsZWN0b3IpIDogc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBtb2RpZnlTdHlsZSA/IG1vZGlmeVN0eWxlKHByb3BlcnRpZXMpIDogcHJvcGVydGllcztcbiAgICAgIHJldHVybiBzZWwgKyAneycgKyBwcm9wcyArICd9XFxuJztcbiAgICB9O1xuICAgIHZhciBjc3MgPSBbXTtcbiAgICB2YXIgZGV0ZWN0Rm9udHMgPSB0eXBlb2YgZm9udHMgPT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBmb250TGlzdCA9IGZvbnRzIHx8IFtdO1xuICAgIHN0eWxlU2hlZXRSdWxlcygpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgcnVsZXMgPSBfcmVmMi5ydWxlcyxcbiAgICAgICAgICBocmVmID0gX3JlZjIuaHJlZjtcblxuICAgICAgaWYgKCFydWxlcykgcmV0dXJuO1xuICAgICAgQXJyYXkuZnJvbShydWxlcykuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUuc3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAocXVlcnkoZWwsIHJ1bGUuc2VsZWN0b3JUZXh0KSkgY3NzLnB1c2goZ2VuZXJhdGVDc3MocnVsZS5zZWxlY3RvclRleHQsIHJ1bGUuc3R5bGUuY3NzVGV4dCkpO2Vsc2UgaWYgKGRldGVjdEZvbnRzICYmIHJ1bGUuY3NzVGV4dC5tYXRjaCgvXkBmb250LWZhY2UvKSkge1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBkZXRlY3RDc3NGb250KHJ1bGUsIGhyZWYpO1xuICAgICAgICAgICAgaWYgKGZvbnQpIGZvbnRMaXN0LnB1c2goZm9udCk7XG4gICAgICAgICAgfSBlbHNlIGNzcy5wdXNoKHJ1bGUuY3NzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlubGluZUZvbnRzKGZvbnRMaXN0KS50aGVuKGZ1bmN0aW9uIChmb250Q3NzKSB7XG4gICAgICByZXR1cm4gY3NzLmpvaW4oJ1xcbicpICsgZm9udENzcztcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZG93bmxvYWRPcHRpb25zID0gZnVuY3Rpb24gZG93bmxvYWRPcHRpb25zKCkge1xuICAgIGlmICghbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IgJiYgISgnZG93bmxvYWQnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSkpIHtcbiAgICAgIHJldHVybiB7IHBvcHVwOiB3aW5kb3cub3BlbigpIH07XG4gICAgfVxuICB9O1xuXG4gIG91dCQucHJlcGFyZVN2ZyA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgZG9uZSkge1xuICAgIHJlcXVpcmVEb21Ob2RlKGVsKTtcblxuICAgIHZhciBfcmVmMyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgIF9yZWYzJGxlZnQgPSBfcmVmMy5sZWZ0LFxuICAgICAgICBsZWZ0ID0gX3JlZjMkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYzJGxlZnQsXG4gICAgICAgIF9yZWYzJHRvcCA9IF9yZWYzLnRvcCxcbiAgICAgICAgdG9wID0gX3JlZjMkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkdG9wLFxuICAgICAgICB3ID0gX3JlZjMud2lkdGgsXG4gICAgICAgIGggPSBfcmVmMy5oZWlnaHQsXG4gICAgICAgIF9yZWYzJHNjYWxlID0gX3JlZjMuc2NhbGUsXG4gICAgICAgIHNjYWxlID0gX3JlZjMkc2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmMyRzY2FsZSxcbiAgICAgICAgX3JlZjMkcmVzcG9uc2l2ZSA9IF9yZWYzLnJlc3BvbnNpdmUsXG4gICAgICAgIHJlc3BvbnNpdmUgPSBfcmVmMyRyZXNwb25zaXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYzJHJlc3BvbnNpdmU7XG5cbiAgICByZXR1cm4gaW5saW5lSW1hZ2VzKGVsKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGNsb25lLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IChvcHRpb25zIHx8IHt9KS5iYWNrZ3JvdW5kQ29sb3IgfHwgZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICB2YXIgX2dldERpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKGVsLCBjbG9uZSwgdywgaCksXG4gICAgICAgICAgd2lkdGggPSBfZ2V0RGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0RGltZW5zaW9ucy5oZWlnaHQ7XG5cbiAgICAgIGlmIChlbC50YWdOYW1lICE9PSAnc3ZnJykge1xuICAgICAgICBpZiAoZWwuZ2V0QkJveCkge1xuICAgICAgICAgIGlmIChjbG9uZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgY2xvbmUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKC90cmFuc2xhdGVcXCguKj9cXCkvLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgIGNsb25lID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byByZW5kZXIgbm9uLVNWRyBlbGVtZW50JywgZWwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCAnMS4xJyk7XG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0XS5qb2luKCcgJykpO1xuICAgICAgaWYgKCFjbG9uZS5nZXRBdHRyaWJ1dGUoJ3htbG5zJykpIGNsb25lLnNldEF0dHJpYnV0ZU5TKHhtbE5zLCAneG1sbnMnLCBzdmdOcyk7XG4gICAgICBpZiAoIWNsb25lLmdldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnKSkgY2xvbmUuc2V0QXR0cmlidXRlTlMoeG1sTnMsICd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG5cbiAgICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICAgIGNsb25lLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgY2xvbmUucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaW5ZTWluIG1lZXQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3aWR0aCAqIHNjYWxlKTtcbiAgICAgICAgY2xvbmUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQgKiBzY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIEFycmF5LmZyb20oY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnZm9yZWlnbk9iamVjdCA+IConKSkuZm9yRWFjaChmdW5jdGlvbiAoZm9yZWlnbk9iamVjdCkge1xuICAgICAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKHhtbE5zLCAneG1sbnMnLCBmb3JlaWduT2JqZWN0LnRhZ05hbWUgPT09ICdzdmcnID8gc3ZnTnMgOiB4aHRtbE5zKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaW5saW5lQ3NzKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChjc3MpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgIHN0eWxlLmlubmVySFRNTCA9ICc8IVtDREFUQVtcXG4nICsgY3NzICsgJ1xcbl1dPic7XG5cbiAgICAgICAgdmFyIGRlZnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkZWZzJyk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICBjbG9uZS5pbnNlcnRCZWZvcmUoZGVmcywgY2xvbmUuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG91dGVyLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgdmFyIHNyYyA9IG91dGVyLmlubmVySFRNTC5yZXBsYWNlKC9OU1xcZCs6aHJlZi9naSwgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhsaW5rOmhyZWYnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGRvbmUgPT09ICdmdW5jdGlvbicpIGRvbmUoc3JjLCB3aWR0aCwgaGVpZ2h0KTtlbHNlIHJldHVybiB7IHNyYzogc3JjLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBvdXQkLnN2Z0FzRGF0YVVyaSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgZG9uZSkge1xuICAgIHJlcXVpcmVEb21Ob2RlKGVsKTtcbiAgICByZXR1cm4gb3V0JC5wcmVwYXJlU3ZnKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgdmFyIHNyYyA9IF9yZWY0LnNyYyxcbiAgICAgICAgICB3aWR0aCA9IF9yZWY0LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWY0LmhlaWdodDtcblxuICAgICAgdmFyIHN2Z1htbCA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCcgKyB3aW5kb3cuYnRvYShyZUVuY29kZShkb2N0eXBlICsgc3JjKSk7XG4gICAgICBpZiAodHlwZW9mIGRvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9uZShzdmdYbWwsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1htbDtcbiAgICB9KTtcbiAgfTtcblxuICBvdXQkLnN2Z0FzUG5nVXJpID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zLCBkb25lKSB7XG4gICAgcmVxdWlyZURvbU5vZGUoZWwpO1xuXG4gICAgdmFyIF9yZWY1ID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgX3JlZjUkZW5jb2RlclR5cGUgPSBfcmVmNS5lbmNvZGVyVHlwZSxcbiAgICAgICAgZW5jb2RlclR5cGUgPSBfcmVmNSRlbmNvZGVyVHlwZSA9PT0gdW5kZWZpbmVkID8gJ2ltYWdlL3BuZycgOiBfcmVmNSRlbmNvZGVyVHlwZSxcbiAgICAgICAgX3JlZjUkZW5jb2Rlck9wdGlvbnMgPSBfcmVmNS5lbmNvZGVyT3B0aW9ucyxcbiAgICAgICAgZW5jb2Rlck9wdGlvbnMgPSBfcmVmNSRlbmNvZGVyT3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gMC44IDogX3JlZjUkZW5jb2Rlck9wdGlvbnMsXG4gICAgICAgIGNhbnZnID0gX3JlZjUuY2Fudmc7XG5cbiAgICB2YXIgY29udmVydFRvUG5nID0gZnVuY3Rpb24gY29udmVydFRvUG5nKF9yZWY2KSB7XG4gICAgICB2YXIgc3JjID0gX3JlZjYuc3JjLFxuICAgICAgICAgIHdpZHRoID0gX3JlZjYud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0O1xuXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCArICdweCc7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcblxuICAgICAgaWYgKGNhbnZnKSBjYW52ZyhjYW52YXMsIHNyYyk7ZWxzZSBjb250ZXh0LmRyYXdJbWFnZShzcmMsIDAsIDApO1xuXG4gICAgICB2YXIgcG5nID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcG5nID0gY2FudmFzLnRvRGF0YVVSTChlbmNvZGVyVHlwZSwgZW5jb2Rlck9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIFNlY3VyaXR5RXJyb3IgIT09ICd1bmRlZmluZWQnICYmIGUgaW5zdGFuY2VvZiBTZWN1cml0eUVycm9yIHx8IGUubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUmVuZGVyZWQgU1ZHIGltYWdlcyBjYW5ub3QgYmUgZG93bmxvYWRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZG9uZSA9PT0gJ2Z1bmN0aW9uJykgZG9uZShwbmcsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBuZyk7XG4gICAgfTtcblxuICAgIGlmIChjYW52ZykgcmV0dXJuIG91dCQucHJlcGFyZVN2ZyhlbCwgb3B0aW9ucykudGhlbihjb252ZXJ0VG9QbmcpO2Vsc2UgcmV0dXJuIG91dCQuc3ZnQXNEYXRhVXJpKGVsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29udmVydFRvUG5nKHtcbiAgICAgICAgICAgIHNyYzogaW1hZ2UsXG4gICAgICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGltYWdlLmhlaWdodFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoJ1RoZXJlIHdhcyBhbiBlcnJvciBsb2FkaW5nIHRoZSBkYXRhIFVSSSBhcyBhbiBpbWFnZSBvbiB0aGUgZm9sbG93aW5nIFNWR1xcbicgKyB3aW5kb3cuYXRvYih1cmkuc2xpY2UoMjYpKSArICdPcGVuIHRoZSBmb2xsb3dpbmcgbGluayB0byBzZWUgYnJvd3NlclxcJ3MgZGlhZ25vc2lzXFxuJyArIHVyaSk7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLnNyYyA9IHVyaTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIG91dCQuZG93bmxvYWQgPSBmdW5jdGlvbiAobmFtZSwgdXJpLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYih1cmlUb0Jsb2IodXJpKSwgbmFtZSk7ZWxzZSB7XG4gICAgICB2YXIgc2F2ZUxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBpZiAoJ2Rvd25sb2FkJyBpbiBzYXZlTGluaykge1xuICAgICAgICBzYXZlTGluay5kb3dubG9hZCA9IG5hbWU7XG4gICAgICAgIHNhdmVMaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2F2ZUxpbmspO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBibG9iID0gdXJpVG9CbG9iKHVyaSk7XG4gICAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgc2F2ZUxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgICBzYXZlTGluay5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHdoaWxlIGdldHRpbmcgb2JqZWN0IFVSTC4gRmFsbGluZyBiYWNrIHRvIHN0cmluZyBVUkwuJyk7XG4gICAgICAgICAgc2F2ZUxpbmsuaHJlZiA9IHVyaTtcbiAgICAgICAgfVxuICAgICAgICBzYXZlTGluay5jbGljaygpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNhdmVMaW5rKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBvcHVwKSB7XG4gICAgICAgIG9wdGlvbnMucG9wdXAuZG9jdW1lbnQudGl0bGUgPSBuYW1lO1xuICAgICAgICBvcHRpb25zLnBvcHVwLmxvY2F0aW9uLnJlcGxhY2UodXJpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb3V0JC5zYXZlU3ZnID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvd25sb2FkT3B0cyA9IGRvd25sb2FkT3B0aW9ucygpOyAvLyBkb24ndCBpbmxpbmUsIGNhbid0IGJlIGFzeW5jXG4gICAgcmV0dXJuIHJlcXVpcmVEb21Ob2RlUHJvbWlzZShlbCkudGhlbihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBvdXQkLnN2Z0FzRGF0YVVyaShlbCwgb3B0aW9ucyB8fCB7fSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodXJpKSB7XG4gICAgICByZXR1cm4gb3V0JC5kb3dubG9hZChuYW1lLCB1cmksIGRvd25sb2FkT3B0cyk7XG4gICAgfSk7XG4gIH07XG5cbiAgb3V0JC5zYXZlU3ZnQXNQbmcgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG93bmxvYWRPcHRzID0gZG93bmxvYWRPcHRpb25zKCk7IC8vIGRvbid0IGlubGluZSwgY2FuJ3QgYmUgYXN5bmNcbiAgICByZXR1cm4gcmVxdWlyZURvbU5vZGVQcm9taXNlKGVsKS50aGVuKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIG91dCQuc3ZnQXNQbmdVcmkoZWwsIG9wdGlvbnMgfHwge30pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVyaSkge1xuICAgICAgcmV0dXJuIG91dCQuZG93bmxvYWQobmFtZSwgdXJpLCBkb3dubG9hZE9wdHMpO1xuICAgIH0pO1xuICB9O1xufSkoKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/save-svg-as-png/lib/saveSvgAsPng.js\n"
          );

          /***/
        },

      /***/ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js':
        /*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
        /*! no static exports found */
        /***/ function(module, exports, __webpack_require__) {
          'use strict';
          eval(
            "\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBOztBQUVBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxTQUFJOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQsR0FBRzs7QUFFSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDOztBQUVBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucykge1xuICB2YXIgc3R5bGVzID0gW107XG4gIHZhciBuZXdTdHlsZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNzcyA9IGl0ZW1bMV07XG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXTtcbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXTtcbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9O1xuXG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHBhcnRzOiBbcGFydF1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG4gICAgdmFyIGogPSAwO1xuXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKys7XG5cbiAgICAgIGZvciAoOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmF0dHJpYnV0ZXMgOiB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuICAgICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICAgIGRvbVN0eWxlLnJlZnMtLTtcbiAgICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICB2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgYWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbWF5UmVtb3ZlLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kb21TdHlsZSA9IG1heVJlbW92ZVtfaV07XG5cbiAgICAgIGlmIChfZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9kb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIF9kb21TdHlsZS5wYXJ0c1tqXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW19kb21TdHlsZS5pZF07XG4gICAgICB9XG4gICAgfVxuICB9O1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n"
          );

          /***/
        },

      /***/ './src/SplitStream.js':
        /*!****************************!*\
  !*** ./src/SplitStream.js ***!
  \****************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStream; });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"d3\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../libs/d3svgfilters/src/d3-svg-filters.js */ \"./libs/d3svgfilters/src/d3-svg-filters.js\");\n/* harmony import */ var _libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_libs_d3svgfilters_src_d3_svg_filters_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SplitStreamInputData.js */ \"./src/SplitStreamInputData.js\");\n/* harmony import */ var _SplitStreamFilter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SplitStreamFilter.js */ \"./src/SplitStreamFilter.js\");\n/* harmony import */ var _SplitStreamData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SplitStreamData.js */ \"./src/SplitStreamData.js\");\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functions.js */ \"./src/functions.js\");\n/* harmony import */ var _css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../css/SplitStream.css */ \"./css/SplitStream.css\");\n/* harmony import */ var _css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_css_SplitStream_css__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\n\nclass SplitStream {\n  constructor(container, opts = {}) {\n    this._opts = {\n      axes: [\n        // {\n        //   position: 'left',\n        //   ticks: 10,\n        //   subticks: 2,\n        //   size: 30\n        // },\n        {\n          position: 'bottom',\n          ticks: 5,\n          tickSize: 'full',\n          textPos: [0, 0],\n          textSize: '2em',\n          textAnchor: 'middle',\n          textBase: 'none' // dominant-baseline\n        }\n      ],\n      transparentRoot: false,\n      margin: { top: 20, right: 20, bottom: 20, left: 20 },\n      height: container.clientHeight,\n      width: container.clientWidth,\n      automaticUpdate: true,\n      minSizeThreshold: 0,\n      //separationXMethod: \"\",\n      xMargin: 0,\n      //separationYMethod: \"\",\n      yMargin: 0,\n      yPadding: 0,\n      zoomTimeFactor: 1,\n      unifySize: false,\n      unifyPosition: false,\n      drawStroke: false,\n      showLabels: false,\n      mirror: false,\n      splitRoot: false,\n      shapeRendering: 'geometricPrecision',\n      offset: 'silhouette', // zero, expand, silhouette,\n      filterMode: 'fast',\n\n      ...opts // overwrite default settings with user settings\n    };\n\n    this._name = container.id;\n    this._container = container;\n    this._data;\n    this._zoomContainer;\n    this._axesContainer;\n    this._pathContainer;\n    this._textContainer;\n    this._svg;\n    this._svgFilters;\n    this._filters;\n    this._datasetsLoaded = 0;\n\n    this._streamData = new _SplitStreamData_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n    this._minTime;\n    this._maxTime;\n    this._maxValue;\n    this._maxDepth;\n    this._indices = {};\n\n    this._xSpacing = this.xSpacingFixed;\n    this._ySpacing = this.ySpacingFixed;\n\n    this._onMouseOver;\n    this._onMouseOut;\n\n    this._color = d3__WEBPACK_IMPORTED_MODULE_0__[\"scaleSequential\"](d3__WEBPACK_IMPORTED_MODULE_0__[\"interpolateBlues\"]);\n    this._colorRandom = false;\n\n    this._init();\n  }\n\n  static get a() { }\n\n  data(d) {\n    return d == null ? this._data : (this._setData(d), this);\n  }\n\n  filters(d) {\n    return d == null ? this._filters : (this._setFilters(d), this);\n  }\n\n  options(opts) {\n    Object.assign(this._opts, opts);\n  }\n\n  set automaticUpdate(auto) {\n    this._opts.automaticUpdate = auto;\n  }\n  set transparentRoot(transparent) {\n    this._opts.transparentRoot = transparent;\n    this._render();\n  }\n  set unifySize(unify) {\n    this._opts.unifySize = unify;\n    this._update();\n  }\n  set yPadding(value) {\n    this._opts.yPadding = +value;\n    this._update();\n  }\n  set unifyPosition(unify) {\n    this._opts.unifyPosition = unify;\n    this._update();\n  }\n  set mirror(mirror) {\n    this._opts.mirror = mirror;\n    this._update();\n  }\n  set splitRoot(splitRoot) {\n    this._opts.splitRoot = splitRoot;\n    this._update();\n  }\n  set minSizeThreshold(threshold) {\n    this._opts.minSizeThreshold = +threshold / 100;\n    this._update();\n  }\n  set zoomTime(factor) {\n    this._opts.zoomTimeFactor = +factor;\n    this._update();\n  }\n  set offset(offset) {\n    this._opts.offset = offset;\n    this._update();\n  }\n  set xMargin(value) {\n    this._opts.xMargin = +value;\n    this._update();\n  }\n  set yMargin(value) {\n    this._opts.yMargin = +value;\n    this._update();\n  }\n  set shapeRendering(rendering) {\n    this._opts.shapeRendering = rendering;\n    this.render();\n  }\n  set filterMode(mode) {\n    if (mode != this._opts.filterMode) {\n      d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('.depthLayer').clearFilter();\n      d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('path.stream').clearFilter();\n    }\n    this._opts.filterMode = mode;\n    this._applyFilters();\n  }\n\n  set showLabels(value) {\n    this._opts.showLabels = value;\n    this.render();\n  }\n  set color(colorFunction) {\n    this._color = colorFunction;\n    this.render();\n  }\n  set colorRandom(random) {\n    this._colorRandom = random;\n    this.render();\n  }\n  set proportion(value) {\n    this._streamData.proportion = this._opts.proportion = +value;\n    this._update();\n  }\n  set startEndEncoding(encoding) {\n    this._streamData.startEndEncoding = encoding;\n    this._update();\n  }\n  set startEndEncodingX(x) {\n    this._streamData.startEndEncodingX = x;\n    this._update();\n  }\n  set startEndEncodingY(y) {\n    this._streamData.startEndEncodingY = y;\n    this._update();\n  }\n  set xSpacing(callback) {\n    this._xSpacing = callback;\n    this._update();\n  }\n  set ySpacing(callback) {\n    this._ySpacing = callback;\n    this._update();\n  }\n\n  set onMouseOver(callback) {\n    this._onMouseOver = callback;\n    this.render();\n  }\n\n  set onMouseOut(callback) {\n    this._onMouseOut = callback;\n    this.render();\n  }\n\n  get splits() {\n    this._streamData.splits;\n  }\n\n  // expects SplitStreamInputData as input\n  _setData(d) {\n    if (!(d instanceof _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] || d instanceof _SplitStreamFilter_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]))\n      console.error(\n        'Added data is not an instance of SplitStreamData or SplitStreamFilter'\n      );\n\n    this._datasetsLoaded++;\n    this._data = d.data;\n    this._update();\n  }\n\n  _setFilters(d) {\n    if (!d || typeof d !== 'object')\n      return console.log(`ERROR: Added data \"${d}\" is not an object.`);\n    this._filters = d;\n    this._applyFilters();\n  }\n\n  _init() {\n    const { margin } = this._opts;\n    this._svg = d3__WEBPACK_IMPORTED_MODULE_0__[\"select\"](this._container)\n      .append('svg')\n      .classed('secstream', 'true')\n      .attr('height', this._container.clientHeight)\n      .attr('width', this._container.clientWidth)\n      .call(\n        d3__WEBPACK_IMPORTED_MODULE_0__[\"zoom\"]().on('zoom', () => {\n          this._zoomContainer.attr('transform', d3__WEBPACK_IMPORTED_MODULE_0__[\"event\"].transform);\n        })\n      );\n    //.on(\"contextmenu\", () => d3.event.preventDefault());\n    //.append('g')\n    //\t.attr('id', 'svg-drawn')\n    //.attr('transform', \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    this._svgFilters = this._svg.append('defs');\n    this._zoomContainer = this._svg.append('g').classed('zoom', true);\n    this._axesContainer = this._zoomContainer\n      .append('g')\n      .classed('axisContainer', true);\n    this._pathContainer = this._zoomContainer\n      .append('g')\n      .classed('pathContainer', true);\n    this._textContainer = this._zoomContainer\n      .append('g')\n      .classed('textContainer', true);\n    this._tooltipContainer = this._zoomContainer\n      .append('g')\n      .classed('tooltipContainer', true);\n  }\n\n  _applyOrdering() {\n    // change the order of siblings in the data for less edge crossings\n    // TEST: RANDOM ORDER OF LEAF NODES\n  }\n\n  // returns true if node id did not exist before\n  _findStreamId(node) {\n    if (!!node.prev) {\n      // use id of prev node\n      let idx = node.prev.findIndex(prev => prev.id == node.id);\n      if (idx == -1) idx = 0;\n      node.streamId = node.prev[idx].streamId;\n      return false;\n    } else {\n      // new node\n      // check if id is already in use\n      if (!this._indices[node.id]) {\n        // if not, use this id for the stream\n        this._indices[node.id] = true;\n        node.streamId = node.id;\n      } else {\n        // find a new ID\n        let count = 0;\n        let id;\n        do {\n          count++;\n          id = node.id + '_' + count;\n        } while (!!this._indices[id]);\n        // console.log(`ID '${node.id}' is already in use. Use '${id}' instead.`);\n        // ID is now in use\n        this._indices[id] = true;\n        node.streamId = id;\n      }\n      return true;\n    }\n  }\n\n  _clearStreamIds() {\n    this._streamData.clear();\n    this._indices = {};\n  }\n\n  _normalizeData() {\n    // we add a padding and therefore need to recalculate the aggregate of each node\n    // if a node's size is bigger than its aggregate, it will use the aggregate as size\n    // TODO: padding interferes with positions\n    // TODO: padded aggregate can probably be calculated from the size of the subtree\n    let checkSizes = node => {\n      if (!!node.children) {\n        let aggregate = 0;\n        for (let child of node.children) {\n          checkSizes(child);\n          aggregate += child.size;\n        }\n        if (aggregate > node.dataSize || this._opts.unifySize)\n          node.size = aggregate;\n        else node.size = node.dataSize;\n\n        let padding = (node.children.length + 1) * this._opts.yPadding; // * (1 / (node.depth + 1));\n        node.size += padding;\n      } else\n        node.size = this._opts.unifySize\n          ? 1\n          : node.dataSize + this._opts.yPadding;\n    };\n\n    // TODO: This version is better with positions but doesn't work properly in general\n    // let checkSizes = node => {\n    //   if (!!node.children) {\n    //     let aggregate = 0;\n    //     for (let child of node.children) {\n    //       checkSizes(child);\n    //       aggregate += child.size;\n    //     }\n    //     let dataSize = node.dataSize + this._opts.yPadding;\n    //     if (aggregate > dataSize || this._opts.unifySize)\n    //       node.size = aggregate + this._opts.yPadding;\n    //     else node.size = dataSize;\n    //   } else node.size = this._opts.unifySize ? 1 : node.dataSize;\n    // };\n\n    // if nodes don't have a set position, spread them out equally\n    // positions must be unified, if sizes are unified\n    let checkPositions = (node, pos = 0) => {\n      if (\n        this._opts.unifySize ||\n        this._opts.unifyPosition ||\n        Number.isNaN(node.dataPos) ||\n        node.dataPos == null\n        // !node.dataPos\n        // (!!node.parent && node.parent.id == 'fakeRoot')\n      )\n        node.pos = pos;\n      else node.pos = node.dataPos;\n\n      if (!!node.children && node.children.length > 0) {\n        let aggregate = 0;\n        for (let child of node.children) {\n          aggregate += child.size;\n        }\n        let spacing = (node.size - aggregate) / (node.children.length + 1);\n\n        for (let [i, child] of node.children.entries()) {\n          pos += spacing;\n          checkPositions(child, pos);\n          pos += child.size;\n        }\n      }\n    };\n\n    this._clearStreamIds();\n    let time = this._data.timesteps;\n    this._maxValue = 0;\n    this._maxTime = 0;\n    this._minTime = Infinity;\n    for (let t in time) {\n      checkSizes(time[t].tree);\n      checkPositions(time[t].tree);\n      this._maxValue = Math.max(this._maxValue, time[t].tree.size);\n      this._minTime = Math.min(this._minTime, +t);\n      this._maxTime = Math.max(this._maxTime, +t);\n    }\n\n    this._maxDepth = 0;\n    let traverse = (node, depth) => {\n      this._maxDepth = Math.max(this._maxDepth, depth);\n      node.depth = depth++;\n      let isNew = this._findStreamId(node);\n      if (isNew) this._streamData.add(node);\n\n      if (!!node.children)\n        node.children.forEach(child => traverse(child, depth));\n    };\n\n    for (let i in time) traverse(time[i].tree, 0);\n  }\n\n  _calculatePositions() {\n    let { minSizeThreshold, offset } = this._opts;\n\n    let setOffset = root => {\n      if (offset == 'zero') {\n        root.y0 = 0;\n        root.y1 = root.size / this._maxValue;\n      } else if (offset == 'expand') {\n        root.y0 = 0;\n        root.y1 = 1;\n      } else if (offset == 'silhouette') {\n        root.y0 = 0.5 - (0.5 * root.size) / this._maxValue;\n        root.y1 = 0.5 + (0.5 * root.size) / this._maxValue;\n      }\n    };\n\n    let traverse = (node, childX = 0) => {\n      let p = node.parent;\n      if (!p) {\n        node.marginX = this._opts.splitRoot ? this._xSpacing(node) : 0;\n      } else {\n        let space = p.y1 - p.y0 - (p.children.length + 1) * p.marginY;\n        // if the parent is too small, draw children as a zero line in the center of the parent stream\n        if (space <= 0) {\n          node.y0 = 0.5 * (p.y0 + p.y1);\n          node.y1 = 0.5 * (p.y0 + p.y1);\n        } else {\n          // normalize\n          node.rpos = (node.pos - p.pos) / p.size;\n          node.rsize = node.size / p.size;\n          node.y0 = p.y0 + (childX + 1) * p.marginY + space * node.rpos;\n          node.y1 = node.y0 + space * node.rsize;\n\n          // if a node is too small, draw it as a zero line\n          let size = node.y1 - node.y0;\n          if (size <= minSizeThreshold) {\n            node.y0 = 0.5 * (node.y0 + node.y1);\n            node.y1 = 0.5 * (node.y0 + node.y1);\n          }\n        }\n\n        node.marginX = p.marginX + this._xSpacing(node);\n      }\n\n      node.marginY = this._ySpacing(node);\n\n      if (!!node.children)\n        node.children.forEach((child, i) => traverse(child, i));\n    };\n\n    let time = this._data.timesteps;\n    for (let i in time) {\n      setOffset(time[i].tree);\n      traverse(time[i].tree);\n    }\n\n    this._setScales();\n  }\n\n  _setScales() {\n    let { height, width, margin, mirror, zoomTimeFactor } = this._opts;\n    // treemaps require 0.5 space on the time axis to the left and right of each timestep\n    this._streamData.xScale = d3__WEBPACK_IMPORTED_MODULE_0__[\"scaleLinear\"]()\n      .domain([this._minTime - 0.5, this._maxTime + 0.5])\n      // .domain([\n      //   this._minTime - 0.5 * (1 - this._opts.proportion),\n      //   this._maxTime + 0.5 * (1 - this._opts.proportion)\n      // ])\n      .range([margin.left, width * zoomTimeFactor - margin.right]);\n\n    let domain = mirror ? [1, 0] : [0, 1];\n    this._streamData.yScale = d3__WEBPACK_IMPORTED_MODULE_0__[\"scaleLinear\"]()\n      .domain(domain)\n      .nice()\n      .range([height - margin.bottom, margin.top]);\n    //.range(margin.top, height - margin.bottom);\n\n    this._drawAxes();\n  }\n\n  setRootNodeById(Id) {\n    let root = this._streamData.streams.find(d => d.id == id);\n  }\n\n  render() {\n    let minColoredDepth = this._opts.transparentRoot ? 1 : 0;\n    let color = this._colorRandom\n      ? _functions_js__WEBPACK_IMPORTED_MODULE_5__[\"getRandomColor\"]\n      : this._color.domain([this._maxDepth, minColoredDepth]);\n\n    let streamsByDepth = d3__WEBPACK_IMPORTED_MODULE_0__[\"nest\"]()\n      .key(d => d.deepestDepth)\n      .entries(this._streamData.streams);\n\n    // add depth groups\n    let depthLayers = this._pathContainer\n      .selectAll('g.depthLayer > g.clipLayer')\n      .data(streamsByDepth, d => d.key)\n      .join(\n        enter =>\n          enter\n            .append('g')\n            .attr('class', d => 'depthLayer depth-' + d.key)\n            .append('g')\n            .classed('clipLayer', true),\n        update => update,\n        exit => exit.remove()\n      );\n\n    let streamLayers = depthLayers\n      .selectAll('g.streamLayer')\n      .data(d => d.values, d => d.id)\n      .join(\n        enter => enter.append('g').classed('streamLayer', true),\n        update => update,\n        exit => exit.remove()\n      );\n\n    // add streams\n    let self = this;\n    streamLayers\n      .selectAll('path.stream')\n      .data(d => [d])\n      .join(\n        function (enter) {\n          return (\n            enter\n              .append('path')\n              .classed('stream', true)\n              .on('mouseover', self._onMouseOver)\n              .on('mouseout', self._onMouseOut)\n              .attr('clip-path', d => 'url(#clip' + d.id + self._name + ')')\n              .attr('id', d => 'stream' + d.id + self._name)\n              //.attr('stroke-width', 3)\n              .attr('paint-order', 'stroke')\n          );\n        },\n        update => update,\n        exit => exit.remove()\n      )\n      .attr('d', d => d.path)\n      .attr('shape-rendering', this._opts.shapeRendering)\n      .attr(\n        'fill',\n        d => (!!d.data ? d.data.color : null) || color(d.deepestDepth)\n        // 'white'\n      )\n      .attr(\n        'fill-opacity',\n        this._opts.transparentRoot ? d => (d.id == 'fakeRoot' ? 0 : 1) : 1\n      )\n      // remove empty streams (they do not include a single bezier curve)\n      .filter(d => d.path.indexOf('C') == -1)\n      .remove();\n\n    this.drawStroke(this._opts.drawStroke);\n\n    // add labels\n    if (!this._opts.showLabels) streamLayers.selectAll('text').remove();\n    else {\n      let mirror = this._opts.mirror;\n      streamLayers\n        .selectAll('text')\n        .data(d => (d.data && d.data.labels ? d.data.labels : []))\n        .join('text')\n        .each(function (d, i) {\n          let stream = this.parentElement.firstElementChild;\n          let numLabels = stream.__data__.data.labels.length;\n          let fontSize = stream.__data__.data.fontSize;\n          let offset = stream.__data__.textPos.offset;\n          let space = stream.__data__.textPos.height;\n          let y = (space / numLabels) * i;\n          if (!mirror) y *= -1;\n          d3__WEBPACK_IMPORTED_MODULE_0__[\"select\"](this)\n            .html(null)\n            .attr('transform', `translate(0,${y})`)\n            .attr('dominant-baseline', mirror ? 'hanging' : 'baseline')\n            .attr('font-size', fontSize)\n            .append('textPath')\n            .attr('href', '#' + stream.id)\n            .text(d => d)\n            .attr('startOffset', offset);\n        });\n    }\n\n    // add splits\n    this._svgFilters\n      .selectAll('clipPath')\n      .data(\n        this._streamData.clipPaths,\n        d => this._name + this._datasetsLoaded + d.id\n      )\n      .join(\n        enter =>\n          enter.append('clipPath').attr('id', d => 'clip' + d.id + this._name),\n        update => update,\n        exit => exit.remove()\n      )\n      .html(d => '<path d=\"' + d.path + '\">');\n\n    this._applyFilters();\n  }\n\n  _drawAxes() {\n    this._axesContainer.selectAll('*').remove();\n    let { axes, height, width } = this._opts;\n    if (axes) {\n      for (let axis of axes) {\n        axis.subticks = axis.subticks || 0;\n        axis.name = 'axis' + axis.position;\n        let totalTicks = axis.ticks * (1 + axis.subticks);\n        let dirY = axis.position == 'left' || axis.position == 'right';\n\n        let axisCon = this._axesContainer.append('g').classed(axis.name, true);\n\n        let d3axis;\n        if (axis.position == 'left') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisLeft\"](this._streamData.yScale);\n        } else if (axis.position == 'right') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisRight\"](this._streamData.yScale);\n        } else if (axis.position == 'top') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisTop\"](this._streamData.xScale);\n        } else if (axis.position == 'bottom') {\n          d3axis = d3__WEBPACK_IMPORTED_MODULE_0__[\"axisBottom\"](this._streamData.xScale);\n        }\n\n        if (totalTicks) d3axis.ticks(totalTicks);\n        // do not label subticks\n        d3axis.tickFormat((d, i) => (!(i % (1 + axis.subticks)) ? d : null));\n\n        if (axis.tickSize == 'full') {\n          let tickSize = dirY ? width : height;\n          d3axis.tickSize(tickSize);\n        }\n\n        axisCon.call(d3axis);\n\n        // move labels\n        let text = axisCon.selectAll('.tick text');\n        if (axis.textPos)\n          text.attr('x', axis.textPos[0]).attr('y', axis.textPos[1]);\n\n        if (axis.textSize) text.attr('font-size', axis.textSize);\n\n        if (axis.textAnchor) text.attr('text-anchor', axis.textAnchor);\n\n        if (axis.textBase) text.attr('dominant-baseline', axis.textBase);\n\n        axisCon.select('.domain').remove();\n      }\n    }\n  }\n\n  drawStroke(draw = true) {\n    this._opts.drawStroke = draw;\n    let color = this._opts.drawStroke ? 'black' : null;\n    this._pathContainer.attr('stroke', color);\n    this._pathContainer.attr('stroke-width', 3);\n    // d3.selectAll('path').attr('stroke-width', 0.001)\n  }\n\n  _applyFilters() {\n    if (!this._filters) return;\n\n    let filters = [];\n    for (let filter of this._filters)\n      filters.push(filter.type, {\n        color: 'black',\n        dx: filter.dx,\n        dy: filter.dy,\n        blur: filter.stdDeviation\n      });\n\n    let elements;\n    if (this._opts.filterMode == 'fast') elements = d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('.depthLayer');\n    else if (this._opts.filterMode == 'accurate')\n      elements = d3__WEBPACK_IMPORTED_MODULE_0__[\"selectAll\"]('path.stream');\n\n    if (elements.size() > 0) elements.svgFilter(...filters);\n  }\n\n  update() {\n    this._update(true);\n  }\n  _update(manuallyTriggered = false) {\n    if (!this._data) return;\n\n    if (!this._opts.automaticUpdate) if (!manuallyTriggered) return;\n\n    // console.log('update');\n    let startTime = Date.now();\n\n    this._normalizeData();\n    this._applyOrdering();\n    this._calculatePositions();\n\n    // this._streamData.preprocess();\n    this._streamData.calculatePaths();\n    this.render();\n\n    // console.log(\n    //   'TIMING: ' + this._data.numNodes + ',' + (Date.now() - startTime)\n    // );\n  }\n\n  resize(\n    width = this._container.clientWidth,\n    height = this._container.clientHeight\n  ) {\n    this._opts.width = width;\n    this._opts.height = height;\n    this._svg.attr('width', width).attr('height', height);\n\n    this._update();\n  }\n\n  ySpacingFixed(node) {\n    return this._opts.yMargin / 4;\n  }\n\n  ySpacingPercentage(node) {\n    return ((node.y1 - node.y0) * this._opts.yMargin) / 2;\n  }\n\n  ySpacingHierarchical(node) {\n    return ((node.depth + 1) * this._opts.yMargin) / 4;\n  }\n\n  ySpacingHierarchicalReverse(node) {\n    return ((1 / (node.depth + 1)) * this._opts.yMargin) / 4;\n  }\n\n  xSpacingFixed(node) {\n    return this._opts.xMargin / 10;\n  }\n\n  // TODO: use the max depth at that timepoint instead\n  xSpacingHierarchical(node) {\n    return ((node.depth + 1) / this._maxDepth) * this._opts.xMargin;\n  }\n\n  xSpacingHierarchicalReverse(node) {\n    return (1 / (node.depth + 1)) * this._opts.xMargin;\n  }\n\n  addSplits(splits) {\n    this._streamData.addSplits(splits);\n    this._update();\n  }\n\n  addSplitsAtTimepoints() {\n    let splits = [];\n    for (let i = this._minTime; i <= this._maxTime; i++) splits.push(i);\n    this.addSplits(splits);\n  }\n\n  addSplitsBetweenTimepoints() {\n    let splits = [];\n    for (let i = this._minTime - 1; i <= this._maxTime; i++)\n      splits.push(i + 0.5);\n    this.addSplits(splits);\n  }\n\n  addSplitsRandomly(num = 1) {\n    let t0 = this._minTime - 1;\n    let t1 = this._maxTime + 1;\n    let splits = [];\n    for (let i = 0; i < num; i++) {\n      let r = t0 + Math.random() * (t1 - t0);\n      splits.push(r.toString());\n      splits.sort();\n    }\n    this.addSplits(splits);\n  }\n\n  removeSplits(splits) {\n    this._streamData.removeSplits(splits);\n    this._update();\n  }\n\n  // static extend(...args) {\n  //     this.myNewFunction\n  // }\n  // extend(...args) {\n  //     return SplitStream.extend(...args);\n  // }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW0uanM/OWQzYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUI7QUFDMkI7O0FBRVM7QUFDTjtBQUNKOztBQUVIO0FBQ2hCOztBQUVqQjtBQUNmLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBMkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwyREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0RBQWtCLENBQUMsbURBQW1CO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0Q0FBWTtBQUNsQixNQUFNLDRDQUFZO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixnRUFBb0IsaUJBQWlCLDZEQUFpQjtBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixnQkFBZ0IseUNBQ0g7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBTztBQUNmLGdEQUFnRCx3Q0FBUTtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QixRQUFRLDRCQUE0QixHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywyQkFBMkI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0RBQWdEO0FBQ3pEO0FBQ0EsOEJBQThCLDhDQUNaO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw4Q0FDWjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFjO0FBQ3RCOztBQUVBLHlCQUF5Qix1Q0FDZDtBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5Q0FBUztBQUNuQjtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDJDQUFXO0FBQzlCLFNBQVM7QUFDVCxtQkFBbUIsNENBQVk7QUFDL0IsU0FBUztBQUNULG1CQUFtQiwwQ0FBVTtBQUM3QixTQUFTO0FBQ1QsbUJBQW1CLDZDQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLG9EQUFvRCw0Q0FBWTtBQUNoRTtBQUNBLGlCQUFpQiw0Q0FBWTs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL1NwbGl0U3RyZWFtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0ICcuLi9saWJzL2Qzc3ZnZmlsdGVycy9zcmMvZDMtc3ZnLWZpbHRlcnMuanMnO1xuXG5pbXBvcnQgU3BsaXRTdHJlYW1JbnB1dERhdGEgZnJvbSAnLi9TcGxpdFN0cmVhbUlucHV0RGF0YS5qcyc7XG5pbXBvcnQgU3BsaXRTdHJlYW1GaWx0ZXIgZnJvbSAnLi9TcGxpdFN0cmVhbUZpbHRlci5qcyc7XG5pbXBvcnQgU3BsaXRTdHJlYW1EYXRhIGZyb20gJy4vU3BsaXRTdHJlYW1EYXRhLmpzJztcblxuaW1wb3J0IHsgZ2V0UmFuZG9tQ29sb3IgfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgJy4uL2Nzcy9TcGxpdFN0cmVhbS5jc3MnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgb3B0cyA9IHt9KSB7XG4gICAgdGhpcy5fb3B0cyA9IHtcbiAgICAgIGF4ZXM6IFtcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIHBvc2l0aW9uOiAnbGVmdCcsXG4gICAgICAgIC8vICAgdGlja3M6IDEwLFxuICAgICAgICAvLyAgIHN1YnRpY2tzOiAyLFxuICAgICAgICAvLyAgIHNpemU6IDMwXG4gICAgICAgIC8vIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICAgICAgdGlja3M6IDUsXG4gICAgICAgICAgdGlja1NpemU6ICdmdWxsJyxcbiAgICAgICAgICB0ZXh0UG9zOiBbMCwgMF0sXG4gICAgICAgICAgdGV4dFNpemU6ICcyZW0nLFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIHRleHRCYXNlOiAnbm9uZScgLy8gZG9taW5hbnQtYmFzZWxpbmVcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHRyYW5zcGFyZW50Um9vdDogZmFsc2UsXG4gICAgICBtYXJnaW46IHsgdG9wOiAyMCwgcmlnaHQ6IDIwLCBib3R0b206IDIwLCBsZWZ0OiAyMCB9LFxuICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCxcbiAgICAgIGF1dG9tYXRpY1VwZGF0ZTogdHJ1ZSxcbiAgICAgIG1pblNpemVUaHJlc2hvbGQ6IDAsXG4gICAgICAvL3NlcGFyYXRpb25YTWV0aG9kOiBcIlwiLFxuICAgICAgeE1hcmdpbjogMCxcbiAgICAgIC8vc2VwYXJhdGlvbllNZXRob2Q6IFwiXCIsXG4gICAgICB5TWFyZ2luOiAwLFxuICAgICAgeVBhZGRpbmc6IDAsXG4gICAgICB6b29tVGltZUZhY3RvcjogMSxcbiAgICAgIHVuaWZ5U2l6ZTogZmFsc2UsXG4gICAgICB1bmlmeVBvc2l0aW9uOiBmYWxzZSxcbiAgICAgIGRyYXdTdHJva2U6IGZhbHNlLFxuICAgICAgc2hvd0xhYmVsczogZmFsc2UsXG4gICAgICBtaXJyb3I6IGZhbHNlLFxuICAgICAgc3BsaXRSb290OiBmYWxzZSxcbiAgICAgIHNoYXBlUmVuZGVyaW5nOiAnZ2VvbWV0cmljUHJlY2lzaW9uJyxcbiAgICAgIG9mZnNldDogJ3NpbGhvdWV0dGUnLCAvLyB6ZXJvLCBleHBhbmQsIHNpbGhvdWV0dGUsXG4gICAgICBmaWx0ZXJNb2RlOiAnZmFzdCcsXG5cbiAgICAgIC4uLm9wdHMgLy8gb3ZlcndyaXRlIGRlZmF1bHQgc2V0dGluZ3Mgd2l0aCB1c2VyIHNldHRpbmdzXG4gICAgfTtcblxuICAgIHRoaXMuX25hbWUgPSBjb250YWluZXIuaWQ7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX2RhdGE7XG4gICAgdGhpcy5fem9vbUNvbnRhaW5lcjtcbiAgICB0aGlzLl9heGVzQ29udGFpbmVyO1xuICAgIHRoaXMuX3BhdGhDb250YWluZXI7XG4gICAgdGhpcy5fdGV4dENvbnRhaW5lcjtcbiAgICB0aGlzLl9zdmc7XG4gICAgdGhpcy5fc3ZnRmlsdGVycztcbiAgICB0aGlzLl9maWx0ZXJzO1xuICAgIHRoaXMuX2RhdGFzZXRzTG9hZGVkID0gMDtcblxuICAgIHRoaXMuX3N0cmVhbURhdGEgPSBuZXcgU3BsaXRTdHJlYW1EYXRhKCk7XG4gICAgdGhpcy5fbWluVGltZTtcbiAgICB0aGlzLl9tYXhUaW1lO1xuICAgIHRoaXMuX21heFZhbHVlO1xuICAgIHRoaXMuX21heERlcHRoO1xuICAgIHRoaXMuX2luZGljZXMgPSB7fTtcblxuICAgIHRoaXMuX3hTcGFjaW5nID0gdGhpcy54U3BhY2luZ0ZpeGVkO1xuICAgIHRoaXMuX3lTcGFjaW5nID0gdGhpcy55U3BhY2luZ0ZpeGVkO1xuXG4gICAgdGhpcy5fb25Nb3VzZU92ZXI7XG4gICAgdGhpcy5fb25Nb3VzZU91dDtcblxuICAgIHRoaXMuX2NvbG9yID0gZDMuc2NhbGVTZXF1ZW50aWFsKGQzLmludGVycG9sYXRlQmx1ZXMpO1xuICAgIHRoaXMuX2NvbG9yUmFuZG9tID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGEoKSB7IH1cblxuICBkYXRhKGQpIHtcbiAgICByZXR1cm4gZCA9PSBudWxsID8gdGhpcy5fZGF0YSA6ICh0aGlzLl9zZXREYXRhKGQpLCB0aGlzKTtcbiAgfVxuXG4gIGZpbHRlcnMoZCkge1xuICAgIHJldHVybiBkID09IG51bGwgPyB0aGlzLl9maWx0ZXJzIDogKHRoaXMuX3NldEZpbHRlcnMoZCksIHRoaXMpO1xuICB9XG5cbiAgb3B0aW9ucyhvcHRzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRzLCBvcHRzKTtcbiAgfVxuXG4gIHNldCBhdXRvbWF0aWNVcGRhdGUoYXV0bykge1xuICAgIHRoaXMuX29wdHMuYXV0b21hdGljVXBkYXRlID0gYXV0bztcbiAgfVxuICBzZXQgdHJhbnNwYXJlbnRSb290KHRyYW5zcGFyZW50KSB7XG4gICAgdGhpcy5fb3B0cy50cmFuc3BhcmVudFJvb3QgPSB0cmFuc3BhcmVudDtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgfVxuICBzZXQgdW5pZnlTaXplKHVuaWZ5KSB7XG4gICAgdGhpcy5fb3B0cy51bmlmeVNpemUgPSB1bmlmeTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgeVBhZGRpbmcodmFsdWUpIHtcbiAgICB0aGlzLl9vcHRzLnlQYWRkaW5nID0gK3ZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCB1bmlmeVBvc2l0aW9uKHVuaWZ5KSB7XG4gICAgdGhpcy5fb3B0cy51bmlmeVBvc2l0aW9uID0gdW5pZnk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IG1pcnJvcihtaXJyb3IpIHtcbiAgICB0aGlzLl9vcHRzLm1pcnJvciA9IG1pcnJvcjtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgc3BsaXRSb290KHNwbGl0Um9vdCkge1xuICAgIHRoaXMuX29wdHMuc3BsaXRSb290ID0gc3BsaXRSb290O1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCBtaW5TaXplVGhyZXNob2xkKHRocmVzaG9sZCkge1xuICAgIHRoaXMuX29wdHMubWluU2l6ZVRocmVzaG9sZCA9ICt0aHJlc2hvbGQgLyAxMDA7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHpvb21UaW1lKGZhY3Rvcikge1xuICAgIHRoaXMuX29wdHMuem9vbVRpbWVGYWN0b3IgPSArZmFjdG9yO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCBvZmZzZXQob2Zmc2V0KSB7XG4gICAgdGhpcy5fb3B0cy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHhNYXJnaW4odmFsdWUpIHtcbiAgICB0aGlzLl9vcHRzLnhNYXJnaW4gPSArdmFsdWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHlNYXJnaW4odmFsdWUpIHtcbiAgICB0aGlzLl9vcHRzLnlNYXJnaW4gPSArdmFsdWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHNoYXBlUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICAgIHRoaXMuX29wdHMuc2hhcGVSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuICBzZXQgZmlsdGVyTW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUgIT0gdGhpcy5fb3B0cy5maWx0ZXJNb2RlKSB7XG4gICAgICBkMy5zZWxlY3RBbGwoJy5kZXB0aExheWVyJykuY2xlYXJGaWx0ZXIoKTtcbiAgICAgIGQzLnNlbGVjdEFsbCgncGF0aC5zdHJlYW0nKS5jbGVhckZpbHRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9vcHRzLmZpbHRlck1vZGUgPSBtb2RlO1xuICAgIHRoaXMuX2FwcGx5RmlsdGVycygpO1xuICB9XG5cbiAgc2V0IHNob3dMYWJlbHModmFsdWUpIHtcbiAgICB0aGlzLl9vcHRzLnNob3dMYWJlbHMgPSB2YWx1ZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIHNldCBjb2xvcihjb2xvckZ1bmN0aW9uKSB7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvckZ1bmN0aW9uO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgc2V0IGNvbG9yUmFuZG9tKHJhbmRvbSkge1xuICAgIHRoaXMuX2NvbG9yUmFuZG9tID0gcmFuZG9tO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgc2V0IHByb3BvcnRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9zdHJlYW1EYXRhLnByb3BvcnRpb24gPSB0aGlzLl9vcHRzLnByb3BvcnRpb24gPSArdmFsdWU7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHN0YXJ0RW5kRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICB0aGlzLl9zdHJlYW1EYXRhLnN0YXJ0RW5kRW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgc3RhcnRFbmRFbmNvZGluZ1goeCkge1xuICAgIHRoaXMuX3N0cmVhbURhdGEuc3RhcnRFbmRFbmNvZGluZ1ggPSB4O1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG4gIHNldCBzdGFydEVuZEVuY29kaW5nWSh5KSB7XG4gICAgdGhpcy5fc3RyZWFtRGF0YS5zdGFydEVuZEVuY29kaW5nWSA9IHk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cbiAgc2V0IHhTcGFjaW5nKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5feFNwYWNpbmcgPSBjYWxsYmFjaztcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuICBzZXQgeVNwYWNpbmcoY2FsbGJhY2spIHtcbiAgICB0aGlzLl95U3BhY2luZyA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgc2V0IG9uTW91c2VPdmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25Nb3VzZU92ZXIgPSBjYWxsYmFjaztcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgc2V0IG9uTW91c2VPdXQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbk1vdXNlT3V0ID0gY2FsbGJhY2s7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIGdldCBzcGxpdHMoKSB7XG4gICAgdGhpcy5fc3RyZWFtRGF0YS5zcGxpdHM7XG4gIH1cblxuICAvLyBleHBlY3RzIFNwbGl0U3RyZWFtSW5wdXREYXRhIGFzIGlucHV0XG4gIF9zZXREYXRhKGQpIHtcbiAgICBpZiAoIShkIGluc3RhbmNlb2YgU3BsaXRTdHJlYW1JbnB1dERhdGEgfHwgZCBpbnN0YW5jZW9mIFNwbGl0U3RyZWFtRmlsdGVyKSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdBZGRlZCBkYXRhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBTcGxpdFN0cmVhbURhdGEgb3IgU3BsaXRTdHJlYW1GaWx0ZXInXG4gICAgICApO1xuXG4gICAgdGhpcy5fZGF0YXNldHNMb2FkZWQrKztcbiAgICB0aGlzLl9kYXRhID0gZC5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX3NldEZpbHRlcnMoZCkge1xuICAgIGlmICghZCB8fCB0eXBlb2YgZCAhPT0gJ29iamVjdCcpXG4gICAgICByZXR1cm4gY29uc29sZS5sb2coYEVSUk9SOiBBZGRlZCBkYXRhIFwiJHtkfVwiIGlzIG5vdCBhbiBvYmplY3QuYCk7XG4gICAgdGhpcy5fZmlsdGVycyA9IGQ7XG4gICAgdGhpcy5fYXBwbHlGaWx0ZXJzKCk7XG4gIH1cblxuICBfaW5pdCgpIHtcbiAgICBjb25zdCB7IG1hcmdpbiB9ID0gdGhpcy5fb3B0cztcbiAgICB0aGlzLl9zdmcgPSBkM1xuICAgICAgLnNlbGVjdCh0aGlzLl9jb250YWluZXIpXG4gICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgLmNsYXNzZWQoJ3NlY3N0cmVhbScsICd0cnVlJylcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KVxuICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoKVxuICAgICAgLmNhbGwoXG4gICAgICAgIGQzLnpvb20oKS5vbignem9vbScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl96b29tQ29udGFpbmVyLmF0dHIoJ3RyYW5zZm9ybScsIGQzLmV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIC8vLm9uKFwiY29udGV4dG1lbnVcIiwgKCkgPT4gZDMuZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgLy8uYXBwZW5kKCdnJylcbiAgICAvL1x0LmF0dHIoJ2lkJywgJ3N2Zy1kcmF3bicpXG4gICAgLy8uYXR0cigndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHRoaXMuX3N2Z0ZpbHRlcnMgPSB0aGlzLl9zdmcuYXBwZW5kKCdkZWZzJyk7XG4gICAgdGhpcy5fem9vbUNvbnRhaW5lciA9IHRoaXMuX3N2Zy5hcHBlbmQoJ2cnKS5jbGFzc2VkKCd6b29tJywgdHJ1ZSk7XG4gICAgdGhpcy5fYXhlc0NvbnRhaW5lciA9IHRoaXMuX3pvb21Db250YWluZXJcbiAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgLmNsYXNzZWQoJ2F4aXNDb250YWluZXInLCB0cnVlKTtcbiAgICB0aGlzLl9wYXRoQ29udGFpbmVyID0gdGhpcy5fem9vbUNvbnRhaW5lclxuICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAuY2xhc3NlZCgncGF0aENvbnRhaW5lcicsIHRydWUpO1xuICAgIHRoaXMuX3RleHRDb250YWluZXIgPSB0aGlzLl96b29tQ29udGFpbmVyXG4gICAgICAuYXBwZW5kKCdnJylcbiAgICAgIC5jbGFzc2VkKCd0ZXh0Q29udGFpbmVyJywgdHJ1ZSk7XG4gICAgdGhpcy5fdG9vbHRpcENvbnRhaW5lciA9IHRoaXMuX3pvb21Db250YWluZXJcbiAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgLmNsYXNzZWQoJ3Rvb2x0aXBDb250YWluZXInLCB0cnVlKTtcbiAgfVxuXG4gIF9hcHBseU9yZGVyaW5nKCkge1xuICAgIC8vIGNoYW5nZSB0aGUgb3JkZXIgb2Ygc2libGluZ3MgaW4gdGhlIGRhdGEgZm9yIGxlc3MgZWRnZSBjcm9zc2luZ3NcbiAgICAvLyBURVNUOiBSQU5ET00gT1JERVIgT0YgTEVBRiBOT0RFU1xuICB9XG5cbiAgLy8gcmV0dXJucyB0cnVlIGlmIG5vZGUgaWQgZGlkIG5vdCBleGlzdCBiZWZvcmVcbiAgX2ZpbmRTdHJlYW1JZChub2RlKSB7XG4gICAgaWYgKCEhbm9kZS5wcmV2KSB7XG4gICAgICAvLyB1c2UgaWQgb2YgcHJldiBub2RlXG4gICAgICBsZXQgaWR4ID0gbm9kZS5wcmV2LmZpbmRJbmRleChwcmV2ID0+IHByZXYuaWQgPT0gbm9kZS5pZCk7XG4gICAgICBpZiAoaWR4ID09IC0xKSBpZHggPSAwO1xuICAgICAgbm9kZS5zdHJlYW1JZCA9IG5vZGUucHJldltpZHhdLnN0cmVhbUlkO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXcgbm9kZVxuICAgICAgLy8gY2hlY2sgaWYgaWQgaXMgYWxyZWFkeSBpbiB1c2VcbiAgICAgIGlmICghdGhpcy5faW5kaWNlc1tub2RlLmlkXSkge1xuICAgICAgICAvLyBpZiBub3QsIHVzZSB0aGlzIGlkIGZvciB0aGUgc3RyZWFtXG4gICAgICAgIHRoaXMuX2luZGljZXNbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICBub2RlLnN0cmVhbUlkID0gbm9kZS5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbmQgYSBuZXcgSURcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICBpZCA9IG5vZGUuaWQgKyAnXycgKyBjb3VudDtcbiAgICAgICAgfSB3aGlsZSAoISF0aGlzLl9pbmRpY2VzW2lkXSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBJRCAnJHtub2RlLmlkfScgaXMgYWxyZWFkeSBpbiB1c2UuIFVzZSAnJHtpZH0nIGluc3RlYWQuYCk7XG4gICAgICAgIC8vIElEIGlzIG5vdyBpbiB1c2VcbiAgICAgICAgdGhpcy5faW5kaWNlc1tpZF0gPSB0cnVlO1xuICAgICAgICBub2RlLnN0cmVhbUlkID0gaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfY2xlYXJTdHJlYW1JZHMoKSB7XG4gICAgdGhpcy5fc3RyZWFtRGF0YS5jbGVhcigpO1xuICAgIHRoaXMuX2luZGljZXMgPSB7fTtcbiAgfVxuXG4gIF9ub3JtYWxpemVEYXRhKCkge1xuICAgIC8vIHdlIGFkZCBhIHBhZGRpbmcgYW5kIHRoZXJlZm9yZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBhZ2dyZWdhdGUgb2YgZWFjaCBub2RlXG4gICAgLy8gaWYgYSBub2RlJ3Mgc2l6ZSBpcyBiaWdnZXIgdGhhbiBpdHMgYWdncmVnYXRlLCBpdCB3aWxsIHVzZSB0aGUgYWdncmVnYXRlIGFzIHNpemVcbiAgICAvLyBUT0RPOiBwYWRkaW5nIGludGVyZmVyZXMgd2l0aCBwb3NpdGlvbnNcbiAgICAvLyBUT0RPOiBwYWRkZWQgYWdncmVnYXRlIGNhbiBwcm9iYWJseSBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIHNpemUgb2YgdGhlIHN1YnRyZWVcbiAgICBsZXQgY2hlY2tTaXplcyA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBsZXQgYWdncmVnYXRlID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGNoZWNrU2l6ZXMoY2hpbGQpO1xuICAgICAgICAgIGFnZ3JlZ2F0ZSArPSBjaGlsZC5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZ2dyZWdhdGUgPiBub2RlLmRhdGFTaXplIHx8IHRoaXMuX29wdHMudW5pZnlTaXplKVxuICAgICAgICAgIG5vZGUuc2l6ZSA9IGFnZ3JlZ2F0ZTtcbiAgICAgICAgZWxzZSBub2RlLnNpemUgPSBub2RlLmRhdGFTaXplO1xuXG4gICAgICAgIGxldCBwYWRkaW5nID0gKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICsgMSkgKiB0aGlzLl9vcHRzLnlQYWRkaW5nOyAvLyAqICgxIC8gKG5vZGUuZGVwdGggKyAxKSk7XG4gICAgICAgIG5vZGUuc2l6ZSArPSBwYWRkaW5nO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG5vZGUuc2l6ZSA9IHRoaXMuX29wdHMudW5pZnlTaXplXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiBub2RlLmRhdGFTaXplICsgdGhpcy5fb3B0cy55UGFkZGluZztcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogVGhpcyB2ZXJzaW9uIGlzIGJldHRlciB3aXRoIHBvc2l0aW9ucyBidXQgZG9lc24ndCB3b3JrIHByb3Blcmx5IGluIGdlbmVyYWxcbiAgICAvLyBsZXQgY2hlY2tTaXplcyA9IG5vZGUgPT4ge1xuICAgIC8vICAgaWYgKCEhbm9kZS5jaGlsZHJlbikge1xuICAgIC8vICAgICBsZXQgYWdncmVnYXRlID0gMDtcbiAgICAvLyAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgIC8vICAgICAgIGNoZWNrU2l6ZXMoY2hpbGQpO1xuICAgIC8vICAgICAgIGFnZ3JlZ2F0ZSArPSBjaGlsZC5zaXplO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGxldCBkYXRhU2l6ZSA9IG5vZGUuZGF0YVNpemUgKyB0aGlzLl9vcHRzLnlQYWRkaW5nO1xuICAgIC8vICAgICBpZiAoYWdncmVnYXRlID4gZGF0YVNpemUgfHwgdGhpcy5fb3B0cy51bmlmeVNpemUpXG4gICAgLy8gICAgICAgbm9kZS5zaXplID0gYWdncmVnYXRlICsgdGhpcy5fb3B0cy55UGFkZGluZztcbiAgICAvLyAgICAgZWxzZSBub2RlLnNpemUgPSBkYXRhU2l6ZTtcbiAgICAvLyAgIH0gZWxzZSBub2RlLnNpemUgPSB0aGlzLl9vcHRzLnVuaWZ5U2l6ZSA/IDEgOiBub2RlLmRhdGFTaXplO1xuICAgIC8vIH07XG5cbiAgICAvLyBpZiBub2RlcyBkb24ndCBoYXZlIGEgc2V0IHBvc2l0aW9uLCBzcHJlYWQgdGhlbSBvdXQgZXF1YWxseVxuICAgIC8vIHBvc2l0aW9ucyBtdXN0IGJlIHVuaWZpZWQsIGlmIHNpemVzIGFyZSB1bmlmaWVkXG4gICAgbGV0IGNoZWNrUG9zaXRpb25zID0gKG5vZGUsIHBvcyA9IDApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fb3B0cy51bmlmeVNpemUgfHxcbiAgICAgICAgdGhpcy5fb3B0cy51bmlmeVBvc2l0aW9uIHx8XG4gICAgICAgIE51bWJlci5pc05hTihub2RlLmRhdGFQb3MpIHx8XG4gICAgICAgIG5vZGUuZGF0YVBvcyA9PSBudWxsXG4gICAgICAgIC8vICFub2RlLmRhdGFQb3NcbiAgICAgICAgLy8gKCEhbm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQuaWQgPT0gJ2Zha2VSb290JylcbiAgICAgIClcbiAgICAgICAgbm9kZS5wb3MgPSBwb3M7XG4gICAgICBlbHNlIG5vZGUucG9zID0gbm9kZS5kYXRhUG9zO1xuXG4gICAgICBpZiAoISFub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgYWdncmVnYXRlID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGFnZ3JlZ2F0ZSArPSBjaGlsZC5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFjaW5nID0gKG5vZGUuc2l6ZSAtIGFnZ3JlZ2F0ZSkgLyAobm9kZS5jaGlsZHJlbi5sZW5ndGggKyAxKTtcblxuICAgICAgICBmb3IgKGxldCBbaSwgY2hpbGRdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgcG9zICs9IHNwYWNpbmc7XG4gICAgICAgICAgY2hlY2tQb3NpdGlvbnMoY2hpbGQsIHBvcyk7XG4gICAgICAgICAgcG9zICs9IGNoaWxkLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fY2xlYXJTdHJlYW1JZHMoKTtcbiAgICBsZXQgdGltZSA9IHRoaXMuX2RhdGEudGltZXN0ZXBzO1xuICAgIHRoaXMuX21heFZhbHVlID0gMDtcbiAgICB0aGlzLl9tYXhUaW1lID0gMDtcbiAgICB0aGlzLl9taW5UaW1lID0gSW5maW5pdHk7XG4gICAgZm9yIChsZXQgdCBpbiB0aW1lKSB7XG4gICAgICBjaGVja1NpemVzKHRpbWVbdF0udHJlZSk7XG4gICAgICBjaGVja1Bvc2l0aW9ucyh0aW1lW3RdLnRyZWUpO1xuICAgICAgdGhpcy5fbWF4VmFsdWUgPSBNYXRoLm1heCh0aGlzLl9tYXhWYWx1ZSwgdGltZVt0XS50cmVlLnNpemUpO1xuICAgICAgdGhpcy5fbWluVGltZSA9IE1hdGgubWluKHRoaXMuX21pblRpbWUsICt0KTtcbiAgICAgIHRoaXMuX21heFRpbWUgPSBNYXRoLm1heCh0aGlzLl9tYXhUaW1lLCArdCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWF4RGVwdGggPSAwO1xuICAgIGxldCB0cmF2ZXJzZSA9IChub2RlLCBkZXB0aCkgPT4ge1xuICAgICAgdGhpcy5fbWF4RGVwdGggPSBNYXRoLm1heCh0aGlzLl9tYXhEZXB0aCwgZGVwdGgpO1xuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoKys7XG4gICAgICBsZXQgaXNOZXcgPSB0aGlzLl9maW5kU3RyZWFtSWQobm9kZSk7XG4gICAgICBpZiAoaXNOZXcpIHRoaXMuX3N0cmVhbURhdGEuYWRkKG5vZGUpO1xuXG4gICAgICBpZiAoISFub2RlLmNoaWxkcmVuKVxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdHJhdmVyc2UoY2hpbGQsIGRlcHRoKSk7XG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgaW4gdGltZSkgdHJhdmVyc2UodGltZVtpXS50cmVlLCAwKTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVQb3NpdGlvbnMoKSB7XG4gICAgbGV0IHsgbWluU2l6ZVRocmVzaG9sZCwgb2Zmc2V0IH0gPSB0aGlzLl9vcHRzO1xuXG4gICAgbGV0IHNldE9mZnNldCA9IHJvb3QgPT4ge1xuICAgICAgaWYgKG9mZnNldCA9PSAnemVybycpIHtcbiAgICAgICAgcm9vdC55MCA9IDA7XG4gICAgICAgIHJvb3QueTEgPSByb290LnNpemUgLyB0aGlzLl9tYXhWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09ICdleHBhbmQnKSB7XG4gICAgICAgIHJvb3QueTAgPSAwO1xuICAgICAgICByb290LnkxID0gMTtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09ICdzaWxob3VldHRlJykge1xuICAgICAgICByb290LnkwID0gMC41IC0gKDAuNSAqIHJvb3Quc2l6ZSkgLyB0aGlzLl9tYXhWYWx1ZTtcbiAgICAgICAgcm9vdC55MSA9IDAuNSArICgwLjUgKiByb290LnNpemUpIC8gdGhpcy5fbWF4VmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCB0cmF2ZXJzZSA9IChub2RlLCBjaGlsZFggPSAwKSA9PiB7XG4gICAgICBsZXQgcCA9IG5vZGUucGFyZW50O1xuICAgICAgaWYgKCFwKSB7XG4gICAgICAgIG5vZGUubWFyZ2luWCA9IHRoaXMuX29wdHMuc3BsaXRSb290ID8gdGhpcy5feFNwYWNpbmcobm9kZSkgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNwYWNlID0gcC55MSAtIHAueTAgLSAocC5jaGlsZHJlbi5sZW5ndGggKyAxKSAqIHAubWFyZ2luWTtcbiAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBpcyB0b28gc21hbGwsIGRyYXcgY2hpbGRyZW4gYXMgYSB6ZXJvIGxpbmUgaW4gdGhlIGNlbnRlciBvZiB0aGUgcGFyZW50IHN0cmVhbVxuICAgICAgICBpZiAoc3BhY2UgPD0gMCkge1xuICAgICAgICAgIG5vZGUueTAgPSAwLjUgKiAocC55MCArIHAueTEpO1xuICAgICAgICAgIG5vZGUueTEgPSAwLjUgKiAocC55MCArIHAueTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vcm1hbGl6ZVxuICAgICAgICAgIG5vZGUucnBvcyA9IChub2RlLnBvcyAtIHAucG9zKSAvIHAuc2l6ZTtcbiAgICAgICAgICBub2RlLnJzaXplID0gbm9kZS5zaXplIC8gcC5zaXplO1xuICAgICAgICAgIG5vZGUueTAgPSBwLnkwICsgKGNoaWxkWCArIDEpICogcC5tYXJnaW5ZICsgc3BhY2UgKiBub2RlLnJwb3M7XG4gICAgICAgICAgbm9kZS55MSA9IG5vZGUueTAgKyBzcGFjZSAqIG5vZGUucnNpemU7XG5cbiAgICAgICAgICAvLyBpZiBhIG5vZGUgaXMgdG9vIHNtYWxsLCBkcmF3IGl0IGFzIGEgemVybyBsaW5lXG4gICAgICAgICAgbGV0IHNpemUgPSBub2RlLnkxIC0gbm9kZS55MDtcbiAgICAgICAgICBpZiAoc2l6ZSA8PSBtaW5TaXplVGhyZXNob2xkKSB7XG4gICAgICAgICAgICBub2RlLnkwID0gMC41ICogKG5vZGUueTAgKyBub2RlLnkxKTtcbiAgICAgICAgICAgIG5vZGUueTEgPSAwLjUgKiAobm9kZS55MCArIG5vZGUueTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUubWFyZ2luWCA9IHAubWFyZ2luWCArIHRoaXMuX3hTcGFjaW5nKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBub2RlLm1hcmdpblkgPSB0aGlzLl95U3BhY2luZyhub2RlKTtcblxuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbilcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaSkgPT4gdHJhdmVyc2UoY2hpbGQsIGkpKTtcbiAgICB9O1xuXG4gICAgbGV0IHRpbWUgPSB0aGlzLl9kYXRhLnRpbWVzdGVwcztcbiAgICBmb3IgKGxldCBpIGluIHRpbWUpIHtcbiAgICAgIHNldE9mZnNldCh0aW1lW2ldLnRyZWUpO1xuICAgICAgdHJhdmVyc2UodGltZVtpXS50cmVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRTY2FsZXMoKTtcbiAgfVxuXG4gIF9zZXRTY2FsZXMoKSB7XG4gICAgbGV0IHsgaGVpZ2h0LCB3aWR0aCwgbWFyZ2luLCBtaXJyb3IsIHpvb21UaW1lRmFjdG9yIH0gPSB0aGlzLl9vcHRzO1xuICAgIC8vIHRyZWVtYXBzIHJlcXVpcmUgMC41IHNwYWNlIG9uIHRoZSB0aW1lIGF4aXMgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggdGltZXN0ZXBcbiAgICB0aGlzLl9zdHJlYW1EYXRhLnhTY2FsZSA9IGQzXG4gICAgICAuc2NhbGVMaW5lYXIoKVxuICAgICAgLmRvbWFpbihbdGhpcy5fbWluVGltZSAtIDAuNSwgdGhpcy5fbWF4VGltZSArIDAuNV0pXG4gICAgICAvLyAuZG9tYWluKFtcbiAgICAgIC8vICAgdGhpcy5fbWluVGltZSAtIDAuNSAqICgxIC0gdGhpcy5fb3B0cy5wcm9wb3J0aW9uKSxcbiAgICAgIC8vICAgdGhpcy5fbWF4VGltZSArIDAuNSAqICgxIC0gdGhpcy5fb3B0cy5wcm9wb3J0aW9uKVxuICAgICAgLy8gXSlcbiAgICAgIC5yYW5nZShbbWFyZ2luLmxlZnQsIHdpZHRoICogem9vbVRpbWVGYWN0b3IgLSBtYXJnaW4ucmlnaHRdKTtcblxuICAgIGxldCBkb21haW4gPSBtaXJyb3IgPyBbMSwgMF0gOiBbMCwgMV07XG4gICAgdGhpcy5fc3RyZWFtRGF0YS55U2NhbGUgPSBkM1xuICAgICAgLnNjYWxlTGluZWFyKClcbiAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgLm5pY2UoKVxuICAgICAgLnJhbmdlKFtoZWlnaHQgLSBtYXJnaW4uYm90dG9tLCBtYXJnaW4udG9wXSk7XG4gICAgLy8ucmFuZ2UobWFyZ2luLnRvcCwgaGVpZ2h0IC0gbWFyZ2luLmJvdHRvbSk7XG5cbiAgICB0aGlzLl9kcmF3QXhlcygpO1xuICB9XG5cbiAgc2V0Um9vdE5vZGVCeUlkKElkKSB7XG4gICAgbGV0IHJvb3QgPSB0aGlzLl9zdHJlYW1EYXRhLnN0cmVhbXMuZmluZChkID0+IGQuaWQgPT0gaWQpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCBtaW5Db2xvcmVkRGVwdGggPSB0aGlzLl9vcHRzLnRyYW5zcGFyZW50Um9vdCA/IDEgOiAwO1xuICAgIGxldCBjb2xvciA9IHRoaXMuX2NvbG9yUmFuZG9tXG4gICAgICA/IGdldFJhbmRvbUNvbG9yXG4gICAgICA6IHRoaXMuX2NvbG9yLmRvbWFpbihbdGhpcy5fbWF4RGVwdGgsIG1pbkNvbG9yZWREZXB0aF0pO1xuXG4gICAgbGV0IHN0cmVhbXNCeURlcHRoID0gZDNcbiAgICAgIC5uZXN0KClcbiAgICAgIC5rZXkoZCA9PiBkLmRlZXBlc3REZXB0aClcbiAgICAgIC5lbnRyaWVzKHRoaXMuX3N0cmVhbURhdGEuc3RyZWFtcyk7XG5cbiAgICAvLyBhZGQgZGVwdGggZ3JvdXBzXG4gICAgbGV0IGRlcHRoTGF5ZXJzID0gdGhpcy5fcGF0aENvbnRhaW5lclxuICAgICAgLnNlbGVjdEFsbCgnZy5kZXB0aExheWVyID4gZy5jbGlwTGF5ZXInKVxuICAgICAgLmRhdGEoc3RyZWFtc0J5RGVwdGgsIGQgPT4gZC5rZXkpXG4gICAgICAuam9pbihcbiAgICAgICAgZW50ZXIgPT5cbiAgICAgICAgICBlbnRlclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCBkID0+ICdkZXB0aExheWVyIGRlcHRoLScgKyBkLmtleSlcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2NsaXBMYXllcicsIHRydWUpLFxuICAgICAgICB1cGRhdGUgPT4gdXBkYXRlLFxuICAgICAgICBleGl0ID0+IGV4aXQucmVtb3ZlKClcbiAgICAgICk7XG5cbiAgICBsZXQgc3RyZWFtTGF5ZXJzID0gZGVwdGhMYXllcnNcbiAgICAgIC5zZWxlY3RBbGwoJ2cuc3RyZWFtTGF5ZXInKVxuICAgICAgLmRhdGEoZCA9PiBkLnZhbHVlcywgZCA9PiBkLmlkKVxuICAgICAgLmpvaW4oXG4gICAgICAgIGVudGVyID0+IGVudGVyLmFwcGVuZCgnZycpLmNsYXNzZWQoJ3N0cmVhbUxheWVyJywgdHJ1ZSksXG4gICAgICAgIHVwZGF0ZSA9PiB1cGRhdGUsXG4gICAgICAgIGV4aXQgPT4gZXhpdC5yZW1vdmUoKVxuICAgICAgKTtcblxuICAgIC8vIGFkZCBzdHJlYW1zXG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIHN0cmVhbUxheWVyc1xuICAgICAgLnNlbGVjdEFsbCgncGF0aC5zdHJlYW0nKVxuICAgICAgLmRhdGEoZCA9PiBbZF0pXG4gICAgICAuam9pbihcbiAgICAgICAgZnVuY3Rpb24gKGVudGVyKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVudGVyXG4gICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAuY2xhc3NlZCgnc3RyZWFtJywgdHJ1ZSlcbiAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBzZWxmLl9vbk1vdXNlT3ZlcilcbiAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIHNlbGYuX29uTW91c2VPdXQpXG4gICAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCBkID0+ICd1cmwoI2NsaXAnICsgZC5pZCArIHNlbGYuX25hbWUgKyAnKScpXG4gICAgICAgICAgICAgIC5hdHRyKCdpZCcsIGQgPT4gJ3N0cmVhbScgKyBkLmlkICsgc2VsZi5fbmFtZSlcbiAgICAgICAgICAgICAgLy8uYXR0cignc3Ryb2tlLXdpZHRoJywgMylcbiAgICAgICAgICAgICAgLmF0dHIoJ3BhaW50LW9yZGVyJywgJ3N0cm9rZScpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlID0+IHVwZGF0ZSxcbiAgICAgICAgZXhpdCA9PiBleGl0LnJlbW92ZSgpXG4gICAgICApXG4gICAgICAuYXR0cignZCcsIGQgPT4gZC5wYXRoKVxuICAgICAgLmF0dHIoJ3NoYXBlLXJlbmRlcmluZycsIHRoaXMuX29wdHMuc2hhcGVSZW5kZXJpbmcpXG4gICAgICAuYXR0cihcbiAgICAgICAgJ2ZpbGwnLFxuICAgICAgICBkID0+ICghIWQuZGF0YSA/IGQuZGF0YS5jb2xvciA6IG51bGwpIHx8IGNvbG9yKGQuZGVlcGVzdERlcHRoKVxuICAgICAgICAvLyAnd2hpdGUnXG4gICAgICApXG4gICAgICAuYXR0cihcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgICAgIHRoaXMuX29wdHMudHJhbnNwYXJlbnRSb290ID8gZCA9PiAoZC5pZCA9PSAnZmFrZVJvb3QnID8gMCA6IDEpIDogMVxuICAgICAgKVxuICAgICAgLy8gcmVtb3ZlIGVtcHR5IHN0cmVhbXMgKHRoZXkgZG8gbm90IGluY2x1ZGUgYSBzaW5nbGUgYmV6aWVyIGN1cnZlKVxuICAgICAgLmZpbHRlcihkID0+IGQucGF0aC5pbmRleE9mKCdDJykgPT0gLTEpXG4gICAgICAucmVtb3ZlKCk7XG5cbiAgICB0aGlzLmRyYXdTdHJva2UodGhpcy5fb3B0cy5kcmF3U3Ryb2tlKTtcblxuICAgIC8vIGFkZCBsYWJlbHNcbiAgICBpZiAoIXRoaXMuX29wdHMuc2hvd0xhYmVscykgc3RyZWFtTGF5ZXJzLnNlbGVjdEFsbCgndGV4dCcpLnJlbW92ZSgpO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IG1pcnJvciA9IHRoaXMuX29wdHMubWlycm9yO1xuICAgICAgc3RyZWFtTGF5ZXJzXG4gICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxuICAgICAgICAuZGF0YShkID0+IChkLmRhdGEgJiYgZC5kYXRhLmxhYmVscyA/IGQuZGF0YS5sYWJlbHMgOiBbXSkpXG4gICAgICAgIC5qb2luKCd0ZXh0JylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICBsZXQgc3RyZWFtID0gdGhpcy5wYXJlbnRFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgIGxldCBudW1MYWJlbHMgPSBzdHJlYW0uX19kYXRhX18uZGF0YS5sYWJlbHMubGVuZ3RoO1xuICAgICAgICAgIGxldCBmb250U2l6ZSA9IHN0cmVhbS5fX2RhdGFfXy5kYXRhLmZvbnRTaXplO1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBzdHJlYW0uX19kYXRhX18udGV4dFBvcy5vZmZzZXQ7XG4gICAgICAgICAgbGV0IHNwYWNlID0gc3RyZWFtLl9fZGF0YV9fLnRleHRQb3MuaGVpZ2h0O1xuICAgICAgICAgIGxldCB5ID0gKHNwYWNlIC8gbnVtTGFiZWxzKSAqIGk7XG4gICAgICAgICAgaWYgKCFtaXJyb3IpIHkgKj0gLTE7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAuaHRtbChudWxsKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwke3l9KWApXG4gICAgICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCBtaXJyb3IgPyAnaGFuZ2luZycgOiAnYmFzZWxpbmUnKVxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKVxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dFBhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCAnIycgKyBzdHJlYW0uaWQpXG4gICAgICAgICAgICAudGV4dChkID0+IGQpXG4gICAgICAgICAgICAuYXR0cignc3RhcnRPZmZzZXQnLCBvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgc3BsaXRzXG4gICAgdGhpcy5fc3ZnRmlsdGVyc1xuICAgICAgLnNlbGVjdEFsbCgnY2xpcFBhdGgnKVxuICAgICAgLmRhdGEoXG4gICAgICAgIHRoaXMuX3N0cmVhbURhdGEuY2xpcFBhdGhzLFxuICAgICAgICBkID0+IHRoaXMuX25hbWUgKyB0aGlzLl9kYXRhc2V0c0xvYWRlZCArIGQuaWRcbiAgICAgIClcbiAgICAgIC5qb2luKFxuICAgICAgICBlbnRlciA9PlxuICAgICAgICAgIGVudGVyLmFwcGVuZCgnY2xpcFBhdGgnKS5hdHRyKCdpZCcsIGQgPT4gJ2NsaXAnICsgZC5pZCArIHRoaXMuX25hbWUpLFxuICAgICAgICB1cGRhdGUgPT4gdXBkYXRlLFxuICAgICAgICBleGl0ID0+IGV4aXQucmVtb3ZlKClcbiAgICAgIClcbiAgICAgIC5odG1sKGQgPT4gJzxwYXRoIGQ9XCInICsgZC5wYXRoICsgJ1wiPicpO1xuXG4gICAgdGhpcy5fYXBwbHlGaWx0ZXJzKCk7XG4gIH1cblxuICBfZHJhd0F4ZXMoKSB7XG4gICAgdGhpcy5fYXhlc0NvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcbiAgICBsZXQgeyBheGVzLCBoZWlnaHQsIHdpZHRoIH0gPSB0aGlzLl9vcHRzO1xuICAgIGlmIChheGVzKSB7XG4gICAgICBmb3IgKGxldCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgICAgYXhpcy5zdWJ0aWNrcyA9IGF4aXMuc3VidGlja3MgfHwgMDtcbiAgICAgICAgYXhpcy5uYW1lID0gJ2F4aXMnICsgYXhpcy5wb3NpdGlvbjtcbiAgICAgICAgbGV0IHRvdGFsVGlja3MgPSBheGlzLnRpY2tzICogKDEgKyBheGlzLnN1YnRpY2tzKTtcbiAgICAgICAgbGV0IGRpclkgPSBheGlzLnBvc2l0aW9uID09ICdsZWZ0JyB8fCBheGlzLnBvc2l0aW9uID09ICdyaWdodCc7XG5cbiAgICAgICAgbGV0IGF4aXNDb24gPSB0aGlzLl9heGVzQ29udGFpbmVyLmFwcGVuZCgnZycpLmNsYXNzZWQoYXhpcy5uYW1lLCB0cnVlKTtcblxuICAgICAgICBsZXQgZDNheGlzO1xuICAgICAgICBpZiAoYXhpcy5wb3NpdGlvbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICBkM2F4aXMgPSBkMy5heGlzTGVmdCh0aGlzLl9zdHJlYW1EYXRhLnlTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpcy5wb3NpdGlvbiA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgZDNheGlzID0gZDMuYXhpc1JpZ2h0KHRoaXMuX3N0cmVhbURhdGEueVNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzLnBvc2l0aW9uID09ICd0b3AnKSB7XG4gICAgICAgICAgZDNheGlzID0gZDMuYXhpc1RvcCh0aGlzLl9zdHJlYW1EYXRhLnhTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpcy5wb3NpdGlvbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgIGQzYXhpcyA9IGQzLmF4aXNCb3R0b20odGhpcy5fc3RyZWFtRGF0YS54U2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvdGFsVGlja3MpIGQzYXhpcy50aWNrcyh0b3RhbFRpY2tzKTtcbiAgICAgICAgLy8gZG8gbm90IGxhYmVsIHN1YnRpY2tzXG4gICAgICAgIGQzYXhpcy50aWNrRm9ybWF0KChkLCBpKSA9PiAoIShpICUgKDEgKyBheGlzLnN1YnRpY2tzKSkgPyBkIDogbnVsbCkpO1xuXG4gICAgICAgIGlmIChheGlzLnRpY2tTaXplID09ICdmdWxsJykge1xuICAgICAgICAgIGxldCB0aWNrU2l6ZSA9IGRpclkgPyB3aWR0aCA6IGhlaWdodDtcbiAgICAgICAgICBkM2F4aXMudGlja1NpemUodGlja1NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXhpc0Nvbi5jYWxsKGQzYXhpcyk7XG5cbiAgICAgICAgLy8gbW92ZSBsYWJlbHNcbiAgICAgICAgbGV0IHRleHQgPSBheGlzQ29uLnNlbGVjdEFsbCgnLnRpY2sgdGV4dCcpO1xuICAgICAgICBpZiAoYXhpcy50ZXh0UG9zKVxuICAgICAgICAgIHRleHQuYXR0cigneCcsIGF4aXMudGV4dFBvc1swXSkuYXR0cigneScsIGF4aXMudGV4dFBvc1sxXSk7XG5cbiAgICAgICAgaWYgKGF4aXMudGV4dFNpemUpIHRleHQuYXR0cignZm9udC1zaXplJywgYXhpcy50ZXh0U2l6ZSk7XG5cbiAgICAgICAgaWYgKGF4aXMudGV4dEFuY2hvcikgdGV4dC5hdHRyKCd0ZXh0LWFuY2hvcicsIGF4aXMudGV4dEFuY2hvcik7XG5cbiAgICAgICAgaWYgKGF4aXMudGV4dEJhc2UpIHRleHQuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCBheGlzLnRleHRCYXNlKTtcblxuICAgICAgICBheGlzQ29uLnNlbGVjdCgnLmRvbWFpbicpLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXdTdHJva2UoZHJhdyA9IHRydWUpIHtcbiAgICB0aGlzLl9vcHRzLmRyYXdTdHJva2UgPSBkcmF3O1xuICAgIGxldCBjb2xvciA9IHRoaXMuX29wdHMuZHJhd1N0cm9rZSA/ICdibGFjaycgOiBudWxsO1xuICAgIHRoaXMuX3BhdGhDb250YWluZXIuYXR0cignc3Ryb2tlJywgY29sb3IpO1xuICAgIHRoaXMuX3BhdGhDb250YWluZXIuYXR0cignc3Ryb2tlLXdpZHRoJywgMyk7XG4gICAgLy8gZDMuc2VsZWN0QWxsKCdwYXRoJykuYXR0cignc3Ryb2tlLXdpZHRoJywgMC4wMDEpXG4gIH1cblxuICBfYXBwbHlGaWx0ZXJzKCkge1xuICAgIGlmICghdGhpcy5fZmlsdGVycykgcmV0dXJuO1xuXG4gICAgbGV0IGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBmaWx0ZXIgb2YgdGhpcy5fZmlsdGVycylcbiAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXIudHlwZSwge1xuICAgICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgZHg6IGZpbHRlci5keCxcbiAgICAgICAgZHk6IGZpbHRlci5keSxcbiAgICAgICAgYmx1cjogZmlsdGVyLnN0ZERldmlhdGlvblxuICAgICAgfSk7XG5cbiAgICBsZXQgZWxlbWVudHM7XG4gICAgaWYgKHRoaXMuX29wdHMuZmlsdGVyTW9kZSA9PSAnZmFzdCcpIGVsZW1lbnRzID0gZDMuc2VsZWN0QWxsKCcuZGVwdGhMYXllcicpO1xuICAgIGVsc2UgaWYgKHRoaXMuX29wdHMuZmlsdGVyTW9kZSA9PSAnYWNjdXJhdGUnKVxuICAgICAgZWxlbWVudHMgPSBkMy5zZWxlY3RBbGwoJ3BhdGguc3RyZWFtJyk7XG5cbiAgICBpZiAoZWxlbWVudHMuc2l6ZSgpID4gMCkgZWxlbWVudHMuc3ZnRmlsdGVyKC4uLmZpbHRlcnMpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcbiAgfVxuICBfdXBkYXRlKG1hbnVhbGx5VHJpZ2dlcmVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuX2RhdGEpIHJldHVybjtcblxuICAgIGlmICghdGhpcy5fb3B0cy5hdXRvbWF0aWNVcGRhdGUpIGlmICghbWFudWFsbHlUcmlnZ2VyZWQpIHJldHVybjtcblxuICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGUnKTtcbiAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMuX25vcm1hbGl6ZURhdGEoKTtcbiAgICB0aGlzLl9hcHBseU9yZGVyaW5nKCk7XG4gICAgdGhpcy5fY2FsY3VsYXRlUG9zaXRpb25zKCk7XG5cbiAgICAvLyB0aGlzLl9zdHJlYW1EYXRhLnByZXByb2Nlc3MoKTtcbiAgICB0aGlzLl9zdHJlYW1EYXRhLmNhbGN1bGF0ZVBhdGhzKCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcblxuICAgIC8vIGNvbnNvbGUubG9nKFxuICAgIC8vICAgJ1RJTUlORzogJyArIHRoaXMuX2RhdGEubnVtTm9kZXMgKyAnLCcgKyAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSlcbiAgICAvLyApO1xuICB9XG5cbiAgcmVzaXplKFxuICAgIHdpZHRoID0gdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgIGhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgKSB7XG4gICAgdGhpcy5fb3B0cy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX29wdHMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3N2Zy5hdHRyKCd3aWR0aCcsIHdpZHRoKS5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICB5U3BhY2luZ0ZpeGVkKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0cy55TWFyZ2luIC8gNDtcbiAgfVxuXG4gIHlTcGFjaW5nUGVyY2VudGFnZShub2RlKSB7XG4gICAgcmV0dXJuICgobm9kZS55MSAtIG5vZGUueTApICogdGhpcy5fb3B0cy55TWFyZ2luKSAvIDI7XG4gIH1cblxuICB5U3BhY2luZ0hpZXJhcmNoaWNhbChub2RlKSB7XG4gICAgcmV0dXJuICgobm9kZS5kZXB0aCArIDEpICogdGhpcy5fb3B0cy55TWFyZ2luKSAvIDQ7XG4gIH1cblxuICB5U3BhY2luZ0hpZXJhcmNoaWNhbFJldmVyc2Uobm9kZSkge1xuICAgIHJldHVybiAoKDEgLyAobm9kZS5kZXB0aCArIDEpKSAqIHRoaXMuX29wdHMueU1hcmdpbikgLyA0O1xuICB9XG5cbiAgeFNwYWNpbmdGaXhlZChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdHMueE1hcmdpbiAvIDEwO1xuICB9XG5cbiAgLy8gVE9ETzogdXNlIHRoZSBtYXggZGVwdGggYXQgdGhhdCB0aW1lcG9pbnQgaW5zdGVhZFxuICB4U3BhY2luZ0hpZXJhcmNoaWNhbChub2RlKSB7XG4gICAgcmV0dXJuICgobm9kZS5kZXB0aCArIDEpIC8gdGhpcy5fbWF4RGVwdGgpICogdGhpcy5fb3B0cy54TWFyZ2luO1xuICB9XG5cbiAgeFNwYWNpbmdIaWVyYXJjaGljYWxSZXZlcnNlKG5vZGUpIHtcbiAgICByZXR1cm4gKDEgLyAobm9kZS5kZXB0aCArIDEpKSAqIHRoaXMuX29wdHMueE1hcmdpbjtcbiAgfVxuXG4gIGFkZFNwbGl0cyhzcGxpdHMpIHtcbiAgICB0aGlzLl9zdHJlYW1EYXRhLmFkZFNwbGl0cyhzcGxpdHMpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgYWRkU3BsaXRzQXRUaW1lcG9pbnRzKCkge1xuICAgIGxldCBzcGxpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5fbWluVGltZTsgaSA8PSB0aGlzLl9tYXhUaW1lOyBpKyspIHNwbGl0cy5wdXNoKGkpO1xuICAgIHRoaXMuYWRkU3BsaXRzKHNwbGl0cyk7XG4gIH1cblxuICBhZGRTcGxpdHNCZXR3ZWVuVGltZXBvaW50cygpIHtcbiAgICBsZXQgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX21pblRpbWUgLSAxOyBpIDw9IHRoaXMuX21heFRpbWU7IGkrKylcbiAgICAgIHNwbGl0cy5wdXNoKGkgKyAwLjUpO1xuICAgIHRoaXMuYWRkU3BsaXRzKHNwbGl0cyk7XG4gIH1cblxuICBhZGRTcGxpdHNSYW5kb21seShudW0gPSAxKSB7XG4gICAgbGV0IHQwID0gdGhpcy5fbWluVGltZSAtIDE7XG4gICAgbGV0IHQxID0gdGhpcy5fbWF4VGltZSArIDE7XG4gICAgbGV0IHNwbGl0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgIGxldCByID0gdDAgKyBNYXRoLnJhbmRvbSgpICogKHQxIC0gdDApO1xuICAgICAgc3BsaXRzLnB1c2goci50b1N0cmluZygpKTtcbiAgICAgIHNwbGl0cy5zb3J0KCk7XG4gICAgfVxuICAgIHRoaXMuYWRkU3BsaXRzKHNwbGl0cyk7XG4gIH1cblxuICByZW1vdmVTcGxpdHMoc3BsaXRzKSB7XG4gICAgdGhpcy5fc3RyZWFtRGF0YS5yZW1vdmVTcGxpdHMoc3BsaXRzKTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIC8vIHN0YXRpYyBleHRlbmQoLi4uYXJncykge1xuICAvLyAgICAgdGhpcy5teU5ld0Z1bmN0aW9uXG4gIC8vIH1cbiAgLy8gZXh0ZW5kKC4uLmFyZ3MpIHtcbiAgLy8gICAgIHJldHVybiBTcGxpdFN0cmVhbS5leHRlbmQoLi4uYXJncyk7XG4gIC8vIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SplitStream.js\n"
          );

          /***/
        },

      /***/ './src/SplitStreamData.js':
        /*!********************************!*\
  !*** ./src/SplitStreamData.js ***!
  \********************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStreamData; });\n/* harmony import */ var _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SvgPath.js */ \"./src/SvgPath.js\");\n\n\nclass SplitStreamData {\n  // array of streams\n  // every stream has a unique ID\n  // every stream contains references to all nodes which belong to that stream\n\n  // if parent never changes, draw stream after parent\n  // if parent changes, draw after both parents.\n  // if special case, split path in 2 and draw before and after\n  constructor() {\n    this._streamNodes = [];\n    this._streams = [];\n    this._splits = {};\n    this._xScale = d => d;\n    this._yScale = d => d;\n    this._proportion = 1;\n\n    this._xCurve = 'bezier'; // linear, bezier\n    this._startEnd = {\n      encoding: 'plug', // circle, plug, default\n      x: 0.85,\n      y: 0\n    };\n  }\n\n  get streams() {\n    return this._streams;\n  }\n  get clipPaths() {\n    return this._clipPaths;\n  }\n  get splits() {\n    return Object.keys(this._splits);\n  }\n\n  set xScale(callback) {\n    this._xScale = callback;\n  }\n  set yScale(callback) {\n    this._yScale = callback;\n  }\n  get xScale() {\n    return this._xScale;\n  }\n  get yScale() {\n    return this._yScale;\n  }\n\n  set startEndEncoding(encoding) {\n    this._startEnd.encoding = encoding;\n  }\n  set startEndEncodingX(x) {\n    this._startEnd.x = x;\n  }\n  set startEndEncodingY(y) {\n    this._startEnd.y = y;\n  }\n  set proportion(p) {\n    this._proportion = p;\n  }\n\n  add(node) {\n    this._streamNodes.push(node);\n  }\n\n  // extract special operations (splits, merges, parentSwap) from the data and treat it extra\n  preprocess() {\n    let mergeNodes = [];\n    let splitNodes = [];\n    let parentSwaps = [];\n    let newStreams = [];\n\n    // cut connection between node and previous nodes\n    let cutPrevious = node => {\n      if (!!node.prev) {\n        for (let prev of node.prev) {\n          if (prev.next.length == 1) prev.next = undefined;\n          else prev.next.splice(prev.next.indexOf(node), 1);\n        }\n      }\n    };\n\n    // cut connection between node and next nodes\n    let cutNext = node => {\n      if (!!node.next) {\n        for (let next of node.next) {\n          if (next.prev.length == 1) next.prev = undefined;\n          else next.prev.splice(next.prev.indexOf(node), 1);\n        }\n      }\n    };\n\n    let traverse = node => {\n      if (!!node.next) for (let next of node.next) traverse(next);\n\n      // split nodes\n      if (!!node.next && node.next.length > 1) {\n        splitNodes.push(node);\n        cutNext(node);\n        // create new streams from here\n        newStreams.push({ ...node.next });\n\n        // end stream here\n        node.next = undefined;\n      }\n\n      // merge nodes\n      if (!!node.prev && node.prev.length > 1) {\n        mergeNodes.push(node);\n        endPrevious(node);\n\n        node.prev = undefined;\n        this.newStreams.push(node);\n      }\n\n      // parent swap\n      if (!!node.next) {\n        for (let next of node.next) {\n          // only consider nodes whos parents change\n          // 1. node becomes root node (parent changes from defined to undefined)\n          // 2. parent id changes (TODO: make sure that this case is not handled twice, because both node's parents change)\n          if (\n            (!node.parent && !!next.parent) ||\n            (!!node.parent && !!next.parent && node.parent.id != next.parent.id)\n          ) {\n            // check if next.parent had node as an ancestor in the previous step\n\n            if (!!next.parent.prev) {\n              for (let prev of next.parent.prev) {\n                let isAncestor = false;\n                let p = prev;\n                while (p && !isAncestor) {\n                  if (p.id == node.id) isAncestor = true;\n                  else p = p.parent;\n                }\n                if (isAncestor) {\n                  endPrevious(prev);\n                  if (!!prev.next) addFollowing(prev.next);\n                  parentSwaps.push({\n                    node: { ...prev },\n                    next: { ...next.parent }\n                  });\n                  prev.next = undefined;\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // draw special case for node \"p\" and all its children, as well as node\n\n    // loop in reverse, because elements are added and deleted\n    for (let i = this._streamNodes.length - 1; i >= 0; i--) {\n      traverse(this._streamNodes[i]);\n    }\n  }\n\n  clear() {\n    this._streamNodes = [];\n    this._streams = [];\n    this._clipPaths = [];\n  }\n\n  addSplits(splits) {\n    if (Array.isArray(splits))\n      splits.forEach(d => {\n        this._splits[d] = true;\n      });\n    else this._splits[d] = true;\n  }\n\n  removeSplits(splits) {\n    if (!splits) this._splits = {};\n    else\n      splits.forEach(d => {\n        this._splits[d].remove();\n      });\n  }\n\n  //TODO: find more elaborate solution\n  _findSplits(t0, t1) {\n    let splits = [];\n    for (let split in this._splits) {\n      if (split >= t0 && split <= t1) splits.push(+split);\n    }\n    return splits;\n  }\n\n  _findClosestNode(stream, x) {\n    let traverseTime = function (node) {\n      let distance = Math.abs(node.x - x);\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestNode = node;\n        // if distance is greater than minDistance, it will only increase with following nodes\n        if (!!node.next) {\n          node.next.forEach(traverseTime);\n        }\n      }\n    };\n    let minDistance = Infinity;\n    let closestNode;\n    traverseTime(stream);\n    return closestNode;\n  }\n\n  // WARNING: work in process\n  _checkForNullStreams() {\n    for (let i = 0; i < this._streamNodes.length; i++) {\n      let isNull = true;\n\n      let traverse = node => {\n        if (node.y1 - node.y0 > 0) {\n          isNull = false;\n          return;\n        }\n\n        if (!!node.next) node.next.forEach(traverse);\n      };\n\n      traverse(this._streamNodes[i]);\n\n      if (isNull) {\n        delete this._streamNodes[i]; //delete stream;\n        i--;\n      }\n    }\n  }\n\n  _drawStart(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    // extend to left\n    d.move(x(node.x), y(node.y1));\n\n    // don't draw start for zero values\n    if (node.y1 - node.y0 <= 0) return;\n\n    let t = node.x - 0.5 * (1 - prop);\n    d.horizontal(x(t));\n\n    // connect top and bottom\n    let root = node;\n    while (!!root.parent) root = root.parent;\n\n    if (!root.prev) {\n      // make first timestep flat\n      d.vertical(y(node.y0));\n    } else {\n      if (this._startEnd.encoding == 'circle') this._drawStartCircle(d, node);\n      else if (this._startEnd.encoding == 'plug') this._drawStartPlug(d, node);\n      else this._drawStartDefault(d, node);\n    }\n\n    // connect back\n    d.horizontal(x(node.x));\n  }\n\n  _drawEnd(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    if (node.y1 - node.y0 <= 0) return;\n\n    // extend to right\n    let t = node.x + 0.5 * (1 - prop);\n    d.horizontal(x(t));\n\n    // connect bottom and top\n    let root = node;\n    while (!!root.parent) root = root.parent;\n    if (!root.next) {\n      // make last timestep flat\n      d.vertical(y(node.y1));\n    } else {\n      if (this._startEnd.encoding == 'circle') this._drawEndCircle(d, node);\n      else if (this._startEnd.encoding == 'plug') this._drawEndPlug(d, node);\n      else this._drawEndDefault(d, node);\n    }\n\n    // connect back\n    d.horizontal(x(node.x));\n  }\n\n  _drawStartDefault(path, node) {\n    // insert node\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    // find position to insert node\n    let pos;\n    // find the oldest parent of node, which does not exist in the previous step\n    let parentNoPrev = node;\n    while (!!parentNoPrev.parent && !parentNoPrev.parent.prev)\n      parentNoPrev = parentNoPrev.parent;\n\n    // p is an ancestor who existed in the previous timestep\n    let p = parentNoPrev.parent;\n    if (!p) {\n      d.vertical(y(node.y0));\n    } else {\n      // use the center of the stream as reference point\n      let mid = 0.5 * (parentNoPrev.y0 + parentNoPrev.y1);\n\n      // if the nodes parent has multiple previous nodes, find the one closest to mid\n      let refPrevId = -1;\n      for (let n = 0; n < p.prev.length && refPrevId == -1; n++) {\n        let prev = p.prev[n];\n        // if mid lies within a prev node\n        if (prev.y0 <= mid && prev.y1 >= mid) {\n          // if node has children\n          if (!!prev.children && prev.children.length > 0) {\n            let refChildId = -1; // find two children to put the mid in between\n            for (let i = 0; i < prev.children.length && refChildId == -1; i++) {\n              let child = prev.children[i];\n              if (mid <= 0.5 * (child.y0 + child.y1)) refChildId = i; // setting ID breaks the loop\n            }\n            if (refChildId == 0)\n              // before first child\n              pos = 0.5 * (prev.y0 + prev.children[0].y0);\n            else if (refChildId == -1)\n              // after last child\n              pos =\n                0.5 * (prev.y1 + prev.children[prev.children.length - 1].y1);\n            else\n              pos =\n                0.5 *\n                (prev.children[refChildId - 1].y1 +\n                  prev.children[refChildId].y0);\n          } // node has no children\n          else pos = 0.5 * (prev.y0 + prev.y1);\n          refPrevId = -2; // setting ID breaks the loop\n        }\n        // if it lies outside, find two nodes to put it inbetween\n        else {\n          if (mid <= 0.5 * (prev.y0 + prev.y1)) refPrevId = n; // setting ID breaks the loop\n        }\n      }\n\n      if (refPrevId != -2) {\n        // if -2, then pos was already set\n        let node; // define the node to draw inside\n        let first; // boolean to define if it should be drawn before the first or after the last child\n        if (refPrevId == 0) {\n          // before first child\n          node = p.prev[0];\n          first = true;\n        } else if (refPrevId == -1) {\n          // after last child\n          node = p.prev[p.prev.length - 1];\n          first = false;\n        } else {\n          // find which node is closer\n          if (\n            Math.abs(p.prev[refPrevId].y0 - mid) <\n            Math.abs(p.prev[refPrevId - 1].y1)\n          ) {\n            node = p.prev[refPrevId];\n            first = true;\n          } else {\n            node = p.prev[refPrevId - 1];\n            first = false;\n          }\n        }\n\n        if (!!node.children && node.children.length > 0) {\n          if (first) pos = 0.5 * (node.y0 + node.children[0].y0);\n          else\n            pos = 0.5 * (node.y1 + node.children[node.children.length - 1].y1);\n        } else pos = 0.5 * (node.y0 + node.y1);\n      }\n\n      let tdiff = node.x - p.prev[0].x;\n      let t0 = node.x - 0.5 * (1 - prop) * tdiff;\n      let t1 = t0 - 0.5 * prop * tdiff;\n\n      if (this._xCurve == 'linear') {\n        d.line(x(p.prev[0].x), y(pos));\n        d.line(x(t0), y(node.y0));\n      } else if (this._xCurve == 'bezier') {\n        d.bezier(x(t1), y(node.y1), x(t1), y(pos), x(p.prev[0].x), y(pos));\n        d.bezier(x(t1), y(pos), x(t1), y(node.y0), x(t0), y(node.y0));\n      }\n    }\n  }\n\n  _drawEndDefault(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    // find position to delete node to\n    let pos;\n    // find the oldest parent of node, which does not exist in the next step\n    let parentNoNext = node;\n    while (!!parentNoNext.parent && !parentNoNext.parent.next)\n      parentNoNext = parentNoNext.parent; // p is the oldest parent of node, which does not exist in the next step\n\n    // p is an ancestor who exists in the next timestep\n    let p = parentNoNext.parent;\n    if (!p) {\n      d.vertical(y(node.y1));\n    } else {\n      // use the center of the stream as reference point\n      let mid = 0.5 * (parentNoNext.y0 + parentNoNext.y1);\n      // if the nodes parent has multiple next nodes, find the one closest to mid\n      let refNextId = -1;\n      for (let n = 0; n < p.next.length && refNextId == -1; n++) {\n        let next = p.next[n];\n        // if mid lies within a next node\n        if (next.y0 <= mid && next.y1 >= mid) {\n          // if node has children\n          if (!!next.children && next.children.length > 0) {\n            let refChildId = -1; // find two children to put the mid in between\n            for (let i = 0; i < next.children.length && refChildId == -1; i++) {\n              let child = next.children[i];\n              if (mid <= 0.5 * (child.y0 + child.y1)) refChildId = i; // setting ID breaks the loop\n            }\n            if (refChildId == 0)\n              // before first child\n              pos = 0.5 * (next.y0 + next.children[0].y0);\n            else if (refChildId == -1)\n              // after last child\n              pos =\n                0.5 * (next.y1 + next.children[next.children.length - 1].y1);\n            else\n              pos =\n                0.5 *\n                (next.children[refChildId - 1].y1 +\n                  next.children[refChildId].y0);\n          } // node has no children\n          else pos = 0.5 * (next.y0 + next.y1);\n          refNextId = -2; // setting ID breaks the loop\n        }\n        // if it lies outside, find two nodes to put it inbetween\n        else {\n          if (mid <= 0.5 * (next.y0 + next.y1)) refNextId = n; // setting ID breaks the loop\n        }\n      }\n\n      if (refNextId != -2) {\n        // if -2, then pos was already set\n        let node; // define the node to draw inside\n        let first; // boolean to define if it should be drawn before the first or after the last child\n        if (refNextId == 0) {\n          // before first child\n          node = p.next[0];\n          first = true;\n        } else if (refNextId == -1) {\n          // after last child\n          node = p.next[p.next.length - 1];\n          first = false;\n        } else {\n          // find which node is closer\n          if (\n            Math.abs(p.next[refNextId].y0 - mid) <\n            Math.abs(p.next[refNextId - 1].y1)\n          ) {\n            node = p.next[refNextId];\n            first = true;\n          } else {\n            node = p.next[refNextId - 1];\n            first = false;\n          }\n        }\n\n        if (!!node.children && node.children.length > 0) {\n          if (first) pos = 0.5 * (node.y0 + node.children[0].y0);\n          else\n            pos = 0.5 * (node.y1 + node.children[node.children.length - 1].y1);\n        } else pos = 0.5 * (node.y0 + node.y1);\n      }\n\n      let tdiff = p.next[0].x - node.x;\n      let t0 = node.x + 0.5 * (1 - prop) * tdiff;\n      let t1 = t0 + 0.5 * prop * tdiff;\n\n      if (this._xCurve == 'linear') {\n        d.line(x(p.next[0].x), y(pos));\n        d.line(x(t0), y(node.y1));\n      } else if (this._xCurve == 'bezier') {\n        d.bezier(x(t1), y(node.y0), x(t1), y(pos), x(p.next[0].x), y(pos));\n        d.bezier(x(t1), y(pos), x(t1), y(node.y1), x(t0), y(node.y1));\n      }\n    }\n  }\n\n  _drawStartCircle(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let height = node.y1 - node.y0;\n    let t = node.x - 0.5 * (1 - prop);\n    d.move(x(t), y(node.y1));\n    //d.arc(Math.log(height), 1, 0, 0, 0, x(node.x), y(node.y0));\n    d.arc(prop, 1, 0, 0, 0, x(t), y(node.y0));\n  }\n\n  _drawEndCircle(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let height = node.y1 - node.y0;\n    let t = node.x + 0.5 * (1 - prop);\n    //d.arc(Math.log(height), 1, 0, 0, 0, x(node.x), y(node.y1));\n    d.arc(prop, 1, 0, 0, 0, x(t), y(node.y1));\n  }\n\n  _drawStartPlug(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let t = node.x - 0.5 * (1 - prop);\n    let height = node.y1 - node.y0;\n    d.bezier(\n      x(t - prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y1 + this._startEnd.y * height),\n      x(t - prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y0 - this._startEnd.y * height),\n      x(t),\n      y(node.y0)\n    );\n  }\n\n  _drawEndPlug(path, node) {\n    const d = path,\n      prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n\n    let t = node.x + 0.5 * (1 - prop);\n    let height = node.y1 - node.y0;\n    d.bezier(\n      x(t + prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y0 - this._startEnd.y * height),\n      x(t + prop * this._startEnd.x * Math.sqrt(height)),\n      y(node.y1 + this._startEnd.y * height),\n      x(t),\n      y(node.y1)\n    );\n  }\n\n  calculatePaths() {\n    //this._checkForNullStreams();\n\n    const prop = this._proportion,\n      x = this._xScale,\n      y = this._yScale;\n    let d, lastTimepoint, deepestDepth, largestSize; // find the deepest depth each stream has over the whole timeseries\n\n    let drawLine = (t1, t2, t3, ySource, yDest) => {\n      let t12 = 0.5 * (t1 + t2); // mid between t1 and t2\n      d.horizontal(t1);\n      if (this._xCurve == 'linear') {\n        d.line(t2, y(yDest));\n      } else if (this._xCurve == 'bezier') {\n        d.bezier(t12, y(ySource), t12, y(yDest), t2, y(yDest));\n      }\n      d.horizontal(t3);\n    };\n\n    let traverse = (node, origin) => {\n      if (node.x > lastTimepoint) lastTimepoint = node.x;\n\n      if (node.depth > deepestDepth) deepestDepth = node.depth;\n      if (node.size > largestSize) largestSize = node.size;\n\n      // check if the node is reached from its true predecessor\n      let isSameStream = true;\n      if (node.prev) {\n        let trueOrigin = node.prev.find(d => d.id == node.id);\n        isSameStream = trueOrigin === undefined || trueOrigin === origin;\n      }\n\n      if (!!node.next && isSameStream) {\n        let dt = node.next[0].x - node.x;\n        let t0 = x(node.x);\n        let t1 = x(node.x + 0.5 * (1 - prop) * dt);\n        let t2 = x(node.next[0].x - 0.5 * (1 - prop) * dt);\n        let t3 = x(node.next[0].x);\n\n        let y0 = node.y0;\n        let y1 = node.y1;\n\n        for (let i = 0; i < node.next.length; i++) {\n          let dest = node.next[i];\n          // don't draw anything for streams with zero height\n          if (y1 - y0 <= 0 && dest.y1 - dest.y0 <= 0) {\n            d.move(t3, y(dest.y0));\n            traverse(dest, node);\n            d.move(t0, y(y0));\n          } else {\n            drawLine(t1, t2, t3, y0, dest.y0); // bottom line (forwards)\n            traverse(dest, node);\n            drawLine(t2, t1, t0, dest.y1, y1); // top line (backwards)\n          }\n          // if dest is one of the nodes where the split occured, we need to draw a line back to our starting point\n          if (node.next.length > 1 && i < node.next.length - 1)\n            d.vertical(y(y0));\n        }\n      } else this._drawEnd(d, node);\n    };\n\n    for (let stream of this._streamNodes) {\n      d = new _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      // reset before new values are found by traverse\n      lastTimepoint = 0;\n      deepestDepth = 0;\n      largestSize = 0;\n\n      this._drawStart(d, stream);\n      traverse(stream);\n      //d.close();\n\n      // add splits\n\n      let clipPath = new _SvgPath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      let splits = this._findSplits(stream.x - 0.5, lastTimepoint + 0.5);\n\n      let clipStart = x(-1);\n      let y0 = y(0);\n      let y1 = y(1);\n      for (let split of splits) {\n        // we move by 0.0001 to avoid cases in which the split is in the middle of 2 nodes\n        let clipEnd = x(\n          split - 0.5 * this._findClosestNode(stream, split - 0.0001).marginX\n        );\n\n        if (clipEnd - clipStart > 0) {\n          clipPath.move(clipStart, y0);\n          clipPath.horizontal(clipEnd);\n          clipPath.vertical(y1);\n          /*let dist = y1-y0;\n          let zigzags = 300;\n          let zigzagWidth = 5;\n          for (let z = 0; z < zigzags; z++) {\n              let dir = (z % 2 * 2 - 1);\n              clipPath.lineD(dir * zigzagWidth, dist/zigzags)\n          }*/\n\n          clipPath.horizontal(clipStart);\n          clipPath.vertical(y0);\n          /*for (let z = 0; z < zigzags; z++) {\n              let dir = (z % 2 * 2 - 1);\n              clipPath.lineD(dir * zigzagWidth, -dist/zigzags)\n          }*/\n        }\n        clipStart = x(\n          split + 0.5 * this._findClosestNode(stream, split + 0.0001).marginX\n        );\n      }\n      clipPath.move(clipStart, y0);\n      clipPath.horizontal(x(lastTimepoint + 1));\n      clipPath.vertical(y1);\n      clipPath.horizontal(clipStart);\n      clipPath.vertical(y0);\n\n      this._clipPaths.push({\n        id: stream.streamId,\n        path: clipPath.get()\n      });\n\n      // find position to put a text label\n      let textPos;\n      let streamHeight = Math.abs(y(stream.y1) - y(stream.y0));\n      if (streamHeight < 25) textPos = -1;\n      else {\n        if (y(stream.y1) > y(stream.y0)) textPos = y(stream.y0) + 15;\n        else textPos = y(stream.y1) + 15;\n      }\n\n      let streamObj = {\n        path: d.get(),\n        depth: stream.depth,\n        deepestDepth: deepestDepth,\n        largestSize: largestSize,\n        id: stream.streamId,\n        data: stream.data,\n        textPos: {\n          x: x(stream.x - 0.5 * (1 - this._proportion + stream.marginX)),\n          y: textPos,\n          offset: (1 - this._proportion + 0.5 * stream.marginX) * (x(1) - x(0)) + streamHeight,\n          height: streamHeight\n        }\n      };\n\n      this._streams.push(streamObj);\n      // if (!this._streams[stream.depth])\n      //     this._streams[stream.depth] = [];\n      // this._streams[stream.depth].push(streamObj);\n    }\n\n    // WARNING: This was a fix for: \"if stream IDs are strings, the clipPath array has an empty value in the beginning --> remove\"\n    // But instead it just removes all clipPaths which have string as an ID\n    //this._clipPaths = this._clipPaths.filter(d => d);\n\n    // TODO: apply an order in which children are drawn correctly\n    // this._streams.sort((a,b) => (a.depth < b.depth) ? -1 : 1)\n    this._streams.sort((a, b) => (a.deepestDepth < b.deepestDepth ? -1 : 1));\n    //this._streams.sort((a,b) => a.id < b.id ? -1: 1)\n    //this._streams.reverse();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1EYXRhLmpzP2UwMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQW1DOztBQUVwQjtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywyQkFBMkIsOENBQThDO0FBQ3pFO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywyQkFBMkIsOENBQThDO0FBQ3pFO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDhDQUE4QztBQUM5QztBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsY0FBYyxtREFBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLG1EQUFPO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9TcGxpdFN0cmVhbURhdGEuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3ZnUGF0aCBmcm9tICcuL1N2Z1BhdGguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdFN0cmVhbURhdGEge1xuICAvLyBhcnJheSBvZiBzdHJlYW1zXG4gIC8vIGV2ZXJ5IHN0cmVhbSBoYXMgYSB1bmlxdWUgSURcbiAgLy8gZXZlcnkgc3RyZWFtIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gYWxsIG5vZGVzIHdoaWNoIGJlbG9uZyB0byB0aGF0IHN0cmVhbVxuXG4gIC8vIGlmIHBhcmVudCBuZXZlciBjaGFuZ2VzLCBkcmF3IHN0cmVhbSBhZnRlciBwYXJlbnRcbiAgLy8gaWYgcGFyZW50IGNoYW5nZXMsIGRyYXcgYWZ0ZXIgYm90aCBwYXJlbnRzLlxuICAvLyBpZiBzcGVjaWFsIGNhc2UsIHNwbGl0IHBhdGggaW4gMiBhbmQgZHJhdyBiZWZvcmUgYW5kIGFmdGVyXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0cmVhbU5vZGVzID0gW107XG4gICAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICAgIHRoaXMuX3NwbGl0cyA9IHt9O1xuICAgIHRoaXMuX3hTY2FsZSA9IGQgPT4gZDtcbiAgICB0aGlzLl95U2NhbGUgPSBkID0+IGQ7XG4gICAgdGhpcy5fcHJvcG9ydGlvbiA9IDE7XG5cbiAgICB0aGlzLl94Q3VydmUgPSAnYmV6aWVyJzsgLy8gbGluZWFyLCBiZXppZXJcbiAgICB0aGlzLl9zdGFydEVuZCA9IHtcbiAgICAgIGVuY29kaW5nOiAncGx1ZycsIC8vIGNpcmNsZSwgcGx1ZywgZGVmYXVsdFxuICAgICAgeDogMC44NSxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgZ2V0IHN0cmVhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbXM7XG4gIH1cbiAgZ2V0IGNsaXBQYXRocygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpcFBhdGhzO1xuICB9XG4gIGdldCBzcGxpdHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NwbGl0cyk7XG4gIH1cblxuICBzZXQgeFNjYWxlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5feFNjYWxlID0gY2FsbGJhY2s7XG4gIH1cbiAgc2V0IHlTY2FsZShjYWxsYmFjaykge1xuICAgIHRoaXMuX3lTY2FsZSA9IGNhbGxiYWNrO1xuICB9XG4gIGdldCB4U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3hTY2FsZTtcbiAgfVxuICBnZXQgeVNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl95U2NhbGU7XG4gIH1cblxuICBzZXQgc3RhcnRFbmRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIHRoaXMuX3N0YXJ0RW5kLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIH1cbiAgc2V0IHN0YXJ0RW5kRW5jb2RpbmdYKHgpIHtcbiAgICB0aGlzLl9zdGFydEVuZC54ID0geDtcbiAgfVxuICBzZXQgc3RhcnRFbmRFbmNvZGluZ1koeSkge1xuICAgIHRoaXMuX3N0YXJ0RW5kLnkgPSB5O1xuICB9XG4gIHNldCBwcm9wb3J0aW9uKHApIHtcbiAgICB0aGlzLl9wcm9wb3J0aW9uID0gcDtcbiAgfVxuXG4gIGFkZChub2RlKSB7XG4gICAgdGhpcy5fc3RyZWFtTm9kZXMucHVzaChub2RlKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3Qgc3BlY2lhbCBvcGVyYXRpb25zIChzcGxpdHMsIG1lcmdlcywgcGFyZW50U3dhcCkgZnJvbSB0aGUgZGF0YSBhbmQgdHJlYXQgaXQgZXh0cmFcbiAgcHJlcHJvY2VzcygpIHtcbiAgICBsZXQgbWVyZ2VOb2RlcyA9IFtdO1xuICAgIGxldCBzcGxpdE5vZGVzID0gW107XG4gICAgbGV0IHBhcmVudFN3YXBzID0gW107XG4gICAgbGV0IG5ld1N0cmVhbXMgPSBbXTtcblxuICAgIC8vIGN1dCBjb25uZWN0aW9uIGJldHdlZW4gbm9kZSBhbmQgcHJldmlvdXMgbm9kZXNcbiAgICBsZXQgY3V0UHJldmlvdXMgPSBub2RlID0+IHtcbiAgICAgIGlmICghIW5vZGUucHJldikge1xuICAgICAgICBmb3IgKGxldCBwcmV2IG9mIG5vZGUucHJldikge1xuICAgICAgICAgIGlmIChwcmV2Lm5leHQubGVuZ3RoID09IDEpIHByZXYubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBlbHNlIHByZXYubmV4dC5zcGxpY2UocHJldi5uZXh0LmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGN1dCBjb25uZWN0aW9uIGJldHdlZW4gbm9kZSBhbmQgbmV4dCBub2Rlc1xuICAgIGxldCBjdXROZXh0ID0gbm9kZSA9PiB7XG4gICAgICBpZiAoISFub2RlLm5leHQpIHtcbiAgICAgICAgZm9yIChsZXQgbmV4dCBvZiBub2RlLm5leHQpIHtcbiAgICAgICAgICBpZiAobmV4dC5wcmV2Lmxlbmd0aCA9PSAxKSBuZXh0LnByZXYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZWxzZSBuZXh0LnByZXYuc3BsaWNlKG5leHQucHJldi5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgdHJhdmVyc2UgPSBub2RlID0+IHtcbiAgICAgIGlmICghIW5vZGUubmV4dCkgZm9yIChsZXQgbmV4dCBvZiBub2RlLm5leHQpIHRyYXZlcnNlKG5leHQpO1xuXG4gICAgICAvLyBzcGxpdCBub2Rlc1xuICAgICAgaWYgKCEhbm9kZS5uZXh0ICYmIG5vZGUubmV4dC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNwbGl0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgY3V0TmV4dChub2RlKTtcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBzdHJlYW1zIGZyb20gaGVyZVxuICAgICAgICBuZXdTdHJlYW1zLnB1c2goeyAuLi5ub2RlLm5leHQgfSk7XG5cbiAgICAgICAgLy8gZW5kIHN0cmVhbSBoZXJlXG4gICAgICAgIG5vZGUubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gbWVyZ2Ugbm9kZXNcbiAgICAgIGlmICghIW5vZGUucHJldiAmJiBub2RlLnByZXYubGVuZ3RoID4gMSkge1xuICAgICAgICBtZXJnZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGVuZFByZXZpb3VzKG5vZGUpO1xuXG4gICAgICAgIG5vZGUucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5uZXdTdHJlYW1zLnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcmVudCBzd2FwXG4gICAgICBpZiAoISFub2RlLm5leHQpIHtcbiAgICAgICAgZm9yIChsZXQgbmV4dCBvZiBub2RlLm5leHQpIHtcbiAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIG5vZGVzIHdob3MgcGFyZW50cyBjaGFuZ2VcbiAgICAgICAgICAvLyAxLiBub2RlIGJlY29tZXMgcm9vdCBub2RlIChwYXJlbnQgY2hhbmdlcyBmcm9tIGRlZmluZWQgdG8gdW5kZWZpbmVkKVxuICAgICAgICAgIC8vIDIuIHBhcmVudCBpZCBjaGFuZ2VzIChUT0RPOiBtYWtlIHN1cmUgdGhhdCB0aGlzIGNhc2UgaXMgbm90IGhhbmRsZWQgdHdpY2UsIGJlY2F1c2UgYm90aCBub2RlJ3MgcGFyZW50cyBjaGFuZ2UpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKCFub2RlLnBhcmVudCAmJiAhIW5leHQucGFyZW50KSB8fFxuICAgICAgICAgICAgKCEhbm9kZS5wYXJlbnQgJiYgISFuZXh0LnBhcmVudCAmJiBub2RlLnBhcmVudC5pZCAhPSBuZXh0LnBhcmVudC5pZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG5leHQucGFyZW50IGhhZCBub2RlIGFzIGFuIGFuY2VzdG9yIGluIHRoZSBwcmV2aW91cyBzdGVwXG5cbiAgICAgICAgICAgIGlmICghIW5leHQucGFyZW50LnByZXYpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgcHJldiBvZiBuZXh0LnBhcmVudC5wcmV2KSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgcCA9IHByZXY7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHAgJiYgIWlzQW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwLmlkID09IG5vZGUuaWQpIGlzQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZWxzZSBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICBlbmRQcmV2aW91cyhwcmV2KTtcbiAgICAgICAgICAgICAgICAgIGlmICghIXByZXYubmV4dCkgYWRkRm9sbG93aW5nKHByZXYubmV4dCk7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRTd2Fwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogeyAuLi5wcmV2IH0sXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IHsgLi4ubmV4dC5wYXJlbnQgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGRyYXcgc3BlY2lhbCBjYXNlIGZvciBub2RlIFwicFwiIGFuZCBhbGwgaXRzIGNoaWxkcmVuLCBhcyB3ZWxsIGFzIG5vZGVcblxuICAgIC8vIGxvb3AgaW4gcmV2ZXJzZSwgYmVjYXVzZSBlbGVtZW50cyBhcmUgYWRkZWQgYW5kIGRlbGV0ZWRcbiAgICBmb3IgKGxldCBpID0gdGhpcy5fc3RyZWFtTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRyYXZlcnNlKHRoaXMuX3N0cmVhbU5vZGVzW2ldKTtcbiAgICB9XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9zdHJlYW1Ob2RlcyA9IFtdO1xuICAgIHRoaXMuX3N0cmVhbXMgPSBbXTtcbiAgICB0aGlzLl9jbGlwUGF0aHMgPSBbXTtcbiAgfVxuXG4gIGFkZFNwbGl0cyhzcGxpdHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcGxpdHMpKVxuICAgICAgc3BsaXRzLmZvckVhY2goZCA9PiB7XG4gICAgICAgIHRoaXMuX3NwbGl0c1tkXSA9IHRydWU7XG4gICAgICB9KTtcbiAgICBlbHNlIHRoaXMuX3NwbGl0c1tkXSA9IHRydWU7XG4gIH1cblxuICByZW1vdmVTcGxpdHMoc3BsaXRzKSB7XG4gICAgaWYgKCFzcGxpdHMpIHRoaXMuX3NwbGl0cyA9IHt9O1xuICAgIGVsc2VcbiAgICAgIHNwbGl0cy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICB0aGlzLl9zcGxpdHNbZF0ucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8vVE9ETzogZmluZCBtb3JlIGVsYWJvcmF0ZSBzb2x1dGlvblxuICBfZmluZFNwbGl0cyh0MCwgdDEpIHtcbiAgICBsZXQgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgc3BsaXQgaW4gdGhpcy5fc3BsaXRzKSB7XG4gICAgICBpZiAoc3BsaXQgPj0gdDAgJiYgc3BsaXQgPD0gdDEpIHNwbGl0cy5wdXNoKCtzcGxpdCk7XG4gICAgfVxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cblxuICBfZmluZENsb3Nlc3ROb2RlKHN0cmVhbSwgeCkge1xuICAgIGxldCB0cmF2ZXJzZVRpbWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbGV0IGRpc3RhbmNlID0gTWF0aC5hYnMobm9kZS54IC0geCk7XG4gICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICBjbG9zZXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIC8vIGlmIGRpc3RhbmNlIGlzIGdyZWF0ZXIgdGhhbiBtaW5EaXN0YW5jZSwgaXQgd2lsbCBvbmx5IGluY3JlYXNlIHdpdGggZm9sbG93aW5nIG5vZGVzXG4gICAgICAgIGlmICghIW5vZGUubmV4dCkge1xuICAgICAgICAgIG5vZGUubmV4dC5mb3JFYWNoKHRyYXZlcnNlVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCBjbG9zZXN0Tm9kZTtcbiAgICB0cmF2ZXJzZVRpbWUoc3RyZWFtKTtcbiAgICByZXR1cm4gY2xvc2VzdE5vZGU7XG4gIH1cblxuICAvLyBXQVJOSU5HOiB3b3JrIGluIHByb2Nlc3NcbiAgX2NoZWNrRm9yTnVsbFN0cmVhbXMoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zdHJlYW1Ob2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGlzTnVsbCA9IHRydWU7XG5cbiAgICAgIGxldCB0cmF2ZXJzZSA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS55MSAtIG5vZGUueTAgPiAwKSB7XG4gICAgICAgICAgaXNOdWxsID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhbm9kZS5uZXh0KSBub2RlLm5leHQuZm9yRWFjaCh0cmF2ZXJzZSk7XG4gICAgICB9O1xuXG4gICAgICB0cmF2ZXJzZSh0aGlzLl9zdHJlYW1Ob2Rlc1tpXSk7XG5cbiAgICAgIGlmIChpc051bGwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0cmVhbU5vZGVzW2ldOyAvL2RlbGV0ZSBzdHJlYW07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZHJhd1N0YXJ0KHBhdGgsIG5vZGUpIHtcbiAgICBjb25zdCBkID0gcGF0aCxcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XG5cbiAgICAvLyBleHRlbmQgdG8gbGVmdFxuICAgIGQubW92ZSh4KG5vZGUueCksIHkobm9kZS55MSkpO1xuXG4gICAgLy8gZG9uJ3QgZHJhdyBzdGFydCBmb3IgemVybyB2YWx1ZXNcbiAgICBpZiAobm9kZS55MSAtIG5vZGUueTAgPD0gMCkgcmV0dXJuO1xuXG4gICAgbGV0IHQgPSBub2RlLnggLSAwLjUgKiAoMSAtIHByb3ApO1xuICAgIGQuaG9yaXpvbnRhbCh4KHQpKTtcblxuICAgIC8vIGNvbm5lY3QgdG9wIGFuZCBib3R0b21cbiAgICBsZXQgcm9vdCA9IG5vZGU7XG4gICAgd2hpbGUgKCEhcm9vdC5wYXJlbnQpIHJvb3QgPSByb290LnBhcmVudDtcblxuICAgIGlmICghcm9vdC5wcmV2KSB7XG4gICAgICAvLyBtYWtlIGZpcnN0IHRpbWVzdGVwIGZsYXRcbiAgICAgIGQudmVydGljYWwoeShub2RlLnkwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9zdGFydEVuZC5lbmNvZGluZyA9PSAnY2lyY2xlJykgdGhpcy5fZHJhd1N0YXJ0Q2lyY2xlKGQsIG5vZGUpO1xuICAgICAgZWxzZSBpZiAodGhpcy5fc3RhcnRFbmQuZW5jb2RpbmcgPT0gJ3BsdWcnKSB0aGlzLl9kcmF3U3RhcnRQbHVnKGQsIG5vZGUpO1xuICAgICAgZWxzZSB0aGlzLl9kcmF3U3RhcnREZWZhdWx0KGQsIG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGNvbm5lY3QgYmFja1xuICAgIGQuaG9yaXpvbnRhbCh4KG5vZGUueCkpO1xuICB9XG5cbiAgX2RyYXdFbmQocGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IGQgPSBwYXRoLFxuICAgICAgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb24sXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxuICAgICAgeSA9IHRoaXMuX3lTY2FsZTtcblxuICAgIGlmIChub2RlLnkxIC0gbm9kZS55MCA8PSAwKSByZXR1cm47XG5cbiAgICAvLyBleHRlbmQgdG8gcmlnaHRcbiAgICBsZXQgdCA9IG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCk7XG4gICAgZC5ob3Jpem9udGFsKHgodCkpO1xuXG4gICAgLy8gY29ubmVjdCBib3R0b20gYW5kIHRvcFxuICAgIGxldCByb290ID0gbm9kZTtcbiAgICB3aGlsZSAoISFyb290LnBhcmVudCkgcm9vdCA9IHJvb3QucGFyZW50O1xuICAgIGlmICghcm9vdC5uZXh0KSB7XG4gICAgICAvLyBtYWtlIGxhc3QgdGltZXN0ZXAgZmxhdFxuICAgICAgZC52ZXJ0aWNhbCh5KG5vZGUueTEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3N0YXJ0RW5kLmVuY29kaW5nID09ICdjaXJjbGUnKSB0aGlzLl9kcmF3RW5kQ2lyY2xlKGQsIG5vZGUpO1xuICAgICAgZWxzZSBpZiAodGhpcy5fc3RhcnRFbmQuZW5jb2RpbmcgPT0gJ3BsdWcnKSB0aGlzLl9kcmF3RW5kUGx1ZyhkLCBub2RlKTtcbiAgICAgIGVsc2UgdGhpcy5fZHJhd0VuZERlZmF1bHQoZCwgbm9kZSk7XG4gICAgfVxuXG4gICAgLy8gY29ubmVjdCBiYWNrXG4gICAgZC5ob3Jpem9udGFsKHgobm9kZS54KSk7XG4gIH1cblxuICBfZHJhd1N0YXJ0RGVmYXVsdChwYXRoLCBub2RlKSB7XG4gICAgLy8gaW5zZXJ0IG5vZGVcbiAgICBjb25zdCBkID0gcGF0aCxcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XG5cbiAgICAvLyBmaW5kIHBvc2l0aW9uIHRvIGluc2VydCBub2RlXG4gICAgbGV0IHBvcztcbiAgICAvLyBmaW5kIHRoZSBvbGRlc3QgcGFyZW50IG9mIG5vZGUsIHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIHRoZSBwcmV2aW91cyBzdGVwXG4gICAgbGV0IHBhcmVudE5vUHJldiA9IG5vZGU7XG4gICAgd2hpbGUgKCEhcGFyZW50Tm9QcmV2LnBhcmVudCAmJiAhcGFyZW50Tm9QcmV2LnBhcmVudC5wcmV2KVxuICAgICAgcGFyZW50Tm9QcmV2ID0gcGFyZW50Tm9QcmV2LnBhcmVudDtcblxuICAgIC8vIHAgaXMgYW4gYW5jZXN0b3Igd2hvIGV4aXN0ZWQgaW4gdGhlIHByZXZpb3VzIHRpbWVzdGVwXG4gICAgbGV0IHAgPSBwYXJlbnROb1ByZXYucGFyZW50O1xuICAgIGlmICghcCkge1xuICAgICAgZC52ZXJ0aWNhbCh5KG5vZGUueTApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXNlIHRoZSBjZW50ZXIgb2YgdGhlIHN0cmVhbSBhcyByZWZlcmVuY2UgcG9pbnRcbiAgICAgIGxldCBtaWQgPSAwLjUgKiAocGFyZW50Tm9QcmV2LnkwICsgcGFyZW50Tm9QcmV2LnkxKTtcblxuICAgICAgLy8gaWYgdGhlIG5vZGVzIHBhcmVudCBoYXMgbXVsdGlwbGUgcHJldmlvdXMgbm9kZXMsIGZpbmQgdGhlIG9uZSBjbG9zZXN0IHRvIG1pZFxuICAgICAgbGV0IHJlZlByZXZJZCA9IC0xO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBwLnByZXYubGVuZ3RoICYmIHJlZlByZXZJZCA9PSAtMTsgbisrKSB7XG4gICAgICAgIGxldCBwcmV2ID0gcC5wcmV2W25dO1xuICAgICAgICAvLyBpZiBtaWQgbGllcyB3aXRoaW4gYSBwcmV2IG5vZGVcbiAgICAgICAgaWYgKHByZXYueTAgPD0gbWlkICYmIHByZXYueTEgPj0gbWlkKSB7XG4gICAgICAgICAgLy8gaWYgbm9kZSBoYXMgY2hpbGRyZW5cbiAgICAgICAgICBpZiAoISFwcmV2LmNoaWxkcmVuICYmIHByZXYuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHJlZkNoaWxkSWQgPSAtMTsgLy8gZmluZCB0d28gY2hpbGRyZW4gdG8gcHV0IHRoZSBtaWQgaW4gYmV0d2VlblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2LmNoaWxkcmVuLmxlbmd0aCAmJiByZWZDaGlsZElkID09IC0xOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcHJldi5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgaWYgKG1pZCA8PSAwLjUgKiAoY2hpbGQueTAgKyBjaGlsZC55MSkpIHJlZkNoaWxkSWQgPSBpOyAvLyBzZXR0aW5nIElEIGJyZWFrcyB0aGUgbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZkNoaWxkSWQgPT0gMClcbiAgICAgICAgICAgICAgLy8gYmVmb3JlIGZpcnN0IGNoaWxkXG4gICAgICAgICAgICAgIHBvcyA9IDAuNSAqIChwcmV2LnkwICsgcHJldi5jaGlsZHJlblswXS55MCk7XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZDaGlsZElkID09IC0xKVxuICAgICAgICAgICAgICAvLyBhZnRlciBsYXN0IGNoaWxkXG4gICAgICAgICAgICAgIHBvcyA9XG4gICAgICAgICAgICAgICAgMC41ICogKHByZXYueTEgKyBwcmV2LmNoaWxkcmVuW3ByZXYuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueTEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBwb3MgPVxuICAgICAgICAgICAgICAgIDAuNSAqXG4gICAgICAgICAgICAgICAgKHByZXYuY2hpbGRyZW5bcmVmQ2hpbGRJZCAtIDFdLnkxICtcbiAgICAgICAgICAgICAgICAgIHByZXYuY2hpbGRyZW5bcmVmQ2hpbGRJZF0ueTApO1xuICAgICAgICAgIH0gLy8gbm9kZSBoYXMgbm8gY2hpbGRyZW5cbiAgICAgICAgICBlbHNlIHBvcyA9IDAuNSAqIChwcmV2LnkwICsgcHJldi55MSk7XG4gICAgICAgICAgcmVmUHJldklkID0gLTI7IC8vIHNldHRpbmcgSUQgYnJlYWtzIHRoZSBsb29wXG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaXQgbGllcyBvdXRzaWRlLCBmaW5kIHR3byBub2RlcyB0byBwdXQgaXQgaW5iZXR3ZWVuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChtaWQgPD0gMC41ICogKHByZXYueTAgKyBwcmV2LnkxKSkgcmVmUHJldklkID0gbjsgLy8gc2V0dGluZyBJRCBicmVha3MgdGhlIGxvb3BcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVmUHJldklkICE9IC0yKSB7XG4gICAgICAgIC8vIGlmIC0yLCB0aGVuIHBvcyB3YXMgYWxyZWFkeSBzZXRcbiAgICAgICAgbGV0IG5vZGU7IC8vIGRlZmluZSB0aGUgbm9kZSB0byBkcmF3IGluc2lkZVxuICAgICAgICBsZXQgZmlyc3Q7IC8vIGJvb2xlYW4gdG8gZGVmaW5lIGlmIGl0IHNob3VsZCBiZSBkcmF3biBiZWZvcmUgdGhlIGZpcnN0IG9yIGFmdGVyIHRoZSBsYXN0IGNoaWxkXG4gICAgICAgIGlmIChyZWZQcmV2SWQgPT0gMCkge1xuICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBjaGlsZFxuICAgICAgICAgIG5vZGUgPSBwLnByZXZbMF07XG4gICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZlByZXZJZCA9PSAtMSkge1xuICAgICAgICAgIC8vIGFmdGVyIGxhc3QgY2hpbGRcbiAgICAgICAgICBub2RlID0gcC5wcmV2W3AucHJldi5sZW5ndGggLSAxXTtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpbmQgd2hpY2ggbm9kZSBpcyBjbG9zZXJcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBNYXRoLmFicyhwLnByZXZbcmVmUHJldklkXS55MCAtIG1pZCkgPFxuICAgICAgICAgICAgTWF0aC5hYnMocC5wcmV2W3JlZlByZXZJZCAtIDFdLnkxKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbm9kZSA9IHAucHJldltyZWZQcmV2SWRdO1xuICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gcC5wcmV2W3JlZlByZXZJZCAtIDFdO1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISFub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChmaXJzdCkgcG9zID0gMC41ICogKG5vZGUueTAgKyBub2RlLmNoaWxkcmVuWzBdLnkwKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBwb3MgPSAwLjUgKiAobm9kZS55MSArIG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS55MSk7XG4gICAgICAgIH0gZWxzZSBwb3MgPSAwLjUgKiAobm9kZS55MCArIG5vZGUueTEpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGRpZmYgPSBub2RlLnggLSBwLnByZXZbMF0ueDtcbiAgICAgIGxldCB0MCA9IG5vZGUueCAtIDAuNSAqICgxIC0gcHJvcCkgKiB0ZGlmZjtcbiAgICAgIGxldCB0MSA9IHQwIC0gMC41ICogcHJvcCAqIHRkaWZmO1xuXG4gICAgICBpZiAodGhpcy5feEN1cnZlID09ICdsaW5lYXInKSB7XG4gICAgICAgIGQubGluZSh4KHAucHJldlswXS54KSwgeShwb3MpKTtcbiAgICAgICAgZC5saW5lKHgodDApLCB5KG5vZGUueTApKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5feEN1cnZlID09ICdiZXppZXInKSB7XG4gICAgICAgIGQuYmV6aWVyKHgodDEpLCB5KG5vZGUueTEpLCB4KHQxKSwgeShwb3MpLCB4KHAucHJldlswXS54KSwgeShwb3MpKTtcbiAgICAgICAgZC5iZXppZXIoeCh0MSksIHkocG9zKSwgeCh0MSksIHkobm9kZS55MCksIHgodDApLCB5KG5vZGUueTApKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZHJhd0VuZERlZmF1bHQocGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IGQgPSBwYXRoLFxuICAgICAgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb24sXG4gICAgICB4ID0gdGhpcy5feFNjYWxlLFxuICAgICAgeSA9IHRoaXMuX3lTY2FsZTtcblxuICAgIC8vIGZpbmQgcG9zaXRpb24gdG8gZGVsZXRlIG5vZGUgdG9cbiAgICBsZXQgcG9zO1xuICAgIC8vIGZpbmQgdGhlIG9sZGVzdCBwYXJlbnQgb2Ygbm9kZSwgd2hpY2ggZG9lcyBub3QgZXhpc3QgaW4gdGhlIG5leHQgc3RlcFxuICAgIGxldCBwYXJlbnROb05leHQgPSBub2RlO1xuICAgIHdoaWxlICghIXBhcmVudE5vTmV4dC5wYXJlbnQgJiYgIXBhcmVudE5vTmV4dC5wYXJlbnQubmV4dClcbiAgICAgIHBhcmVudE5vTmV4dCA9IHBhcmVudE5vTmV4dC5wYXJlbnQ7IC8vIHAgaXMgdGhlIG9sZGVzdCBwYXJlbnQgb2Ygbm9kZSwgd2hpY2ggZG9lcyBub3QgZXhpc3QgaW4gdGhlIG5leHQgc3RlcFxuXG4gICAgLy8gcCBpcyBhbiBhbmNlc3RvciB3aG8gZXhpc3RzIGluIHRoZSBuZXh0IHRpbWVzdGVwXG4gICAgbGV0IHAgPSBwYXJlbnROb05leHQucGFyZW50O1xuICAgIGlmICghcCkge1xuICAgICAgZC52ZXJ0aWNhbCh5KG5vZGUueTEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXNlIHRoZSBjZW50ZXIgb2YgdGhlIHN0cmVhbSBhcyByZWZlcmVuY2UgcG9pbnRcbiAgICAgIGxldCBtaWQgPSAwLjUgKiAocGFyZW50Tm9OZXh0LnkwICsgcGFyZW50Tm9OZXh0LnkxKTtcbiAgICAgIC8vIGlmIHRoZSBub2RlcyBwYXJlbnQgaGFzIG11bHRpcGxlIG5leHQgbm9kZXMsIGZpbmQgdGhlIG9uZSBjbG9zZXN0IHRvIG1pZFxuICAgICAgbGV0IHJlZk5leHRJZCA9IC0xO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBwLm5leHQubGVuZ3RoICYmIHJlZk5leHRJZCA9PSAtMTsgbisrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gcC5uZXh0W25dO1xuICAgICAgICAvLyBpZiBtaWQgbGllcyB3aXRoaW4gYSBuZXh0IG5vZGVcbiAgICAgICAgaWYgKG5leHQueTAgPD0gbWlkICYmIG5leHQueTEgPj0gbWlkKSB7XG4gICAgICAgICAgLy8gaWYgbm9kZSBoYXMgY2hpbGRyZW5cbiAgICAgICAgICBpZiAoISFuZXh0LmNoaWxkcmVuICYmIG5leHQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHJlZkNoaWxkSWQgPSAtMTsgLy8gZmluZCB0d28gY2hpbGRyZW4gdG8gcHV0IHRoZSBtaWQgaW4gYmV0d2VlblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0LmNoaWxkcmVuLmxlbmd0aCAmJiByZWZDaGlsZElkID09IC0xOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV0IGNoaWxkID0gbmV4dC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgaWYgKG1pZCA8PSAwLjUgKiAoY2hpbGQueTAgKyBjaGlsZC55MSkpIHJlZkNoaWxkSWQgPSBpOyAvLyBzZXR0aW5nIElEIGJyZWFrcyB0aGUgbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZkNoaWxkSWQgPT0gMClcbiAgICAgICAgICAgICAgLy8gYmVmb3JlIGZpcnN0IGNoaWxkXG4gICAgICAgICAgICAgIHBvcyA9IDAuNSAqIChuZXh0LnkwICsgbmV4dC5jaGlsZHJlblswXS55MCk7XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZDaGlsZElkID09IC0xKVxuICAgICAgICAgICAgICAvLyBhZnRlciBsYXN0IGNoaWxkXG4gICAgICAgICAgICAgIHBvcyA9XG4gICAgICAgICAgICAgICAgMC41ICogKG5leHQueTEgKyBuZXh0LmNoaWxkcmVuW25leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueTEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBwb3MgPVxuICAgICAgICAgICAgICAgIDAuNSAqXG4gICAgICAgICAgICAgICAgKG5leHQuY2hpbGRyZW5bcmVmQ2hpbGRJZCAtIDFdLnkxICtcbiAgICAgICAgICAgICAgICAgIG5leHQuY2hpbGRyZW5bcmVmQ2hpbGRJZF0ueTApO1xuICAgICAgICAgIH0gLy8gbm9kZSBoYXMgbm8gY2hpbGRyZW5cbiAgICAgICAgICBlbHNlIHBvcyA9IDAuNSAqIChuZXh0LnkwICsgbmV4dC55MSk7XG4gICAgICAgICAgcmVmTmV4dElkID0gLTI7IC8vIHNldHRpbmcgSUQgYnJlYWtzIHRoZSBsb29wXG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaXQgbGllcyBvdXRzaWRlLCBmaW5kIHR3byBub2RlcyB0byBwdXQgaXQgaW5iZXR3ZWVuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChtaWQgPD0gMC41ICogKG5leHQueTAgKyBuZXh0LnkxKSkgcmVmTmV4dElkID0gbjsgLy8gc2V0dGluZyBJRCBicmVha3MgdGhlIGxvb3BcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVmTmV4dElkICE9IC0yKSB7XG4gICAgICAgIC8vIGlmIC0yLCB0aGVuIHBvcyB3YXMgYWxyZWFkeSBzZXRcbiAgICAgICAgbGV0IG5vZGU7IC8vIGRlZmluZSB0aGUgbm9kZSB0byBkcmF3IGluc2lkZVxuICAgICAgICBsZXQgZmlyc3Q7IC8vIGJvb2xlYW4gdG8gZGVmaW5lIGlmIGl0IHNob3VsZCBiZSBkcmF3biBiZWZvcmUgdGhlIGZpcnN0IG9yIGFmdGVyIHRoZSBsYXN0IGNoaWxkXG4gICAgICAgIGlmIChyZWZOZXh0SWQgPT0gMCkge1xuICAgICAgICAgIC8vIGJlZm9yZSBmaXJzdCBjaGlsZFxuICAgICAgICAgIG5vZGUgPSBwLm5leHRbMF07XG4gICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZk5leHRJZCA9PSAtMSkge1xuICAgICAgICAgIC8vIGFmdGVyIGxhc3QgY2hpbGRcbiAgICAgICAgICBub2RlID0gcC5uZXh0W3AubmV4dC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpbmQgd2hpY2ggbm9kZSBpcyBjbG9zZXJcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBNYXRoLmFicyhwLm5leHRbcmVmTmV4dElkXS55MCAtIG1pZCkgPFxuICAgICAgICAgICAgTWF0aC5hYnMocC5uZXh0W3JlZk5leHRJZCAtIDFdLnkxKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbm9kZSA9IHAubmV4dFtyZWZOZXh0SWRdO1xuICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gcC5uZXh0W3JlZk5leHRJZCAtIDFdO1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISFub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChmaXJzdCkgcG9zID0gMC41ICogKG5vZGUueTAgKyBub2RlLmNoaWxkcmVuWzBdLnkwKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBwb3MgPSAwLjUgKiAobm9kZS55MSArIG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS55MSk7XG4gICAgICAgIH0gZWxzZSBwb3MgPSAwLjUgKiAobm9kZS55MCArIG5vZGUueTEpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGRpZmYgPSBwLm5leHRbMF0ueCAtIG5vZGUueDtcbiAgICAgIGxldCB0MCA9IG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCkgKiB0ZGlmZjtcbiAgICAgIGxldCB0MSA9IHQwICsgMC41ICogcHJvcCAqIHRkaWZmO1xuXG4gICAgICBpZiAodGhpcy5feEN1cnZlID09ICdsaW5lYXInKSB7XG4gICAgICAgIGQubGluZSh4KHAubmV4dFswXS54KSwgeShwb3MpKTtcbiAgICAgICAgZC5saW5lKHgodDApLCB5KG5vZGUueTEpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5feEN1cnZlID09ICdiZXppZXInKSB7XG4gICAgICAgIGQuYmV6aWVyKHgodDEpLCB5KG5vZGUueTApLCB4KHQxKSwgeShwb3MpLCB4KHAubmV4dFswXS54KSwgeShwb3MpKTtcbiAgICAgICAgZC5iZXppZXIoeCh0MSksIHkocG9zKSwgeCh0MSksIHkobm9kZS55MSksIHgodDApLCB5KG5vZGUueTEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZHJhd1N0YXJ0Q2lyY2xlKHBhdGgsIG5vZGUpIHtcbiAgICBjb25zdCBkID0gcGF0aCxcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XG5cbiAgICBsZXQgaGVpZ2h0ID0gbm9kZS55MSAtIG5vZGUueTA7XG4gICAgbGV0IHQgPSBub2RlLnggLSAwLjUgKiAoMSAtIHByb3ApO1xuICAgIGQubW92ZSh4KHQpLCB5KG5vZGUueTEpKTtcbiAgICAvL2QuYXJjKE1hdGgubG9nKGhlaWdodCksIDEsIDAsIDAsIDAsIHgobm9kZS54KSwgeShub2RlLnkwKSk7XG4gICAgZC5hcmMocHJvcCwgMSwgMCwgMCwgMCwgeCh0KSwgeShub2RlLnkwKSk7XG4gIH1cblxuICBfZHJhd0VuZENpcmNsZShwYXRoLCBub2RlKSB7XG4gICAgY29uc3QgZCA9IHBhdGgsXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xuXG4gICAgbGV0IGhlaWdodCA9IG5vZGUueTEgLSBub2RlLnkwO1xuICAgIGxldCB0ID0gbm9kZS54ICsgMC41ICogKDEgLSBwcm9wKTtcbiAgICAvL2QuYXJjKE1hdGgubG9nKGhlaWdodCksIDEsIDAsIDAsIDAsIHgobm9kZS54KSwgeShub2RlLnkxKSk7XG4gICAgZC5hcmMocHJvcCwgMSwgMCwgMCwgMCwgeCh0KSwgeShub2RlLnkxKSk7XG4gIH1cblxuICBfZHJhd1N0YXJ0UGx1ZyhwYXRoLCBub2RlKSB7XG4gICAgY29uc3QgZCA9IHBhdGgsXG4gICAgICBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbixcbiAgICAgIHggPSB0aGlzLl94U2NhbGUsXG4gICAgICB5ID0gdGhpcy5feVNjYWxlO1xuXG4gICAgbGV0IHQgPSBub2RlLnggLSAwLjUgKiAoMSAtIHByb3ApO1xuICAgIGxldCBoZWlnaHQgPSBub2RlLnkxIC0gbm9kZS55MDtcbiAgICBkLmJlemllcihcbiAgICAgIHgodCAtIHByb3AgKiB0aGlzLl9zdGFydEVuZC54ICogTWF0aC5zcXJ0KGhlaWdodCkpLFxuICAgICAgeShub2RlLnkxICsgdGhpcy5fc3RhcnRFbmQueSAqIGhlaWdodCksXG4gICAgICB4KHQgLSBwcm9wICogdGhpcy5fc3RhcnRFbmQueCAqIE1hdGguc3FydChoZWlnaHQpKSxcbiAgICAgIHkobm9kZS55MCAtIHRoaXMuX3N0YXJ0RW5kLnkgKiBoZWlnaHQpLFxuICAgICAgeCh0KSxcbiAgICAgIHkobm9kZS55MClcbiAgICApO1xuICB9XG5cbiAgX2RyYXdFbmRQbHVnKHBhdGgsIG5vZGUpIHtcbiAgICBjb25zdCBkID0gcGF0aCxcbiAgICAgIHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XG5cbiAgICBsZXQgdCA9IG5vZGUueCArIDAuNSAqICgxIC0gcHJvcCk7XG4gICAgbGV0IGhlaWdodCA9IG5vZGUueTEgLSBub2RlLnkwO1xuICAgIGQuYmV6aWVyKFxuICAgICAgeCh0ICsgcHJvcCAqIHRoaXMuX3N0YXJ0RW5kLnggKiBNYXRoLnNxcnQoaGVpZ2h0KSksXG4gICAgICB5KG5vZGUueTAgLSB0aGlzLl9zdGFydEVuZC55ICogaGVpZ2h0KSxcbiAgICAgIHgodCArIHByb3AgKiB0aGlzLl9zdGFydEVuZC54ICogTWF0aC5zcXJ0KGhlaWdodCkpLFxuICAgICAgeShub2RlLnkxICsgdGhpcy5fc3RhcnRFbmQueSAqIGhlaWdodCksXG4gICAgICB4KHQpLFxuICAgICAgeShub2RlLnkxKVxuICAgICk7XG4gIH1cblxuICBjYWxjdWxhdGVQYXRocygpIHtcbiAgICAvL3RoaXMuX2NoZWNrRm9yTnVsbFN0cmVhbXMoKTtcblxuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wb3J0aW9uLFxuICAgICAgeCA9IHRoaXMuX3hTY2FsZSxcbiAgICAgIHkgPSB0aGlzLl95U2NhbGU7XG4gICAgbGV0IGQsIGxhc3RUaW1lcG9pbnQsIGRlZXBlc3REZXB0aCwgbGFyZ2VzdFNpemU7IC8vIGZpbmQgdGhlIGRlZXBlc3QgZGVwdGggZWFjaCBzdHJlYW0gaGFzIG92ZXIgdGhlIHdob2xlIHRpbWVzZXJpZXNcblxuICAgIGxldCBkcmF3TGluZSA9ICh0MSwgdDIsIHQzLCB5U291cmNlLCB5RGVzdCkgPT4ge1xuICAgICAgbGV0IHQxMiA9IDAuNSAqICh0MSArIHQyKTsgLy8gbWlkIGJldHdlZW4gdDEgYW5kIHQyXG4gICAgICBkLmhvcml6b250YWwodDEpO1xuICAgICAgaWYgKHRoaXMuX3hDdXJ2ZSA9PSAnbGluZWFyJykge1xuICAgICAgICBkLmxpbmUodDIsIHkoeURlc3QpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5feEN1cnZlID09ICdiZXppZXInKSB7XG4gICAgICAgIGQuYmV6aWVyKHQxMiwgeSh5U291cmNlKSwgdDEyLCB5KHlEZXN0KSwgdDIsIHkoeURlc3QpKTtcbiAgICAgIH1cbiAgICAgIGQuaG9yaXpvbnRhbCh0Myk7XG4gICAgfTtcblxuICAgIGxldCB0cmF2ZXJzZSA9IChub2RlLCBvcmlnaW4pID0+IHtcbiAgICAgIGlmIChub2RlLnggPiBsYXN0VGltZXBvaW50KSBsYXN0VGltZXBvaW50ID0gbm9kZS54O1xuXG4gICAgICBpZiAobm9kZS5kZXB0aCA+IGRlZXBlc3REZXB0aCkgZGVlcGVzdERlcHRoID0gbm9kZS5kZXB0aDtcbiAgICAgIGlmIChub2RlLnNpemUgPiBsYXJnZXN0U2l6ZSkgbGFyZ2VzdFNpemUgPSBub2RlLnNpemU7XG5cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBub2RlIGlzIHJlYWNoZWQgZnJvbSBpdHMgdHJ1ZSBwcmVkZWNlc3NvclxuICAgICAgbGV0IGlzU2FtZVN0cmVhbSA9IHRydWU7XG4gICAgICBpZiAobm9kZS5wcmV2KSB7XG4gICAgICAgIGxldCB0cnVlT3JpZ2luID0gbm9kZS5wcmV2LmZpbmQoZCA9PiBkLmlkID09IG5vZGUuaWQpO1xuICAgICAgICBpc1NhbWVTdHJlYW0gPSB0cnVlT3JpZ2luID09PSB1bmRlZmluZWQgfHwgdHJ1ZU9yaWdpbiA9PT0gb3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpZiAoISFub2RlLm5leHQgJiYgaXNTYW1lU3RyZWFtKSB7XG4gICAgICAgIGxldCBkdCA9IG5vZGUubmV4dFswXS54IC0gbm9kZS54O1xuICAgICAgICBsZXQgdDAgPSB4KG5vZGUueCk7XG4gICAgICAgIGxldCB0MSA9IHgobm9kZS54ICsgMC41ICogKDEgLSBwcm9wKSAqIGR0KTtcbiAgICAgICAgbGV0IHQyID0geChub2RlLm5leHRbMF0ueCAtIDAuNSAqICgxIC0gcHJvcCkgKiBkdCk7XG4gICAgICAgIGxldCB0MyA9IHgobm9kZS5uZXh0WzBdLngpO1xuXG4gICAgICAgIGxldCB5MCA9IG5vZGUueTA7XG4gICAgICAgIGxldCB5MSA9IG5vZGUueTE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgZGVzdCA9IG5vZGUubmV4dFtpXTtcbiAgICAgICAgICAvLyBkb24ndCBkcmF3IGFueXRoaW5nIGZvciBzdHJlYW1zIHdpdGggemVybyBoZWlnaHRcbiAgICAgICAgICBpZiAoeTEgLSB5MCA8PSAwICYmIGRlc3QueTEgLSBkZXN0LnkwIDw9IDApIHtcbiAgICAgICAgICAgIGQubW92ZSh0MywgeShkZXN0LnkwKSk7XG4gICAgICAgICAgICB0cmF2ZXJzZShkZXN0LCBub2RlKTtcbiAgICAgICAgICAgIGQubW92ZSh0MCwgeSh5MCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmF3TGluZSh0MSwgdDIsIHQzLCB5MCwgZGVzdC55MCk7IC8vIGJvdHRvbSBsaW5lIChmb3J3YXJkcylcbiAgICAgICAgICAgIHRyYXZlcnNlKGRlc3QsIG5vZGUpO1xuICAgICAgICAgICAgZHJhd0xpbmUodDIsIHQxLCB0MCwgZGVzdC55MSwgeTEpOyAvLyB0b3AgbGluZSAoYmFja3dhcmRzKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBkZXN0IGlzIG9uZSBvZiB0aGUgbm9kZXMgd2hlcmUgdGhlIHNwbGl0IG9jY3VyZWQsIHdlIG5lZWQgdG8gZHJhdyBhIGxpbmUgYmFjayB0byBvdXIgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgICBpZiAobm9kZS5uZXh0Lmxlbmd0aCA+IDEgJiYgaSA8IG5vZGUubmV4dC5sZW5ndGggLSAxKVxuICAgICAgICAgICAgZC52ZXJ0aWNhbCh5KHkwKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB0aGlzLl9kcmF3RW5kKGQsIG5vZGUpO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBzdHJlYW0gb2YgdGhpcy5fc3RyZWFtTm9kZXMpIHtcbiAgICAgIGQgPSBuZXcgU3ZnUGF0aCgpO1xuICAgICAgLy8gcmVzZXQgYmVmb3JlIG5ldyB2YWx1ZXMgYXJlIGZvdW5kIGJ5IHRyYXZlcnNlXG4gICAgICBsYXN0VGltZXBvaW50ID0gMDtcbiAgICAgIGRlZXBlc3REZXB0aCA9IDA7XG4gICAgICBsYXJnZXN0U2l6ZSA9IDA7XG5cbiAgICAgIHRoaXMuX2RyYXdTdGFydChkLCBzdHJlYW0pO1xuICAgICAgdHJhdmVyc2Uoc3RyZWFtKTtcbiAgICAgIC8vZC5jbG9zZSgpO1xuXG4gICAgICAvLyBhZGQgc3BsaXRzXG5cbiAgICAgIGxldCBjbGlwUGF0aCA9IG5ldyBTdmdQYXRoKCk7XG4gICAgICBsZXQgc3BsaXRzID0gdGhpcy5fZmluZFNwbGl0cyhzdHJlYW0ueCAtIDAuNSwgbGFzdFRpbWVwb2ludCArIDAuNSk7XG5cbiAgICAgIGxldCBjbGlwU3RhcnQgPSB4KC0xKTtcbiAgICAgIGxldCB5MCA9IHkoMCk7XG4gICAgICBsZXQgeTEgPSB5KDEpO1xuICAgICAgZm9yIChsZXQgc3BsaXQgb2Ygc3BsaXRzKSB7XG4gICAgICAgIC8vIHdlIG1vdmUgYnkgMC4wMDAxIHRvIGF2b2lkIGNhc2VzIGluIHdoaWNoIHRoZSBzcGxpdCBpcyBpbiB0aGUgbWlkZGxlIG9mIDIgbm9kZXNcbiAgICAgICAgbGV0IGNsaXBFbmQgPSB4KFxuICAgICAgICAgIHNwbGl0IC0gMC41ICogdGhpcy5fZmluZENsb3Nlc3ROb2RlKHN0cmVhbSwgc3BsaXQgLSAwLjAwMDEpLm1hcmdpblhcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoY2xpcEVuZCAtIGNsaXBTdGFydCA+IDApIHtcbiAgICAgICAgICBjbGlwUGF0aC5tb3ZlKGNsaXBTdGFydCwgeTApO1xuICAgICAgICAgIGNsaXBQYXRoLmhvcml6b250YWwoY2xpcEVuZCk7XG4gICAgICAgICAgY2xpcFBhdGgudmVydGljYWwoeTEpO1xuICAgICAgICAgIC8qbGV0IGRpc3QgPSB5MS15MDtcbiAgICAgICAgICBsZXQgemlnemFncyA9IDMwMDtcbiAgICAgICAgICBsZXQgemlnemFnV2lkdGggPSA1O1xuICAgICAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgemlnemFnczsgeisrKSB7XG4gICAgICAgICAgICAgIGxldCBkaXIgPSAoeiAlIDIgKiAyIC0gMSk7XG4gICAgICAgICAgICAgIGNsaXBQYXRoLmxpbmVEKGRpciAqIHppZ3phZ1dpZHRoLCBkaXN0L3ppZ3phZ3MpXG4gICAgICAgICAgfSovXG5cbiAgICAgICAgICBjbGlwUGF0aC5ob3Jpem9udGFsKGNsaXBTdGFydCk7XG4gICAgICAgICAgY2xpcFBhdGgudmVydGljYWwoeTApO1xuICAgICAgICAgIC8qZm9yIChsZXQgeiA9IDA7IHogPCB6aWd6YWdzOyB6KyspIHtcbiAgICAgICAgICAgICAgbGV0IGRpciA9ICh6ICUgMiAqIDIgLSAxKTtcbiAgICAgICAgICAgICAgY2xpcFBhdGgubGluZUQoZGlyICogemlnemFnV2lkdGgsIC1kaXN0L3ppZ3phZ3MpXG4gICAgICAgICAgfSovXG4gICAgICAgIH1cbiAgICAgICAgY2xpcFN0YXJ0ID0geChcbiAgICAgICAgICBzcGxpdCArIDAuNSAqIHRoaXMuX2ZpbmRDbG9zZXN0Tm9kZShzdHJlYW0sIHNwbGl0ICsgMC4wMDAxKS5tYXJnaW5YXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aC5tb3ZlKGNsaXBTdGFydCwgeTApO1xuICAgICAgY2xpcFBhdGguaG9yaXpvbnRhbCh4KGxhc3RUaW1lcG9pbnQgKyAxKSk7XG4gICAgICBjbGlwUGF0aC52ZXJ0aWNhbCh5MSk7XG4gICAgICBjbGlwUGF0aC5ob3Jpem9udGFsKGNsaXBTdGFydCk7XG4gICAgICBjbGlwUGF0aC52ZXJ0aWNhbCh5MCk7XG5cbiAgICAgIHRoaXMuX2NsaXBQYXRocy5wdXNoKHtcbiAgICAgICAgaWQ6IHN0cmVhbS5zdHJlYW1JZCxcbiAgICAgICAgcGF0aDogY2xpcFBhdGguZ2V0KClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBmaW5kIHBvc2l0aW9uIHRvIHB1dCBhIHRleHQgbGFiZWxcbiAgICAgIGxldCB0ZXh0UG9zO1xuICAgICAgbGV0IHN0cmVhbUhlaWdodCA9IE1hdGguYWJzKHkoc3RyZWFtLnkxKSAtIHkoc3RyZWFtLnkwKSk7XG4gICAgICBpZiAoc3RyZWFtSGVpZ2h0IDwgMjUpIHRleHRQb3MgPSAtMTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoeShzdHJlYW0ueTEpID4geShzdHJlYW0ueTApKSB0ZXh0UG9zID0geShzdHJlYW0ueTApICsgMTU7XG4gICAgICAgIGVsc2UgdGV4dFBvcyA9IHkoc3RyZWFtLnkxKSArIDE1O1xuICAgICAgfVxuXG4gICAgICBsZXQgc3RyZWFtT2JqID0ge1xuICAgICAgICBwYXRoOiBkLmdldCgpLFxuICAgICAgICBkZXB0aDogc3RyZWFtLmRlcHRoLFxuICAgICAgICBkZWVwZXN0RGVwdGg6IGRlZXBlc3REZXB0aCxcbiAgICAgICAgbGFyZ2VzdFNpemU6IGxhcmdlc3RTaXplLFxuICAgICAgICBpZDogc3RyZWFtLnN0cmVhbUlkLFxuICAgICAgICBkYXRhOiBzdHJlYW0uZGF0YSxcbiAgICAgICAgdGV4dFBvczoge1xuICAgICAgICAgIHg6IHgoc3RyZWFtLnggLSAwLjUgKiAoMSAtIHRoaXMuX3Byb3BvcnRpb24gKyBzdHJlYW0ubWFyZ2luWCkpLFxuICAgICAgICAgIHk6IHRleHRQb3MsXG4gICAgICAgICAgb2Zmc2V0OiAoMSAtIHRoaXMuX3Byb3BvcnRpb24gKyAwLjUgKiBzdHJlYW0ubWFyZ2luWCkgKiAoeCgxKSAtIHgoMCkpICsgc3RyZWFtSGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogc3RyZWFtSGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3N0cmVhbXMucHVzaChzdHJlYW1PYmopO1xuICAgICAgLy8gaWYgKCF0aGlzLl9zdHJlYW1zW3N0cmVhbS5kZXB0aF0pXG4gICAgICAvLyAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uZGVwdGhdID0gW107XG4gICAgICAvLyB0aGlzLl9zdHJlYW1zW3N0cmVhbS5kZXB0aF0ucHVzaChzdHJlYW1PYmopO1xuICAgIH1cblxuICAgIC8vIFdBUk5JTkc6IFRoaXMgd2FzIGEgZml4IGZvcjogXCJpZiBzdHJlYW0gSURzIGFyZSBzdHJpbmdzLCB0aGUgY2xpcFBhdGggYXJyYXkgaGFzIGFuIGVtcHR5IHZhbHVlIGluIHRoZSBiZWdpbm5pbmcgLS0+IHJlbW92ZVwiXG4gICAgLy8gQnV0IGluc3RlYWQgaXQganVzdCByZW1vdmVzIGFsbCBjbGlwUGF0aHMgd2hpY2ggaGF2ZSBzdHJpbmcgYXMgYW4gSURcbiAgICAvL3RoaXMuX2NsaXBQYXRocyA9IHRoaXMuX2NsaXBQYXRocy5maWx0ZXIoZCA9PiBkKTtcblxuICAgIC8vIFRPRE86IGFwcGx5IGFuIG9yZGVyIGluIHdoaWNoIGNoaWxkcmVuIGFyZSBkcmF3biBjb3JyZWN0bHlcbiAgICAvLyB0aGlzLl9zdHJlYW1zLnNvcnQoKGEsYikgPT4gKGEuZGVwdGggPCBiLmRlcHRoKSA/IC0xIDogMSlcbiAgICB0aGlzLl9zdHJlYW1zLnNvcnQoKGEsIGIpID0+IChhLmRlZXBlc3REZXB0aCA8IGIuZGVlcGVzdERlcHRoID8gLTEgOiAxKSk7XG4gICAgLy90aGlzLl9zdHJlYW1zLnNvcnQoKGEsYikgPT4gYS5pZCA8IGIuaWQgPyAtMTogMSlcbiAgICAvL3RoaXMuX3N0cmVhbXMucmV2ZXJzZSgpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/SplitStreamData.js\n"
          );

          /***/
        },

      /***/ './src/SplitStreamFilter.js':
        /*!**********************************!*\
  !*** ./src/SplitStreamFilter.js ***!
  \**********************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SplitStreamFilter; });\n/* harmony import */ var flatted_esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flatted/esm */ "./node_modules/flatted/esm/index.js");\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SplitStreamInputData.js */ "./src/SplitStreamInputData.js");\n\r\n\r\n\r\nclass SplitStreamFilter {\r\n  // expects SplitStreamInputData.data as input\r\n  constructor(inputData, options = {}) {\r\n    this._opts = {\r\n      ...options // overwrite default settings with user settings\r\n    };\r\n    if (!inputData instanceof _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_1__["default"])\r\n      throw Exeption(\'Added data is not an instance of SplitStreamData\');\r\n    this.__inputData = inputData;\r\n    this._filteredData;\r\n    this._lastMaxDepth = 0;\r\n    this._reset();\r\n  }\r\n\r\n  get data() {\r\n    return this._filteredData;\r\n  }\r\n\r\n  _reset() {\r\n    let json = Object(flatted_esm__WEBPACK_IMPORTED_MODULE_0__["stringify"])(this.__inputData.data);\r\n    this._filteredData = Object(flatted_esm__WEBPACK_IMPORTED_MODULE_0__["parse"])(json);\r\n    //this._filteredData.timesteps = this._filteredData.timesteps.filter(d => d);\r\n    return this;\r\n  }\r\n\r\n  maxDepth(maxDepth) {\r\n    // if (maxDepth > this._lastMaxDepth) this._reset();\r\n\r\n    let traverse = node => {\r\n      if (node.depth >= maxDepth) {\r\n        node.children = [];\r\n      } else {\r\n        if (!!node.children) for (let child of node.children) traverse(child);\r\n      }\r\n    };\r\n\r\n    for (let time of this._filteredData.timesteps) {\r\n      if (!!time)\r\n        // TODO: Check why some entries are empty\r\n        traverse(time.tree);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  branch(branchNr) {\r\n    branchNr = +branchNr;\r\n    // this._reset();\r\n    for (let time of this._filteredData.timesteps) {\r\n      if (!!time) {\r\n        // TODO: Check why some entries are empty\r\n        let branches = time.tree.children;\r\n        // remove branches after branchNr\r\n        if (branchNr < branches.length - 1) branches.splice(branchNr + 1);\r\n        // remove branches before branchNr\r\n        if (branchNr > 0) branches.splice(0, branchNr);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  select(nodeId) {}\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1GaWx0ZXIuanM/ZTJkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNjOztBQUU5QztBQUNmO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnRUFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsNkRBQVM7QUFDeEIseUJBQXlCLHlEQUFLO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3BsaXRTdHJlYW1GaWx0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSwgc3RyaW5naWZ5IH0gZnJvbSAnZmxhdHRlZC9lc20nO1xyXG5pbXBvcnQgU3BsaXRTdHJlYW1JbnB1dERhdGEgZnJvbSAnLi9TcGxpdFN0cmVhbUlucHV0RGF0YS5qcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdFN0cmVhbUZpbHRlciB7XHJcbiAgLy8gZXhwZWN0cyBTcGxpdFN0cmVhbUlucHV0RGF0YS5kYXRhIGFzIGlucHV0XHJcbiAgY29uc3RydWN0b3IoaW5wdXREYXRhLCBvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMuX29wdHMgPSB7XHJcbiAgICAgIC4uLm9wdGlvbnMgLy8gb3ZlcndyaXRlIGRlZmF1bHQgc2V0dGluZ3Mgd2l0aCB1c2VyIHNldHRpbmdzXHJcbiAgICB9O1xyXG4gICAgaWYgKCFpbnB1dERhdGEgaW5zdGFuY2VvZiBTcGxpdFN0cmVhbUlucHV0RGF0YSlcclxuICAgICAgdGhyb3cgRXhlcHRpb24oJ0FkZGVkIGRhdGEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFNwbGl0U3RyZWFtRGF0YScpO1xyXG4gICAgdGhpcy5fX2lucHV0RGF0YSA9IGlucHV0RGF0YTtcclxuICAgIHRoaXMuX2ZpbHRlcmVkRGF0YTtcclxuICAgIHRoaXMuX2xhc3RNYXhEZXB0aCA9IDA7XHJcbiAgICB0aGlzLl9yZXNldCgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWREYXRhO1xyXG4gIH1cclxuXHJcbiAgX3Jlc2V0KCkge1xyXG4gICAgbGV0IGpzb24gPSBzdHJpbmdpZnkodGhpcy5fX2lucHV0RGF0YS5kYXRhKTtcclxuICAgIHRoaXMuX2ZpbHRlcmVkRGF0YSA9IHBhcnNlKGpzb24pO1xyXG4gICAgLy90aGlzLl9maWx0ZXJlZERhdGEudGltZXN0ZXBzID0gdGhpcy5fZmlsdGVyZWREYXRhLnRpbWVzdGVwcy5maWx0ZXIoZCA9PiBkKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgbWF4RGVwdGgobWF4RGVwdGgpIHtcclxuICAgIC8vIGlmIChtYXhEZXB0aCA+IHRoaXMuX2xhc3RNYXhEZXB0aCkgdGhpcy5fcmVzZXQoKTtcclxuXHJcbiAgICBsZXQgdHJhdmVyc2UgPSBub2RlID0+IHtcclxuICAgICAgaWYgKG5vZGUuZGVwdGggPj0gbWF4RGVwdGgpIHtcclxuICAgICAgICBub2RlLmNoaWxkcmVuID0gW107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbikgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikgdHJhdmVyc2UoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IHRpbWUgb2YgdGhpcy5fZmlsdGVyZWREYXRhLnRpbWVzdGVwcykge1xyXG4gICAgICBpZiAoISF0aW1lKVxyXG4gICAgICAgIC8vIFRPRE86IENoZWNrIHdoeSBzb21lIGVudHJpZXMgYXJlIGVtcHR5XHJcbiAgICAgICAgdHJhdmVyc2UodGltZS50cmVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgYnJhbmNoKGJyYW5jaE5yKSB7XHJcbiAgICBicmFuY2hOciA9ICticmFuY2hOcjtcclxuICAgIC8vIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICBmb3IgKGxldCB0aW1lIG9mIHRoaXMuX2ZpbHRlcmVkRGF0YS50aW1lc3RlcHMpIHtcclxuICAgICAgaWYgKCEhdGltZSkge1xyXG4gICAgICAgIC8vIFRPRE86IENoZWNrIHdoeSBzb21lIGVudHJpZXMgYXJlIGVtcHR5XHJcbiAgICAgICAgbGV0IGJyYW5jaGVzID0gdGltZS50cmVlLmNoaWxkcmVuO1xyXG4gICAgICAgIC8vIHJlbW92ZSBicmFuY2hlcyBhZnRlciBicmFuY2hOclxyXG4gICAgICAgIGlmIChicmFuY2hOciA8IGJyYW5jaGVzLmxlbmd0aCAtIDEpIGJyYW5jaGVzLnNwbGljZShicmFuY2hOciArIDEpO1xyXG4gICAgICAgIC8vIHJlbW92ZSBicmFuY2hlcyBiZWZvcmUgYnJhbmNoTnJcclxuICAgICAgICBpZiAoYnJhbmNoTnIgPiAwKSBicmFuY2hlcy5zcGxpY2UoMCwgYnJhbmNoTnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHNlbGVjdChub2RlSWQpIHt9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/SplitStreamFilter.js\n'
          );

          /***/
        },

      /***/ './src/SplitStreamInputData.js':
        /*!*************************************!*\
  !*** ./src/SplitStreamInputData.js ***!
  \*************************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SplitStreamInputData; });\nclass SplitStreamInputData {\n  constructor(options = {}) {\n    this._opts = {\n      forceFakeRoot: false,\n      order: {\n        name: 'minimizeEdgeCrossings',\n        options: {\n          iterations: 20\n        }\n      },\n      ...options // overwrite default settings with user settings\n    };\n    // hold a tree (root node) for each timestep\n    // hold a reference array which includes all nodes present in a single timestep\n    // TODO: if timesteps do not start with 0, for ... of loops give back undefined until the first timestep is reached\n    // TODO: The problem is that an array does contain all inbetween values, but a for ... in loop in an object converts numbers to strings again\n    // maybe prove a nextTimestep function for convenience\n    // or store the keys for timesteps in an individual array and use integer indices from 0 to n internally\n    // also requires convenience function to not write +t + 1 every time\n    this._timesteps = {};\n    this._numNodes = 0;\n  }\n\n  get data() {\n    return { timesteps: this._timesteps, numNodes: this._numNodes };\n  }\n\n  addNode(t, id, size = undefined, pos = undefined, data = undefined) {\n    if (!this._timesteps[t]) this._createTimestep(t);\n\n    if (!this._timesteps[t].references[id]) {\n      let dataSize = +size;\n      let dataPos = +pos;\n      id = String(id);\n      // size = +size;\n      // pos = +pos;\n      this._timesteps[t].references[id] = {\n        id,\n        dataSize,\n        dataPos,\n        size,\n        pos,\n        data\n      };\n      this._numNodes++;\n    } else; // console.log(`Warning AddNode: Node ${id} at timestep ${t} exists already.`);\n  }\n\n  addParent(t, id, pId) {\n    let nodes = this._timesteps[t].references;\n    let node = nodes[id];\n    let parent = nodes[pId];\n    if (!node) {\n      // console.log(`Error 'addParent': Node '${id}' does not exist.`);\n      return;\n    }\n    if (!parent) {\n      // console.log(`Error 'addParent': Parent node '${pId}' does not exist.`);\n      return;\n    }\n    node.parent = parent;\n    if (!parent.children) parent.children = [];\n    parent.children.push(node);\n  }\n\n  addNext(t, id, nextId) {\n    let time1 = this._timesteps[t];\n    let time2 = this._timesteps[+t + 1];\n    if (!time1 || !time2) {\n      // console.log(`Error 'addNext': Timestep '${+t + 1}' does not exist.`);\n      return false;\n    }\n\n    let node = time1.references[id];\n    let nextNode = time2.references[nextId];\n    if (!node || !nextNode) {\n      // console.log(`Error 'addNext': Node '${id}' does not exist.`);\n      return false;\n    }\n\n    // console.log(`Change timestep ${t}: ${id} to ${nextId}`);\n    if (!node.next) node.next = [];\n    node.next.push(nextNode);\n    if (!nextNode.prev) nextNode.prev = [];\n    nextNode.prev.push(node);\n    return true;\n  }\n\n  finalize() {\n    this._checkParents();\n\n    this.__forEachNodeDepthFirst((node, depth, t) => {\n      node.x = +t;\n      node.depth = depth;\n      this._setSizeAndAggregate(node);\n      this._checkSize(node);\n      this._checkPositions(node);\n    });\n\n    if (this._opts.order)\n      if (this._opts.order.name == 'minimizeEdgeCrossings') {\n        if (this._opts.order.options)\n          this.minimizeEdgeCrossings(this._opts.order.options.iterations);\n        else this.minimizeEdgeCrossings();\n      }\n  }\n\n  // check if all nodes except the root have a parent\n  // if multiple roots exist, create a fake root\n  _checkParents() {\n    let nodesWithoutParents = {};\n    for (let t in this._timesteps) {\n      let nodes = this._timesteps[t].references;\n      for (let id in nodes) {\n        let node = nodes[id];\n        if (!node.parent) {\n          if (!nodesWithoutParents[t]) nodesWithoutParents[t] = [];\n          nodesWithoutParents[t].push(node);\n        }\n      }\n    }\n\n    let fakeRootNeeded = false;\n    for (let t in nodesWithoutParents) {\n      if (nodesWithoutParents[t].length > 1) {\n        fakeRootNeeded = true;\n        break;\n      }\n    }\n\n    if (fakeRootNeeded || this._opts.forceFakeRoot) {\n      let prevT;\n      for (let t in nodesWithoutParents) {\n        this.addNode(t, 'fakeRoot');\n        nodesWithoutParents[t].forEach(node => {\n          this.addParent(t, node.id, 'fakeRoot');\n          this._timesteps[t].tree = this._timesteps[t].references['fakeRoot'];\n        });\n        // connect fake roots\n        if (!!prevT) {\n          this.addNext(prevT, 'fakeRoot', 'fakeRoot');\n        }\n        prevT = t;\n      }\n    } else {\n      // every timepoint has a single root node\n      for (let t in nodesWithoutParents) {\n        this._timesteps[t].tree = nodesWithoutParents[t][0];\n      }\n    }\n  }\n\n  // if node does not have a size, set it's size to the sum of the sizes of its children\n  // if a node does not have a size and does not have children, give it size 1\n  _setSizeAndAggregate(node) {\n    if (!!node.children) {\n      node.aggregate = 0;\n      for (let child of node.children) node.aggregate += child.dataSize;\n      if (Number.isNaN(node.dataSize)) node.dataSize = node.aggregate;\n    } else {\n      if (Number.isNaN(node.dataSize)) node.dataSize = 1;\n      node.aggregate = node.dataSize;\n    }\n  }\n\n  _checkSize(node) {\n    if (node.dataSize < node.aggregate) {\n      // console.log('Error: Node has a smaller size than its children.');\n      // console.log(node);\n    }\n  }\n\n  // check if size of parent elements is bigger than the aggregate of the sizes of its children\n  _checkPositions(node) {\n    if (!!node.children) {\n      let minPos = 0;\n      for (let child of node.children) {\n        if (child.pos >= 0) {\n          if (minPos > child.pos) {\n            // console.log('Error: Children positions overlap each other.');\n            // console.log(node);\n          }\n          minPos = child.pos + child.dataSize;\n        }\n      }\n    }\n  }\n\n  __forEachNodeDepthFirst(callback) {\n    let traverse = function(node, depth, t) {\n      if (!!node.children)\n        node.children.forEach(child => traverse(child, depth + 1, t));\n      callback(node, depth, t);\n    };\n\n    for (let t in this._timesteps) traverse(this._timesteps[t].tree, 0, t);\n  }\n\n  _createTimestep(t) {\n    this._timesteps[t] = {\n      references: {},\n      tree: null\n    };\n  }\n\n  // connect nodes which have the same ID in consecutive timesteps\n  connectEqualIds() {\n    for (let t in this._timesteps) {\n      if (!!this._timesteps[+t + 1]) {\n        let nodes = this._timesteps[t].references;\n        let nodes2 = this._timesteps[+t + 1].references;\n        for (let id in nodes) {\n          if (!!nodes2[id]) {\n            // do not build connections if the nodes next elements were manually set\n            if (!nodes[id].next) nodes[id].next = [];\n            if (!nodes2[id].prev) nodes2[id].prev = [];\n\n            nodes[id].next.push(nodes2[id]);\n            nodes2[id].prev.push(nodes[id]);\n          }\n        }\n      }\n    }\n  }\n\n  // following the algorithm by Shixia Liu et al. in StoryFlow, based on\n  // Methods for Visual Understanding of Hierarchical System Structures by Sugiyama et al.\n  minimizeEdgeCrossings(iterations = 20) {\n    // create t-1 adjacency matrices for leave nodes\n    let leaves = this.__getLeafNodes();\n    let M = this.__getAdjacencyMatrices(leaves);\n    let timesteps = Object.keys(this._timesteps);\n\n    let calculateBarycenterCols = t => {\n      for (let l in leaves[t])\n        leaves[t][l].barycenter = this.__getBarycenterCol(M[t - 1], l);\n    };\n\n    let calculateBarycenterRows = t => {\n      for (let l in leaves[t])\n        leaves[t][l].barycenter = this.__getBarycenterRow(M[t], l);\n    };\n\n    let reorder = t => {\n      this.__orderByBarycenter(this._timesteps[t].tree);\n      let newOrder = this.__getNewOrder(this._timesteps[t].tree);\n      applyOrder(t, newOrder);\n    };\n\n    let applyOrder = (t, order) => {\n      // reorder matrix rows\n      if (M[t]) M[t] = order.map(i => M[t][i]);\n      // reorder same nodes in previous matrix columns\n      if (M[t - 1])\n        M[t - 1].forEach((row, i) => (M[t - 1][i] = order.map(i => row[i])));\n      // reorder leaf array\n      leaves[t] = order.map(i => leaves[t][i]);\n    };\n\n    //sweep right, reorder columns based on barycenters\n    let phase1Down = () => {\n      for (let tId = 1; tId < timesteps.length; tId++) {\n        let t = timesteps[tId];\n        calculateBarycenterCols(t);\n        reorder(t);\n      }\n    };\n\n    // sweep left, reorder rows\n    let phase1Up = () => {\n      for (let tId = timesteps.length - 2; tId >= 0; tId--) {\n        let t = timesteps[tId];\n        calculateBarycenterRows(t);\n        reorder(t);\n      }\n    };\n\n    // sweep right, reverse order of nodes with equal barycenter\n    let phase2Down = () => {\n      for (let tId = 1; tId < timesteps.length; tId++) {\n        let t = timesteps[tId];\n        calculateBarycenterCols(t);\n        this.__reverseEqualBarycenters(this._timesteps[t].tree);\n        let newOrder = this.__getNewOrder(this._timesteps[t].tree);\n        applyOrder(t, newOrder);\n      }\n    };\n\n    let phase2Up = () => {\n      for (let tId = timesteps.length - 2; tId >= 0; tId--) {\n        let t = timesteps[tId];\n        calculateBarycenterRows(t);\n        this.__reverseEqualBarycenters(this._timesteps[t].tree);\n        let newOrder = this.__getNewOrder(this._timesteps[t].tree);\n        applyOrder(t, newOrder);\n      }\n    };\n\n    for (let i = 0; i < iterations; i++) {\n      if (i % 2 == 0) {\n        phase1Down();\n        phase2Down();\n        phase2Up();\n      } else {\n        phase1Up();\n        phase2Up();\n        phase2Down();\n      }\n\n      // TODO: stop if all rows and columns are sorted ascending\n      // this is the case when no order changed in an iteration\n    }\n  }\n\n  // takes an array of barycenter values as input\n  // outputs an array of new indices, where elements with equal values are reversed\n  __reverseIndicesOfEqualValues(array) {\n    let result = [];\n    // create an object that contains for each value an array of indices that have this value\n    let equals = {};\n    array.forEach((val, idx) => {\n      if (!equals[val]) equals[val] = [];\n      equals[val].push(idx);\n    });\n    // for each value reverse the index order\n    for (let val in equals) {\n      let indices = equals[val];\n      indices.forEach((idx, i) => {\n        result[idx] = indices[indices.length - i - 1];\n      });\n    }\n    return result;\n  }\n\n  __reverseEqualBarycenters(tree) {\n    let numLeaves = 0;\n    let traverse = node => {\n      if (!node.children) node.bcMatrixPosition = numLeaves++;\n      else {\n        node.children.forEach(child => traverse(child));\n        // extract an array of barycenters in order\n        let barycenterArray = node.children.map(d => d.barycenter);\n        // reverse the order of equal barycenters\n        let newOrder = this.__reverseIndicesOfEqualValues(barycenterArray);\n        // reorder children\n        node.children = newOrder.map(idx => node.children[idx]);\n      }\n    };\n    traverse(tree);\n  }\n\n  __getNewOrder(tree) {\n    let order = [];\n    let newLeafOrder = node => {\n      if (node.children) node.children.forEach(child => newLeafOrder(child));\n      else order.push(node.bcMatrixPosition);\n    };\n    newLeafOrder(tree);\n    return order;\n  }\n\n  // bcMatrixRange defines the area of the adjacency matrix in which the node has influence\n  // this is necesasry because of hierarchy nodes that span a wider range\n  __orderByBarycenter(tree) {\n    let numLeaves = 0;\n    let traverse = node => {\n      if (!node.children) node.bcMatrixPosition = numLeaves++;\n      else {\n        node.barycenter = 0; // hierarchy nodes get the average of their childrens' barycenter\n        let numInvolvedChildren = 0;\n        node.children.forEach((child, i) => {\n          traverse(child);\n          // child.index = i; // store previous child index\n          if (!Number.isNaN(child.barycenter)) {\n            node.barycenter += child.barycenter;\n            numInvolvedChildren++;\n          }\n        });\n        if (numInvolvedChildren > 0) node.barycenter /= numInvolvedChildren;\n\n        node.children.sort((a, b) => {\n          if (Number.isNaN(a.barycenter) || Number.isNaN(b.barycenter))\n            return 0;\n          if (a.barycenter == b.barycenter) return 0;\n          else return a.barycenter > b.barycenter ? 1 : -1;\n        });\n      }\n    };\n\n    traverse(tree);\n  }\n\n  __getLeafNodes() {\n    let leaves = {};\n    this.__forEachNodeDepthFirst((node, depth, t) => {\n      if (!node.children) {\n        if (!leaves[t]) leaves[t] = [];\n        leaves[t].push(node);\n      }\n    });\n    return leaves;\n  }\n\n  __getAdjacencyMatrices(leaves) {\n    let M = [];\n    for (let t in this._timesteps) {\n      let left = leaves[t];\n      let right = leaves[+t + 1];\n      if (right)\n        // skip the last timestep\n        M[t] = this.__getAdjacencyMatrix(left, right);\n    }\n    return M;\n  }\n\n  __getAdjacencyMatrix(left, right) {\n    let targetLookup = {};\n    let M = [];\n    for (let i = 0; i < left.length; i++) {\n      M[i] = Array(right.length).fill(0);\n      for (let j = 0; j < right.length; j++) targetLookup[right[j].id] = j;\n      // set edges to 1\n      if (left[i].next)\n        for (let next of left[i].next) {\n          // only if the edge goes to one of the leaf nodes\n          if (typeof M[i][targetLookup[next.id]] !== 'undefined')\n            M[i][targetLookup[next.id]] = 1;\n        }\n    }\n    return M;\n  }\n\n  // variable names match the equation given in the paper by Sugiyama et al.\n  __getNumCrossings(matrix) {\n    let crossings = 0;\n    let p = matrix.length; // row length (num of leaves in the left layer)\n    let q = matrix[0].length; // column length\n    for (let j = 0; j < p - 1; j++)\n      for (let k = j + 1; k < p; k++)\n        for (let a = 0; a < q - 1; a++)\n          for (let b = a + 1; b < q; b++)\n            crossings += matrix[j][b] * matrix[k][a];\n    return crossings;\n  }\n\n  __getBarycenterRow(matrix, row) {\n    let barycenter = 0;\n    let sum = 0;\n    let q = matrix[0].length;\n\n    for (let l = 0; l < q; l++) {\n      barycenter += (l + 1) * matrix[row][l];\n      sum += matrix[row][l];\n    }\n    return barycenter / sum; // || 0;\n  }\n\n  __getBarycenterCol(matrix, col) {\n    let barycenter = 0;\n    let sum = 0;\n    let p = matrix.length;\n\n    for (let l = 0; l < p; l++) {\n      barycenter += (l + 1) * matrix[l][col];\n      sum += matrix[l][col];\n    }\n    return barycenter / sum; //|| 0;\n  }\n\n  // sort all children of a node by their number of children\n  __sortChildrenByNumChildren() {\n    for (let t in this._timesteps) {\n      let nodes = this._timesteps[t].references;\n      for (let id in nodes) {\n        let node = nodes[id];\n        if (node.children)\n          node.children.sort((a, b) => {\n            if (a.children && b.children)\n              return a.children.length > b.children.length ? 1 : -1;\n            else if (a.children) return 1;\n            else return -1;\n          });\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3BsaXRTdHJlYW1JbnB1dERhdGEuanM/ZGZkOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQWU7QUFDZiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxNQUFNLHlDQUF5QyxHQUFHLGVBQWUsRUFBRTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEdBQUc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBOztBQUVBLHNDQUFzQyxFQUFFLElBQUksR0FBRyxNQUFNLE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLG1CQUFtQixXQUFXO0FBQzlCLHlCQUF5QixPQUFPO0FBQ2hDLHVCQUF1QixXQUFXO0FBQ2xDLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9TcGxpdFN0cmVhbUlucHV0RGF0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0U3RyZWFtSW5wdXREYXRhIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fb3B0cyA9IHtcbiAgICAgIGZvcmNlRmFrZVJvb3Q6IGZhbHNlLFxuICAgICAgb3JkZXI6IHtcbiAgICAgICAgbmFtZTogJ21pbmltaXplRWRnZUNyb3NzaW5ncycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBpdGVyYXRpb25zOiAyMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyAvLyBvdmVyd3JpdGUgZGVmYXVsdCBzZXR0aW5ncyB3aXRoIHVzZXIgc2V0dGluZ3NcbiAgICB9O1xuICAgIC8vIGhvbGQgYSB0cmVlIChyb290IG5vZGUpIGZvciBlYWNoIHRpbWVzdGVwXG4gICAgLy8gaG9sZCBhIHJlZmVyZW5jZSBhcnJheSB3aGljaCBpbmNsdWRlcyBhbGwgbm9kZXMgcHJlc2VudCBpbiBhIHNpbmdsZSB0aW1lc3RlcFxuICAgIC8vIFRPRE86IGlmIHRpbWVzdGVwcyBkbyBub3Qgc3RhcnQgd2l0aCAwLCBmb3IgLi4uIG9mIGxvb3BzIGdpdmUgYmFjayB1bmRlZmluZWQgdW50aWwgdGhlIGZpcnN0IHRpbWVzdGVwIGlzIHJlYWNoZWRcbiAgICAvLyBUT0RPOiBUaGUgcHJvYmxlbSBpcyB0aGF0IGFuIGFycmF5IGRvZXMgY29udGFpbiBhbGwgaW5iZXR3ZWVuIHZhbHVlcywgYnV0IGEgZm9yIC4uLiBpbiBsb29wIGluIGFuIG9iamVjdCBjb252ZXJ0cyBudW1iZXJzIHRvIHN0cmluZ3MgYWdhaW5cbiAgICAvLyBtYXliZSBwcm92ZSBhIG5leHRUaW1lc3RlcCBmdW5jdGlvbiBmb3IgY29udmVuaWVuY2VcbiAgICAvLyBvciBzdG9yZSB0aGUga2V5cyBmb3IgdGltZXN0ZXBzIGluIGFuIGluZGl2aWR1YWwgYXJyYXkgYW5kIHVzZSBpbnRlZ2VyIGluZGljZXMgZnJvbSAwIHRvIG4gaW50ZXJuYWxseVxuICAgIC8vIGFsc28gcmVxdWlyZXMgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gbm90IHdyaXRlICt0ICsgMSBldmVyeSB0aW1lXG4gICAgdGhpcy5fdGltZXN0ZXBzID0ge307XG4gICAgdGhpcy5fbnVtTm9kZXMgPSAwO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHsgdGltZXN0ZXBzOiB0aGlzLl90aW1lc3RlcHMsIG51bU5vZGVzOiB0aGlzLl9udW1Ob2RlcyB9O1xuICB9XG5cbiAgYWRkTm9kZSh0LCBpZCwgc2l6ZSA9IHVuZGVmaW5lZCwgcG9zID0gdW5kZWZpbmVkLCBkYXRhID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCF0aGlzLl90aW1lc3RlcHNbdF0pIHRoaXMuX2NyZWF0ZVRpbWVzdGVwKHQpO1xuXG4gICAgaWYgKCF0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlc1tpZF0pIHtcbiAgICAgIGxldCBkYXRhU2l6ZSA9ICtzaXplO1xuICAgICAgbGV0IGRhdGFQb3MgPSArcG9zO1xuICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgLy8gc2l6ZSA9ICtzaXplO1xuICAgICAgLy8gcG9zID0gK3BvcztcbiAgICAgIHRoaXMuX3RpbWVzdGVwc1t0XS5yZWZlcmVuY2VzW2lkXSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGFTaXplLFxuICAgICAgICBkYXRhUG9zLFxuICAgICAgICBzaXplLFxuICAgICAgICBwb3MsXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgICB0aGlzLl9udW1Ob2RlcysrO1xuICAgIH0gZWxzZTsgLy8gY29uc29sZS5sb2coYFdhcm5pbmcgQWRkTm9kZTogTm9kZSAke2lkfSBhdCB0aW1lc3RlcCAke3R9IGV4aXN0cyBhbHJlYWR5LmApO1xuICB9XG5cbiAgYWRkUGFyZW50KHQsIGlkLCBwSWQpIHtcbiAgICBsZXQgbm9kZXMgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlcztcbiAgICBsZXQgbm9kZSA9IG5vZGVzW2lkXTtcbiAgICBsZXQgcGFyZW50ID0gbm9kZXNbcElkXTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBFcnJvciAnYWRkUGFyZW50JzogTm9kZSAnJHtpZH0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYEVycm9yICdhZGRQYXJlbnQnOiBQYXJlbnQgbm9kZSAnJHtwSWR9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQuY2hpbGRyZW4pIHBhcmVudC5jaGlsZHJlbiA9IFtdO1xuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICB9XG5cbiAgYWRkTmV4dCh0LCBpZCwgbmV4dElkKSB7XG4gICAgbGV0IHRpbWUxID0gdGhpcy5fdGltZXN0ZXBzW3RdO1xuICAgIGxldCB0aW1lMiA9IHRoaXMuX3RpbWVzdGVwc1srdCArIDFdO1xuICAgIGlmICghdGltZTEgfHwgIXRpbWUyKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgRXJyb3IgJ2FkZE5leHQnOiBUaW1lc3RlcCAnJHsrdCArIDF9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHRpbWUxLnJlZmVyZW5jZXNbaWRdO1xuICAgIGxldCBuZXh0Tm9kZSA9IHRpbWUyLnJlZmVyZW5jZXNbbmV4dElkXTtcbiAgICBpZiAoIW5vZGUgfHwgIW5leHROb2RlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgRXJyb3IgJ2FkZE5leHQnOiBOb2RlICcke2lkfScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coYENoYW5nZSB0aW1lc3RlcCAke3R9OiAke2lkfSB0byAke25leHRJZH1gKTtcbiAgICBpZiAoIW5vZGUubmV4dCkgbm9kZS5uZXh0ID0gW107XG4gICAgbm9kZS5uZXh0LnB1c2gobmV4dE5vZGUpO1xuICAgIGlmICghbmV4dE5vZGUucHJldikgbmV4dE5vZGUucHJldiA9IFtdO1xuICAgIG5leHROb2RlLnByZXYucHVzaChub2RlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIHRoaXMuX2NoZWNrUGFyZW50cygpO1xuXG4gICAgdGhpcy5fX2ZvckVhY2hOb2RlRGVwdGhGaXJzdCgobm9kZSwgZGVwdGgsIHQpID0+IHtcbiAgICAgIG5vZGUueCA9ICt0O1xuICAgICAgbm9kZS5kZXB0aCA9IGRlcHRoO1xuICAgICAgdGhpcy5fc2V0U2l6ZUFuZEFnZ3JlZ2F0ZShub2RlKTtcbiAgICAgIHRoaXMuX2NoZWNrU2l6ZShub2RlKTtcbiAgICAgIHRoaXMuX2NoZWNrUG9zaXRpb25zKG5vZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX29wdHMub3JkZXIpXG4gICAgICBpZiAodGhpcy5fb3B0cy5vcmRlci5uYW1lID09ICdtaW5pbWl6ZUVkZ2VDcm9zc2luZ3MnKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRzLm9yZGVyLm9wdGlvbnMpXG4gICAgICAgICAgdGhpcy5taW5pbWl6ZUVkZ2VDcm9zc2luZ3ModGhpcy5fb3B0cy5vcmRlci5vcHRpb25zLml0ZXJhdGlvbnMpO1xuICAgICAgICBlbHNlIHRoaXMubWluaW1pemVFZGdlQ3Jvc3NpbmdzKCk7XG4gICAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSByb290IGhhdmUgYSBwYXJlbnRcbiAgLy8gaWYgbXVsdGlwbGUgcm9vdHMgZXhpc3QsIGNyZWF0ZSBhIGZha2Ugcm9vdFxuICBfY2hlY2tQYXJlbnRzKCkge1xuICAgIGxldCBub2Rlc1dpdGhvdXRQYXJlbnRzID0ge307XG4gICAgZm9yIChsZXQgdCBpbiB0aGlzLl90aW1lc3RlcHMpIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMuX3RpbWVzdGVwc1t0XS5yZWZlcmVuY2VzO1xuICAgICAgZm9yIChsZXQgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpZF07XG4gICAgICAgIGlmICghbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIW5vZGVzV2l0aG91dFBhcmVudHNbdF0pIG5vZGVzV2l0aG91dFBhcmVudHNbdF0gPSBbXTtcbiAgICAgICAgICBub2Rlc1dpdGhvdXRQYXJlbnRzW3RdLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZmFrZVJvb3ROZWVkZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB0IGluIG5vZGVzV2l0aG91dFBhcmVudHMpIHtcbiAgICAgIGlmIChub2Rlc1dpdGhvdXRQYXJlbnRzW3RdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZmFrZVJvb3ROZWVkZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFrZVJvb3ROZWVkZWQgfHwgdGhpcy5fb3B0cy5mb3JjZUZha2VSb290KSB7XG4gICAgICBsZXQgcHJldlQ7XG4gICAgICBmb3IgKGxldCB0IGluIG5vZGVzV2l0aG91dFBhcmVudHMpIHtcbiAgICAgICAgdGhpcy5hZGROb2RlKHQsICdmYWtlUm9vdCcpO1xuICAgICAgICBub2Rlc1dpdGhvdXRQYXJlbnRzW3RdLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRQYXJlbnQodCwgbm9kZS5pZCwgJ2Zha2VSb290Jyk7XG4gICAgICAgICAgdGhpcy5fdGltZXN0ZXBzW3RdLnRyZWUgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlc1snZmFrZVJvb3QnXTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbm5lY3QgZmFrZSByb290c1xuICAgICAgICBpZiAoISFwcmV2VCkge1xuICAgICAgICAgIHRoaXMuYWRkTmV4dChwcmV2VCwgJ2Zha2VSb290JywgJ2Zha2VSb290Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlQgPSB0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBldmVyeSB0aW1lcG9pbnQgaGFzIGEgc2luZ2xlIHJvb3Qgbm9kZVxuICAgICAgZm9yIChsZXQgdCBpbiBub2Rlc1dpdGhvdXRQYXJlbnRzKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlID0gbm9kZXNXaXRob3V0UGFyZW50c1t0XVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBub2RlIGRvZXMgbm90IGhhdmUgYSBzaXplLCBzZXQgaXQncyBzaXplIHRvIHRoZSBzdW0gb2YgdGhlIHNpemVzIG9mIGl0cyBjaGlsZHJlblxuICAvLyBpZiBhIG5vZGUgZG9lcyBub3QgaGF2ZSBhIHNpemUgYW5kIGRvZXMgbm90IGhhdmUgY2hpbGRyZW4sIGdpdmUgaXQgc2l6ZSAxXG4gIF9zZXRTaXplQW5kQWdncmVnYXRlKG5vZGUpIHtcbiAgICBpZiAoISFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmFnZ3JlZ2F0ZSA9IDA7XG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSBub2RlLmFnZ3JlZ2F0ZSArPSBjaGlsZC5kYXRhU2l6ZTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4obm9kZS5kYXRhU2l6ZSkpIG5vZGUuZGF0YVNpemUgPSBub2RlLmFnZ3JlZ2F0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE51bWJlci5pc05hTihub2RlLmRhdGFTaXplKSkgbm9kZS5kYXRhU2l6ZSA9IDE7XG4gICAgICBub2RlLmFnZ3JlZ2F0ZSA9IG5vZGUuZGF0YVNpemU7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrU2l6ZShub2RlKSB7XG4gICAgaWYgKG5vZGUuZGF0YVNpemUgPCBub2RlLmFnZ3JlZ2F0ZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ0Vycm9yOiBOb2RlIGhhcyBhIHNtYWxsZXIgc2l6ZSB0aGFuIGl0cyBjaGlsZHJlbi4nKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHNpemUgb2YgcGFyZW50IGVsZW1lbnRzIGlzIGJpZ2dlciB0aGFuIHRoZSBhZ2dyZWdhdGUgb2YgdGhlIHNpemVzIG9mIGl0cyBjaGlsZHJlblxuICBfY2hlY2tQb3NpdGlvbnMobm9kZSkge1xuICAgIGlmICghIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGxldCBtaW5Qb3MgPSAwO1xuICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQucG9zID49IDApIHtcbiAgICAgICAgICBpZiAobWluUG9zID4gY2hpbGQucG9zKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRXJyb3I6IENoaWxkcmVuIHBvc2l0aW9ucyBvdmVybGFwIGVhY2ggb3RoZXIuJyk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWluUG9zID0gY2hpbGQucG9zICsgY2hpbGQuZGF0YVNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2ZvckVhY2hOb2RlRGVwdGhGaXJzdChjYWxsYmFjaykge1xuICAgIGxldCB0cmF2ZXJzZSA9IGZ1bmN0aW9uKG5vZGUsIGRlcHRoLCB0KSB7XG4gICAgICBpZiAoISFub2RlLmNoaWxkcmVuKVxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdHJhdmVyc2UoY2hpbGQsIGRlcHRoICsgMSwgdCkpO1xuICAgICAgY2FsbGJhY2sobm9kZSwgZGVwdGgsIHQpO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCB0IGluIHRoaXMuX3RpbWVzdGVwcykgdHJhdmVyc2UodGhpcy5fdGltZXN0ZXBzW3RdLnRyZWUsIDAsIHQpO1xuICB9XG5cbiAgX2NyZWF0ZVRpbWVzdGVwKHQpIHtcbiAgICB0aGlzLl90aW1lc3RlcHNbdF0gPSB7XG4gICAgICByZWZlcmVuY2VzOiB7fSxcbiAgICAgIHRyZWU6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLy8gY29ubmVjdCBub2RlcyB3aGljaCBoYXZlIHRoZSBzYW1lIElEIGluIGNvbnNlY3V0aXZlIHRpbWVzdGVwc1xuICBjb25uZWN0RXF1YWxJZHMoKSB7XG4gICAgZm9yIChsZXQgdCBpbiB0aGlzLl90aW1lc3RlcHMpIHtcbiAgICAgIGlmICghIXRoaXMuX3RpbWVzdGVwc1srdCArIDFdKSB7XG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuX3RpbWVzdGVwc1t0XS5yZWZlcmVuY2VzO1xuICAgICAgICBsZXQgbm9kZXMyID0gdGhpcy5fdGltZXN0ZXBzWyt0ICsgMV0ucmVmZXJlbmNlcztcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgICBpZiAoISFub2RlczJbaWRdKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgYnVpbGQgY29ubmVjdGlvbnMgaWYgdGhlIG5vZGVzIG5leHQgZWxlbWVudHMgd2VyZSBtYW51YWxseSBzZXRcbiAgICAgICAgICAgIGlmICghbm9kZXNbaWRdLm5leHQpIG5vZGVzW2lkXS5uZXh0ID0gW107XG4gICAgICAgICAgICBpZiAoIW5vZGVzMltpZF0ucHJldikgbm9kZXMyW2lkXS5wcmV2ID0gW107XG5cbiAgICAgICAgICAgIG5vZGVzW2lkXS5uZXh0LnB1c2gobm9kZXMyW2lkXSk7XG4gICAgICAgICAgICBub2RlczJbaWRdLnByZXYucHVzaChub2Rlc1tpZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvbGxvd2luZyB0aGUgYWxnb3JpdGhtIGJ5IFNoaXhpYSBMaXUgZXQgYWwuIGluIFN0b3J5RmxvdywgYmFzZWQgb25cbiAgLy8gTWV0aG9kcyBmb3IgVmlzdWFsIFVuZGVyc3RhbmRpbmcgb2YgSGllcmFyY2hpY2FsIFN5c3RlbSBTdHJ1Y3R1cmVzIGJ5IFN1Z2l5YW1hIGV0IGFsLlxuICBtaW5pbWl6ZUVkZ2VDcm9zc2luZ3MoaXRlcmF0aW9ucyA9IDIwKSB7XG4gICAgLy8gY3JlYXRlIHQtMSBhZGphY2VuY3kgbWF0cmljZXMgZm9yIGxlYXZlIG5vZGVzXG4gICAgbGV0IGxlYXZlcyA9IHRoaXMuX19nZXRMZWFmTm9kZXMoKTtcbiAgICBsZXQgTSA9IHRoaXMuX19nZXRBZGphY2VuY3lNYXRyaWNlcyhsZWF2ZXMpO1xuICAgIGxldCB0aW1lc3RlcHMgPSBPYmplY3Qua2V5cyh0aGlzLl90aW1lc3RlcHMpO1xuXG4gICAgbGV0IGNhbGN1bGF0ZUJhcnljZW50ZXJDb2xzID0gdCA9PiB7XG4gICAgICBmb3IgKGxldCBsIGluIGxlYXZlc1t0XSlcbiAgICAgICAgbGVhdmVzW3RdW2xdLmJhcnljZW50ZXIgPSB0aGlzLl9fZ2V0QmFyeWNlbnRlckNvbChNW3QgLSAxXSwgbCk7XG4gICAgfTtcblxuICAgIGxldCBjYWxjdWxhdGVCYXJ5Y2VudGVyUm93cyA9IHQgPT4ge1xuICAgICAgZm9yIChsZXQgbCBpbiBsZWF2ZXNbdF0pXG4gICAgICAgIGxlYXZlc1t0XVtsXS5iYXJ5Y2VudGVyID0gdGhpcy5fX2dldEJhcnljZW50ZXJSb3coTVt0XSwgbCk7XG4gICAgfTtcblxuICAgIGxldCByZW9yZGVyID0gdCA9PiB7XG4gICAgICB0aGlzLl9fb3JkZXJCeUJhcnljZW50ZXIodGhpcy5fdGltZXN0ZXBzW3RdLnRyZWUpO1xuICAgICAgbGV0IG5ld09yZGVyID0gdGhpcy5fX2dldE5ld09yZGVyKHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlKTtcbiAgICAgIGFwcGx5T3JkZXIodCwgbmV3T3JkZXIpO1xuICAgIH07XG5cbiAgICBsZXQgYXBwbHlPcmRlciA9ICh0LCBvcmRlcikgPT4ge1xuICAgICAgLy8gcmVvcmRlciBtYXRyaXggcm93c1xuICAgICAgaWYgKE1bdF0pIE1bdF0gPSBvcmRlci5tYXAoaSA9PiBNW3RdW2ldKTtcbiAgICAgIC8vIHJlb3JkZXIgc2FtZSBub2RlcyBpbiBwcmV2aW91cyBtYXRyaXggY29sdW1uc1xuICAgICAgaWYgKE1bdCAtIDFdKVxuICAgICAgICBNW3QgLSAxXS5mb3JFYWNoKChyb3csIGkpID0+IChNW3QgLSAxXVtpXSA9IG9yZGVyLm1hcChpID0+IHJvd1tpXSkpKTtcbiAgICAgIC8vIHJlb3JkZXIgbGVhZiBhcnJheVxuICAgICAgbGVhdmVzW3RdID0gb3JkZXIubWFwKGkgPT4gbGVhdmVzW3RdW2ldKTtcbiAgICB9O1xuXG4gICAgLy9zd2VlcCByaWdodCwgcmVvcmRlciBjb2x1bW5zIGJhc2VkIG9uIGJhcnljZW50ZXJzXG4gICAgbGV0IHBoYXNlMURvd24gPSAoKSA9PiB7XG4gICAgICBmb3IgKGxldCB0SWQgPSAxOyB0SWQgPCB0aW1lc3RlcHMubGVuZ3RoOyB0SWQrKykge1xuICAgICAgICBsZXQgdCA9IHRpbWVzdGVwc1t0SWRdO1xuICAgICAgICBjYWxjdWxhdGVCYXJ5Y2VudGVyQ29scyh0KTtcbiAgICAgICAgcmVvcmRlcih0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3dlZXAgbGVmdCwgcmVvcmRlciByb3dzXG4gICAgbGV0IHBoYXNlMVVwID0gKCkgPT4ge1xuICAgICAgZm9yIChsZXQgdElkID0gdGltZXN0ZXBzLmxlbmd0aCAtIDI7IHRJZCA+PSAwOyB0SWQtLSkge1xuICAgICAgICBsZXQgdCA9IHRpbWVzdGVwc1t0SWRdO1xuICAgICAgICBjYWxjdWxhdGVCYXJ5Y2VudGVyUm93cyh0KTtcbiAgICAgICAgcmVvcmRlcih0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3dlZXAgcmlnaHQsIHJldmVyc2Ugb3JkZXIgb2Ygbm9kZXMgd2l0aCBlcXVhbCBiYXJ5Y2VudGVyXG4gICAgbGV0IHBoYXNlMkRvd24gPSAoKSA9PiB7XG4gICAgICBmb3IgKGxldCB0SWQgPSAxOyB0SWQgPCB0aW1lc3RlcHMubGVuZ3RoOyB0SWQrKykge1xuICAgICAgICBsZXQgdCA9IHRpbWVzdGVwc1t0SWRdO1xuICAgICAgICBjYWxjdWxhdGVCYXJ5Y2VudGVyQ29scyh0KTtcbiAgICAgICAgdGhpcy5fX3JldmVyc2VFcXVhbEJhcnljZW50ZXJzKHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlKTtcbiAgICAgICAgbGV0IG5ld09yZGVyID0gdGhpcy5fX2dldE5ld09yZGVyKHRoaXMuX3RpbWVzdGVwc1t0XS50cmVlKTtcbiAgICAgICAgYXBwbHlPcmRlcih0LCBuZXdPcmRlcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxldCBwaGFzZTJVcCA9ICgpID0+IHtcbiAgICAgIGZvciAobGV0IHRJZCA9IHRpbWVzdGVwcy5sZW5ndGggLSAyOyB0SWQgPj0gMDsgdElkLS0pIHtcbiAgICAgICAgbGV0IHQgPSB0aW1lc3RlcHNbdElkXTtcbiAgICAgICAgY2FsY3VsYXRlQmFyeWNlbnRlclJvd3ModCk7XG4gICAgICAgIHRoaXMuX19yZXZlcnNlRXF1YWxCYXJ5Y2VudGVycyh0aGlzLl90aW1lc3RlcHNbdF0udHJlZSk7XG4gICAgICAgIGxldCBuZXdPcmRlciA9IHRoaXMuX19nZXROZXdPcmRlcih0aGlzLl90aW1lc3RlcHNbdF0udHJlZSk7XG4gICAgICAgIGFwcGx5T3JkZXIodCwgbmV3T3JkZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgaWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgcGhhc2UxRG93bigpO1xuICAgICAgICBwaGFzZTJEb3duKCk7XG4gICAgICAgIHBoYXNlMlVwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaGFzZTFVcCgpO1xuICAgICAgICBwaGFzZTJVcCgpO1xuICAgICAgICBwaGFzZTJEb3duKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHN0b3AgaWYgYWxsIHJvd3MgYW5kIGNvbHVtbnMgYXJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBubyBvcmRlciBjaGFuZ2VkIGluIGFuIGl0ZXJhdGlvblxuICAgIH1cbiAgfVxuXG4gIC8vIHRha2VzIGFuIGFycmF5IG9mIGJhcnljZW50ZXIgdmFsdWVzIGFzIGlucHV0XG4gIC8vIG91dHB1dHMgYW4gYXJyYXkgb2YgbmV3IGluZGljZXMsIHdoZXJlIGVsZW1lbnRzIHdpdGggZXF1YWwgdmFsdWVzIGFyZSByZXZlcnNlZFxuICBfX3JldmVyc2VJbmRpY2VzT2ZFcXVhbFZhbHVlcyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAvLyBjcmVhdGUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgZm9yIGVhY2ggdmFsdWUgYW4gYXJyYXkgb2YgaW5kaWNlcyB0aGF0IGhhdmUgdGhpcyB2YWx1ZVxuICAgIGxldCBlcXVhbHMgPSB7fTtcbiAgICBhcnJheS5mb3JFYWNoKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgaWYgKCFlcXVhbHNbdmFsXSkgZXF1YWxzW3ZhbF0gPSBbXTtcbiAgICAgIGVxdWFsc1t2YWxdLnB1c2goaWR4KTtcbiAgICB9KTtcbiAgICAvLyBmb3IgZWFjaCB2YWx1ZSByZXZlcnNlIHRoZSBpbmRleCBvcmRlclxuICAgIGZvciAobGV0IHZhbCBpbiBlcXVhbHMpIHtcbiAgICAgIGxldCBpbmRpY2VzID0gZXF1YWxzW3ZhbF07XG4gICAgICBpbmRpY2VzLmZvckVhY2goKGlkeCwgaSkgPT4ge1xuICAgICAgICByZXN1bHRbaWR4XSA9IGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSBpIC0gMV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9fcmV2ZXJzZUVxdWFsQmFyeWNlbnRlcnModHJlZSkge1xuICAgIGxldCBudW1MZWF2ZXMgPSAwO1xuICAgIGxldCB0cmF2ZXJzZSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSBub2RlLmJjTWF0cml4UG9zaXRpb24gPSBudW1MZWF2ZXMrKztcbiAgICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gdHJhdmVyc2UoY2hpbGQpKTtcbiAgICAgICAgLy8gZXh0cmFjdCBhbiBhcnJheSBvZiBiYXJ5Y2VudGVycyBpbiBvcmRlclxuICAgICAgICBsZXQgYmFyeWNlbnRlckFycmF5ID0gbm9kZS5jaGlsZHJlbi5tYXAoZCA9PiBkLmJhcnljZW50ZXIpO1xuICAgICAgICAvLyByZXZlcnNlIHRoZSBvcmRlciBvZiBlcXVhbCBiYXJ5Y2VudGVyc1xuICAgICAgICBsZXQgbmV3T3JkZXIgPSB0aGlzLl9fcmV2ZXJzZUluZGljZXNPZkVxdWFsVmFsdWVzKGJhcnljZW50ZXJBcnJheSk7XG4gICAgICAgIC8vIHJlb3JkZXIgY2hpbGRyZW5cbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ld09yZGVyLm1hcChpZHggPT4gbm9kZS5jaGlsZHJlbltpZHhdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyYXZlcnNlKHRyZWUpO1xuICB9XG5cbiAgX19nZXROZXdPcmRlcih0cmVlKSB7XG4gICAgbGV0IG9yZGVyID0gW107XG4gICAgbGV0IG5ld0xlYWZPcmRlciA9IG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBuZXdMZWFmT3JkZXIoY2hpbGQpKTtcbiAgICAgIGVsc2Ugb3JkZXIucHVzaChub2RlLmJjTWF0cml4UG9zaXRpb24pO1xuICAgIH07XG4gICAgbmV3TGVhZk9yZGVyKHRyZWUpO1xuICAgIHJldHVybiBvcmRlcjtcbiAgfVxuXG4gIC8vIGJjTWF0cml4UmFuZ2UgZGVmaW5lcyB0aGUgYXJlYSBvZiB0aGUgYWRqYWNlbmN5IG1hdHJpeCBpbiB3aGljaCB0aGUgbm9kZSBoYXMgaW5mbHVlbmNlXG4gIC8vIHRoaXMgaXMgbmVjZXNhc3J5IGJlY2F1c2Ugb2YgaGllcmFyY2h5IG5vZGVzIHRoYXQgc3BhbiBhIHdpZGVyIHJhbmdlXG4gIF9fb3JkZXJCeUJhcnljZW50ZXIodHJlZSkge1xuICAgIGxldCBudW1MZWF2ZXMgPSAwO1xuICAgIGxldCB0cmF2ZXJzZSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSBub2RlLmJjTWF0cml4UG9zaXRpb24gPSBudW1MZWF2ZXMrKztcbiAgICAgIGVsc2Uge1xuICAgICAgICBub2RlLmJhcnljZW50ZXIgPSAwOyAvLyBoaWVyYXJjaHkgbm9kZXMgZ2V0IHRoZSBhdmVyYWdlIG9mIHRoZWlyIGNoaWxkcmVucycgYmFyeWNlbnRlclxuICAgICAgICBsZXQgbnVtSW52b2x2ZWRDaGlsZHJlbiA9IDA7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICB0cmF2ZXJzZShjaGlsZCk7XG4gICAgICAgICAgLy8gY2hpbGQuaW5kZXggPSBpOyAvLyBzdG9yZSBwcmV2aW91cyBjaGlsZCBpbmRleFxuICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGNoaWxkLmJhcnljZW50ZXIpKSB7XG4gICAgICAgICAgICBub2RlLmJhcnljZW50ZXIgKz0gY2hpbGQuYmFyeWNlbnRlcjtcbiAgICAgICAgICAgIG51bUludm9sdmVkQ2hpbGRyZW4rKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobnVtSW52b2x2ZWRDaGlsZHJlbiA+IDApIG5vZGUuYmFyeWNlbnRlciAvPSBudW1JbnZvbHZlZENoaWxkcmVuO1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYS5iYXJ5Y2VudGVyKSB8fCBOdW1iZXIuaXNOYU4oYi5iYXJ5Y2VudGVyKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIGlmIChhLmJhcnljZW50ZXIgPT0gYi5iYXJ5Y2VudGVyKSByZXR1cm4gMDtcbiAgICAgICAgICBlbHNlIHJldHVybiBhLmJhcnljZW50ZXIgPiBiLmJhcnljZW50ZXIgPyAxIDogLTE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmF2ZXJzZSh0cmVlKTtcbiAgfVxuXG4gIF9fZ2V0TGVhZk5vZGVzKCkge1xuICAgIGxldCBsZWF2ZXMgPSB7fTtcbiAgICB0aGlzLl9fZm9yRWFjaE5vZGVEZXB0aEZpcnN0KChub2RlLCBkZXB0aCwgdCkgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbGVhdmVzW3RdKSBsZWF2ZXNbdF0gPSBbXTtcbiAgICAgICAgbGVhdmVzW3RdLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxuXG4gIF9fZ2V0QWRqYWNlbmN5TWF0cmljZXMobGVhdmVzKSB7XG4gICAgbGV0IE0gPSBbXTtcbiAgICBmb3IgKGxldCB0IGluIHRoaXMuX3RpbWVzdGVwcykge1xuICAgICAgbGV0IGxlZnQgPSBsZWF2ZXNbdF07XG4gICAgICBsZXQgcmlnaHQgPSBsZWF2ZXNbK3QgKyAxXTtcbiAgICAgIGlmIChyaWdodClcbiAgICAgICAgLy8gc2tpcCB0aGUgbGFzdCB0aW1lc3RlcFxuICAgICAgICBNW3RdID0gdGhpcy5fX2dldEFkamFjZW5jeU1hdHJpeChsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBNO1xuICB9XG5cbiAgX19nZXRBZGphY2VuY3lNYXRyaXgobGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgdGFyZ2V0TG9va3VwID0ge307XG4gICAgbGV0IE0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIE1baV0gPSBBcnJheShyaWdodC5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJpZ2h0Lmxlbmd0aDsgaisrKSB0YXJnZXRMb29rdXBbcmlnaHRbal0uaWRdID0gajtcbiAgICAgIC8vIHNldCBlZGdlcyB0byAxXG4gICAgICBpZiAobGVmdFtpXS5uZXh0KVxuICAgICAgICBmb3IgKGxldCBuZXh0IG9mIGxlZnRbaV0ubmV4dCkge1xuICAgICAgICAgIC8vIG9ubHkgaWYgdGhlIGVkZ2UgZ29lcyB0byBvbmUgb2YgdGhlIGxlYWYgbm9kZXNcbiAgICAgICAgICBpZiAodHlwZW9mIE1baV1bdGFyZ2V0TG9va3VwW25leHQuaWRdXSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBNW2ldW3RhcmdldExvb2t1cFtuZXh0LmlkXV0gPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNO1xuICB9XG5cbiAgLy8gdmFyaWFibGUgbmFtZXMgbWF0Y2ggdGhlIGVxdWF0aW9uIGdpdmVuIGluIHRoZSBwYXBlciBieSBTdWdpeWFtYSBldCBhbC5cbiAgX19nZXROdW1Dcm9zc2luZ3MobWF0cml4KSB7XG4gICAgbGV0IGNyb3NzaW5ncyA9IDA7XG4gICAgbGV0IHAgPSBtYXRyaXgubGVuZ3RoOyAvLyByb3cgbGVuZ3RoIChudW0gb2YgbGVhdmVzIGluIHRoZSBsZWZ0IGxheWVyKVxuICAgIGxldCBxID0gbWF0cml4WzBdLmxlbmd0aDsgLy8gY29sdW1uIGxlbmd0aFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcCAtIDE7IGorKylcbiAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IHA7IGsrKylcbiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBxIC0gMTsgYSsrKVxuICAgICAgICAgIGZvciAobGV0IGIgPSBhICsgMTsgYiA8IHE7IGIrKylcbiAgICAgICAgICAgIGNyb3NzaW5ncyArPSBtYXRyaXhbal1bYl0gKiBtYXRyaXhba11bYV07XG4gICAgcmV0dXJuIGNyb3NzaW5ncztcbiAgfVxuXG4gIF9fZ2V0QmFyeWNlbnRlclJvdyhtYXRyaXgsIHJvdykge1xuICAgIGxldCBiYXJ5Y2VudGVyID0gMDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgcSA9IG1hdHJpeFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IHE7IGwrKykge1xuICAgICAgYmFyeWNlbnRlciArPSAobCArIDEpICogbWF0cml4W3Jvd11bbF07XG4gICAgICBzdW0gKz0gbWF0cml4W3Jvd11bbF07XG4gICAgfVxuICAgIHJldHVybiBiYXJ5Y2VudGVyIC8gc3VtOyAvLyB8fCAwO1xuICB9XG5cbiAgX19nZXRCYXJ5Y2VudGVyQ29sKG1hdHJpeCwgY29sKSB7XG4gICAgbGV0IGJhcnljZW50ZXIgPSAwO1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBwID0gbWF0cml4Lmxlbmd0aDtcblxuICAgIGZvciAobGV0IGwgPSAwOyBsIDwgcDsgbCsrKSB7XG4gICAgICBiYXJ5Y2VudGVyICs9IChsICsgMSkgKiBtYXRyaXhbbF1bY29sXTtcbiAgICAgIHN1bSArPSBtYXRyaXhbbF1bY29sXTtcbiAgICB9XG4gICAgcmV0dXJuIGJhcnljZW50ZXIgLyBzdW07IC8vfHwgMDtcbiAgfVxuXG4gIC8vIHNvcnQgYWxsIGNoaWxkcmVuIG9mIGEgbm9kZSBieSB0aGVpciBudW1iZXIgb2YgY2hpbGRyZW5cbiAgX19zb3J0Q2hpbGRyZW5CeU51bUNoaWxkcmVuKCkge1xuICAgIGZvciAobGV0IHQgaW4gdGhpcy5fdGltZXN0ZXBzKSB7XG4gICAgICBsZXQgbm9kZXMgPSB0aGlzLl90aW1lc3RlcHNbdF0ucmVmZXJlbmNlcztcbiAgICAgIGZvciAobGV0IGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaWRdO1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbilcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLmNoaWxkcmVuICYmIGIuY2hpbGRyZW4pXG4gICAgICAgICAgICAgIHJldHVybiBhLmNoaWxkcmVuLmxlbmd0aCA+IGIuY2hpbGRyZW4ubGVuZ3RoID8gMSA6IC0xO1xuICAgICAgICAgICAgZWxzZSBpZiAoYS5jaGlsZHJlbikgcmV0dXJuIDE7XG4gICAgICAgICAgICBlbHNlIHJldHVybiAtMTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SplitStreamInputData.js\n"
          );

          /***/
        },

      /***/ './src/SvgPath.js':
        /*!************************!*\
  !*** ./src/SvgPath.js ***!
  \************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SvgPath; });\nconst ACTION = {\n  MOVE: 0,\n  MOVE_D: 1,\n  LINE: 2,\n  LINE_D: 3,\n  HORIZONTAL: 4,\n  HORIZONTAL_D: 5,\n  VERTICAL: 6,\n  VERTICAL_D: 7,\n  BEZIER: 8,\n  BEZIER_D: 9,\n  ARC: 10\n};\n\nclass SvgPath {\n  constructor() {\n    this._path = '';\n    this._x;\n    this._y;\n    this._precision = 2;\n    this._lastAction;\n  }\n\n  // ignore a change, if its end coordinate is the same as its current position\n  _pathWillChange(x, y) {\n    if (Number.isNaN(x) || Number.isNaN(y)); //debugger;\n    if (x !== this._x || y !== this._y) {\n      this._x = x;\n      this._y = y;\n      return true;\n    }\n    return false;\n  }\n\n  _applyPrecision(...numbers) {\n    return numbers.map(d => +d.toFixed(this._precision));\n  }\n\n  get() {\n    return this._path;\n  }\n\n  move(x, y) {\n    [x, y] = this._applyPrecision(x, y);\n    if (this._pathWillChange(x, y)) {\n      if (this._lastAction == ACTION.MOVE)\n        // remove last move from string\n        this._path = this._path.slice(0, this._path.lastIndexOf('M'));\n      this._path += 'M ' + x + ' ' + y + ' ';\n      this._lastAction = ACTION.MOVE;\n    }\n  }\n\n  moveD(dx, dy) {\n    [dx, dy] = this._applyPrecision(dx, dy);\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\n      this._path += 'm ' + dx + ' ' + dy + ' ';\n      this._lastAction = ACTION.MOVE_D;\n    }\n  }\n\n  line(x, y) {\n    [x, y] = this._applyPrecision(x, y);\n    if (this._pathWillChange(x, y)) {\n      this._path += 'L ' + x + ' ' + y + ' ';\n      this._lastAction = ACTION.LINE;\n    }\n  }\n\n  lineD(dx, dy) {\n    [dx, dy] = this._applyPrecision(dx, dy);\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\n      this._path += 'l ' + dx + ' ' + dy + ' ';\n      this._lastAction = ACTION.LINE_D;\n    }\n  }\n\n  horizontal(x) {\n    [x] = this._applyPrecision(x);\n    if (this._pathWillChange(x, this._y)) {\n      if (this._lastAction == ACTION.HORIZONTAL)\n        // remove last move from string\n        this._path = this._path.slice(0, this._path.lastIndexOf('H'));\n      this._path += 'H ' + x + ' ';\n      this._lastAction = ACTION.HORIZONTAL;\n    }\n  }\n\n  horizontalD(dx) {\n    [dx] = this._applyPrecision(dx);\n    if (this._pathWillChange(this._x + dx, this._y)) {\n      this._path += 'h ' + dx + ' ';\n      this._lastAction = ACTION.HORIZONTAL_D;\n    }\n  }\n\n  vertical(y) {\n    [y] = this._applyPrecision(y);\n    if (this._pathWillChange(this._x, y)) {\n      if (this._lastAction == ACTION.VERTICAL)\n        // remove last move from string\n        this._path = this._path.slice(0, this._path.lastIndexOf('V'));\n      this._path += 'V ' + y + ' ';\n      this._lastAction = ACTION.VERTICAL;\n    }\n  }\n\n  verticalD(dy) {\n    [dy] = this._applyPrecision(dy);\n    if (this._pathWillChange(this._x, this._y + dy)) {\n      this._path += 'v ' + dy + ' ';\n      this._lastAction = ACTION.VERTICAL_D;\n    }\n  }\n\n  bezier(x1, y1, x2, y2, x, y) {\n    [x1, y1, x2, y2, x, y] = this._applyPrecision(x1, y1, x2, y2, x, y);\n    if (this._pathWillChange(x, y)) {\n      this._path +=\n        'C ' + x1 + ' ' + y1 + ', ' + x2 + ' ' + y2 + ', ' + x + ' ' + y + ' ';\n      this._lastAction = ACTION.BEZIER;\n    }\n  }\n\n  bezierD(dx1, dy1, dx2, dy2, dx, dy) {\n    [dx1, dy1, dx2, dy2, dx, dy] = this._applyPrecision(\n      dx1,\n      dy1,\n      dx2,\n      dy2,\n      dx,\n      dy\n    );\n    if (this._pathWillChange(this._x + dx, this._y + dy)) {\n      this._path +=\n        'c ' +\n        dx1 +\n        ' ' +\n        dy1 +\n        ', ' +\n        dx2 +\n        ' ' +\n        dy2 +\n        ', ' +\n        dx +\n        ' ' +\n        dy +\n        ' ';\n      this._lastAction = ACTION.BEZIER_D;\n    }\n  }\n\n  arc(rx, ry, rot, largeArcFlag, sweepFlag, x, y) {\n    [rx, ry, rot, largeArcFlag, sweepFlag, x, y] = this._applyPrecision(\n      rx,\n      ry,\n      rot,\n      largeArcFlag,\n      sweepFlag,\n      x,\n      y\n    );\n    if (this._pathWillChange(x, y)) {\n      this._path +=\n        'A ' +\n        rx +\n        ' ' +\n        ry +\n        ' ' +\n        rot +\n        ' ' +\n        largeArcFlag +\n        ' ' +\n        sweepFlag +\n        ' ' +\n        x +\n        ' ' +\n        y +\n        ' ';\n      this._lastAction = ACTION.ARC;\n    }\n  }\n\n  close() {\n    this._path += 'Z';\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvU3ZnUGF0aC5qcz9jYzc1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvU3ZnUGF0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEFDVElPTiA9IHtcbiAgTU9WRTogMCxcbiAgTU9WRV9EOiAxLFxuICBMSU5FOiAyLFxuICBMSU5FX0Q6IDMsXG4gIEhPUklaT05UQUw6IDQsXG4gIEhPUklaT05UQUxfRDogNSxcbiAgVkVSVElDQUw6IDYsXG4gIFZFUlRJQ0FMX0Q6IDcsXG4gIEJFWklFUjogOCxcbiAgQkVaSUVSX0Q6IDksXG4gIEFSQzogMTBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN2Z1BhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXRoID0gJyc7XG4gICAgdGhpcy5feDtcbiAgICB0aGlzLl95O1xuICAgIHRoaXMuX3ByZWNpc2lvbiA9IDI7XG4gICAgdGhpcy5fbGFzdEFjdGlvbjtcbiAgfVxuXG4gIC8vIGlnbm9yZSBhIGNoYW5nZSwgaWYgaXRzIGVuZCBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIGl0cyBjdXJyZW50IHBvc2l0aW9uXG4gIF9wYXRoV2lsbENoYW5nZSh4LCB5KSB7XG4gICAgaWYgKE51bWJlci5pc05hTih4KSB8fCBOdW1iZXIuaXNOYU4oeSkpOyAvL2RlYnVnZ2VyO1xuICAgIGlmICh4ICE9PSB0aGlzLl94IHx8IHkgIT09IHRoaXMuX3kpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX2FwcGx5UHJlY2lzaW9uKC4uLm51bWJlcnMpIHtcbiAgICByZXR1cm4gbnVtYmVycy5tYXAoZCA9PiArZC50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbikpO1xuICB9XG5cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICB9XG5cbiAgbW92ZSh4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeCwgeSk7XG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHgsIHkpKSB7XG4gICAgICBpZiAodGhpcy5fbGFzdEFjdGlvbiA9PSBBQ1RJT04uTU9WRSlcbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgbW92ZSBmcm9tIHN0cmluZ1xuICAgICAgICB0aGlzLl9wYXRoID0gdGhpcy5fcGF0aC5zbGljZSgwLCB0aGlzLl9wYXRoLmxhc3RJbmRleE9mKCdNJykpO1xuICAgICAgdGhpcy5fcGF0aCArPSAnTSAnICsgeCArICcgJyArIHkgKyAnICc7XG4gICAgICB0aGlzLl9sYXN0QWN0aW9uID0gQUNUSU9OLk1PVkU7XG4gICAgfVxuICB9XG5cbiAgbW92ZUQoZHgsIGR5KSB7XG4gICAgW2R4LCBkeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihkeCwgZHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94ICsgZHgsIHRoaXMuX3kgKyBkeSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz0gJ20gJyArIGR4ICsgJyAnICsgZHkgKyAnICc7XG4gICAgICB0aGlzLl9sYXN0QWN0aW9uID0gQUNUSU9OLk1PVkVfRDtcbiAgICB9XG4gIH1cblxuICBsaW5lKHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbih4LCB5KTtcbiAgICBpZiAodGhpcy5fcGF0aFdpbGxDaGFuZ2UoeCwgeSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz0gJ0wgJyArIHggKyAnICcgKyB5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5MSU5FO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVEKGR4LCBkeSkge1xuICAgIFtkeCwgZHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oZHgsIGR5KTtcbiAgICBpZiAodGhpcy5fcGF0aFdpbGxDaGFuZ2UodGhpcy5feCArIGR4LCB0aGlzLl95ICsgZHkpKSB7XG4gICAgICB0aGlzLl9wYXRoICs9ICdsICcgKyBkeCArICcgJyArIGR5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5MSU5FX0Q7XG4gICAgfVxuICB9XG5cbiAgaG9yaXpvbnRhbCh4KSB7XG4gICAgW3hdID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeCk7XG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHgsIHRoaXMuX3kpKSB7XG4gICAgICBpZiAodGhpcy5fbGFzdEFjdGlvbiA9PSBBQ1RJT04uSE9SSVpPTlRBTClcbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgbW92ZSBmcm9tIHN0cmluZ1xuICAgICAgICB0aGlzLl9wYXRoID0gdGhpcy5fcGF0aC5zbGljZSgwLCB0aGlzLl9wYXRoLmxhc3RJbmRleE9mKCdIJykpO1xuICAgICAgdGhpcy5fcGF0aCArPSAnSCAnICsgeCArICcgJztcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uSE9SSVpPTlRBTDtcbiAgICB9XG4gIH1cblxuICBob3Jpem9udGFsRChkeCkge1xuICAgIFtkeF0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihkeCk7XG4gICAgaWYgKHRoaXMuX3BhdGhXaWxsQ2hhbmdlKHRoaXMuX3ggKyBkeCwgdGhpcy5feSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz0gJ2ggJyArIGR4ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5IT1JJWk9OVEFMX0Q7XG4gICAgfVxuICB9XG5cbiAgdmVydGljYWwoeSkge1xuICAgIFt5XSA9IHRoaXMuX2FwcGx5UHJlY2lzaW9uKHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94LCB5KSkge1xuICAgICAgaWYgKHRoaXMuX2xhc3RBY3Rpb24gPT0gQUNUSU9OLlZFUlRJQ0FMKVxuICAgICAgICAvLyByZW1vdmUgbGFzdCBtb3ZlIGZyb20gc3RyaW5nXG4gICAgICAgIHRoaXMuX3BhdGggPSB0aGlzLl9wYXRoLnNsaWNlKDAsIHRoaXMuX3BhdGgubGFzdEluZGV4T2YoJ1YnKSk7XG4gICAgICB0aGlzLl9wYXRoICs9ICdWICcgKyB5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5WRVJUSUNBTDtcbiAgICB9XG4gIH1cblxuICB2ZXJ0aWNhbEQoZHkpIHtcbiAgICBbZHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oZHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94LCB0aGlzLl95ICsgZHkpKSB7XG4gICAgICB0aGlzLl9wYXRoICs9ICd2ICcgKyBkeSArICcgJztcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uVkVSVElDQUxfRDtcbiAgICB9XG4gIH1cblxuICBiZXppZXIoeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICBbeDEsIHkxLCB4MiwgeTIsIHgsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh4LCB5KSkge1xuICAgICAgdGhpcy5fcGF0aCArPVxuICAgICAgICAnQyAnICsgeDEgKyAnICcgKyB5MSArICcsICcgKyB4MiArICcgJyArIHkyICsgJywgJyArIHggKyAnICcgKyB5ICsgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5CRVpJRVI7XG4gICAgfVxuICB9XG5cbiAgYmV6aWVyRChkeDEsIGR5MSwgZHgyLCBkeTIsIGR4LCBkeSkge1xuICAgIFtkeDEsIGR5MSwgZHgyLCBkeTIsIGR4LCBkeV0gPSB0aGlzLl9hcHBseVByZWNpc2lvbihcbiAgICAgIGR4MSxcbiAgICAgIGR5MSxcbiAgICAgIGR4MixcbiAgICAgIGR5MixcbiAgICAgIGR4LFxuICAgICAgZHlcbiAgICApO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh0aGlzLl94ICsgZHgsIHRoaXMuX3kgKyBkeSkpIHtcbiAgICAgIHRoaXMuX3BhdGggKz1cbiAgICAgICAgJ2MgJyArXG4gICAgICAgIGR4MSArXG4gICAgICAgICcgJyArXG4gICAgICAgIGR5MSArXG4gICAgICAgICcsICcgK1xuICAgICAgICBkeDIgK1xuICAgICAgICAnICcgK1xuICAgICAgICBkeTIgK1xuICAgICAgICAnLCAnICtcbiAgICAgICAgZHggK1xuICAgICAgICAnICcgK1xuICAgICAgICBkeSArXG4gICAgICAgICcgJztcbiAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBBQ1RJT04uQkVaSUVSX0Q7XG4gICAgfVxuICB9XG5cbiAgYXJjKHJ4LCByeSwgcm90LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeCwgeSkge1xuICAgIFtyeCwgcnksIHJvdCwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHldID0gdGhpcy5fYXBwbHlQcmVjaXNpb24oXG4gICAgICByeCxcbiAgICAgIHJ5LFxuICAgICAgcm90LFxuICAgICAgbGFyZ2VBcmNGbGFnLFxuICAgICAgc3dlZXBGbGFnLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICApO1xuICAgIGlmICh0aGlzLl9wYXRoV2lsbENoYW5nZSh4LCB5KSkge1xuICAgICAgdGhpcy5fcGF0aCArPVxuICAgICAgICAnQSAnICtcbiAgICAgICAgcnggK1xuICAgICAgICAnICcgK1xuICAgICAgICByeSArXG4gICAgICAgICcgJyArXG4gICAgICAgIHJvdCArXG4gICAgICAgICcgJyArXG4gICAgICAgIGxhcmdlQXJjRmxhZyArXG4gICAgICAgICcgJyArXG4gICAgICAgIHN3ZWVwRmxhZyArXG4gICAgICAgICcgJyArXG4gICAgICAgIHggK1xuICAgICAgICAnICcgK1xuICAgICAgICB5ICtcbiAgICAgICAgJyAnO1xuICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IEFDVElPTi5BUkM7XG4gICAgfVxuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5fcGF0aCArPSAnWic7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/SvgPath.js\n"
          );

          /***/
        },

      /***/ './src/TransformData.js':
        /*!******************************!*\
  !*** ./src/TransformData.js ***!
  \******************************/
        /*! exports provided: default */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SplitStreamInputData.js */ \"./src/SplitStreamInputData.js\");\n\r\n\r\nconst TransformData = {\r\n  viscous: function (data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    // add nodes\r\n    for (let id in data.N) {\r\n      let node = data.N[id];\r\n      format.addNode(node.t, id, node.w, undefined, { labels: [id] });\r\n    }\r\n    // add tree structure\r\n    for (let t in data.EN) {\r\n      for (let id in data.EN[t]) {\r\n        let childArray = data.EN[t][id];\r\n        for (let childId of childArray) {\r\n          format.addParent(t, childId, id);\r\n        }\r\n      }\r\n    }\r\n    // add timeline\r\n    for (let stream in data.ET) {\r\n      for (let nodeId in data.ET[stream]) {\r\n        let t = data.N[nodeId].t;\r\n        for (let nextId of data.ET[stream][nodeId]) {\r\n          format.addNext(t, nodeId, nextId);\r\n        }\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  gumtree: function (data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    let idx = 0;\r\n\r\n    // follow the data format's post-order DFS approach\r\n    let traverse = (t, node) => {\r\n      if (!!node.children)\r\n        for (let i = 0; i < node.children.length; i++)\r\n          traverse(t, node.children[i]);\r\n\r\n      node.id = idx++;\r\n      format.addNode(t, node.id, node.length, node.pos, {\r\n        label: node.label,\r\n        type: node.type,\r\n        labels: [node.typeLabel]\r\n      });\r\n\r\n      // children need to be added in a second step, becaues ID is not known beforehand\r\n      if (!!node.children)\r\n        for (let i = 0; i < node.children.length; i++)\r\n          format.addParent(t, node.children[i].id, node.id);\r\n    };\r\n\r\n    for (let t in data.timesteps) {\r\n      idx = 0;\r\n      // add nodes and tree structure\r\n      traverse(t, data.timesteps[t].root);\r\n\r\n      // add timeline (start with second, because data needs to be written before being modified)\r\n      if (t > 0) {\r\n        if (!!data.changes[t - 1].matches)\r\n          for (let match of data.changes[t - 1].matches) {\r\n            format.addNext(t - 1, match.src, match.dest);\r\n          }\r\n\r\n        // find added, deleted nodes\r\n        // if (!!data.changes[t-1].actions)\r\n        // \tfor (let action of data.changes[t-1].actions) {\r\n        // \t\tif (action.action == \"delete\")\r\n        // \t\t\tcurrentTimestep.deleted[action.tree] = previousTimestep.references[action.tree];\r\n\r\n        // \t\t/*if (action.action == \"insert\") {\r\n        // \t\t\tcurrentTimestep.references[action.tree].insertAt = action.at;\r\n        // \t\t}*/\r\n        //     }\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  titan: function (data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    let t = -1;\r\n    let lastDate;\r\n    for (let entry of data) {\r\n      // when timestamp changes, create a new timestep\r\n      if (entry['observation_time'] != lastDate) {\r\n        lastDate = entry['observation_time'];\r\n        t++;\r\n      }\r\n      format.addNode(t, entry.id, +entry['cell_volume (km3)']);\r\n    }\r\n\r\n    t = -1;\r\n    for (let entry of data) {\r\n      if (entry['observation_time'] != lastDate) {\r\n        lastDate = entry['observation_time'];\r\n        t++;\r\n      }\r\n      let children = entry['IDs of children '];\r\n      if (!!children) {\r\n        if (typeof children == 'string') {\r\n          let next = children.split(', ');\r\n          if (next[0] != '')\r\n            next.forEach(nextId => format.addNext(t, entry.id, nextId));\r\n        } // single ID as number\r\n        else format.addNext(t, entry.id, children);\r\n      }\r\n    }\r\n\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  allen: function (data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](/*{forceFakeRoot: true}*/);\r\n    let timesteps = {\r\n      '2': 0,\r\n      '3': 1,\r\n      '5': 2,\r\n      '6': 3,\r\n      '7': 4,\r\n      '8': 5\r\n    };\r\n    let time = t => timesteps[t];\r\n\r\n    for (let structureId in data) {\r\n      let structure = data[structureId];\r\n      for (let step in structure.timesteps) {\r\n        let { id, timesteps, name, acronym, color, parent } = structure;\r\n        format.addNode(time(step), id, timesteps[step], undefined, {\r\n          name,\r\n          acronym,\r\n          color\r\n        });\r\n      }\r\n    }\r\n\r\n    for (let structureId in data) {\r\n      let structure = data[structureId];\r\n      for (let step in structure.timesteps) {\r\n        let { id, timesteps, name, acronym, color, parent } = structure;\r\n        format.addParent(time(step), id, parent);\r\n      }\r\n    }\r\n\r\n    format.connectEqualIds();\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  storyline: function (data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    const characters = [];\r\n    const locations = [];\r\n    for (let char of data.characters)\r\n      characters[char.id] = char.name.replace(/\\s+/g, '');\r\n    for (let loc of data.locations)\r\n      locations[loc.id] = loc.name.replace(/\\s+/g, '');\r\n\r\n    for (let session of data.sessions) {\r\n      for (let t = session.start; t < session.end; t++) {\r\n        format.addNode(\r\n          t,\r\n          locations[session.location],\r\n          undefined,\r\n          undefined,\r\n          locations[session.location]\r\n        );\r\n        for (let member of session.members) {\r\n          format.addNode(\r\n            t,\r\n            characters[member],\r\n            undefined,\r\n            undefined,\r\n            characters[member]\r\n          );\r\n          format.addParent(t, characters[member], locations[session.location]);\r\n        }\r\n      }\r\n    }\r\n\r\n    format.connectEqualIds();\r\n    format.finalize();\r\n    return format;\r\n  },\r\n\r\n  treemap: function (data) {\r\n    let format = new _SplitStreamInputData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n    for (let entry of data) {\r\n      let id = entry[0];\r\n      let parentId = entry[1];\r\n      for (let t = 2; t < entry.length; t++) {\r\n        if (entry[t] > 0) {\r\n          format.addNode(t, id, entry[t]);\r\n          format.addNode(t, parentId);\r\n          format.addParent(t, id, parentId);\r\n        }\r\n      }\r\n    }\r\n    format.connectEqualIds();\r\n    format.finalize();\r\n    return format;\r\n  }\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TransformData);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvVHJhbnNmb3JtRGF0YS5qcz9lNDk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBNkQ7O0FBRTdEO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EscUJBQXFCLGdFQUFvQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsZ0VBQW9CLElBQUksb0JBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhDQUE4QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EscUJBQXFCLGdFQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsZ0VBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLDRFQUFhLEVBQUMiLCJmaWxlIjoiLi9zcmMvVHJhbnNmb3JtRGF0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTcGxpdFN0cmVhbUlucHV0RGF0YSBmcm9tICcuL1NwbGl0U3RyZWFtSW5wdXREYXRhLmpzJztcclxuXHJcbmNvbnN0IFRyYW5zZm9ybURhdGEgPSB7XHJcbiAgdmlzY291czogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoKTtcclxuICAgIC8vIGFkZCBub2Rlc1xyXG4gICAgZm9yIChsZXQgaWQgaW4gZGF0YS5OKSB7XHJcbiAgICAgIGxldCBub2RlID0gZGF0YS5OW2lkXTtcclxuICAgICAgZm9ybWF0LmFkZE5vZGUobm9kZS50LCBpZCwgbm9kZS53LCB1bmRlZmluZWQsIHsgbGFiZWxzOiBbaWRdIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gYWRkIHRyZWUgc3RydWN0dXJlXHJcbiAgICBmb3IgKGxldCB0IGluIGRhdGEuRU4pIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gZGF0YS5FTlt0XSkge1xyXG4gICAgICAgIGxldCBjaGlsZEFycmF5ID0gZGF0YS5FTlt0XVtpZF07XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGRJZCBvZiBjaGlsZEFycmF5KSB7XHJcbiAgICAgICAgICBmb3JtYXQuYWRkUGFyZW50KHQsIGNoaWxkSWQsIGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGFkZCB0aW1lbGluZVxyXG4gICAgZm9yIChsZXQgc3RyZWFtIGluIGRhdGEuRVQpIHtcclxuICAgICAgZm9yIChsZXQgbm9kZUlkIGluIGRhdGEuRVRbc3RyZWFtXSkge1xyXG4gICAgICAgIGxldCB0ID0gZGF0YS5OW25vZGVJZF0udDtcclxuICAgICAgICBmb3IgKGxldCBuZXh0SWQgb2YgZGF0YS5FVFtzdHJlYW1dW25vZGVJZF0pIHtcclxuICAgICAgICAgIGZvcm1hdC5hZGROZXh0KHQsIG5vZGVJZCwgbmV4dElkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3JtYXQuZmluYWxpemUoKTtcclxuICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgfSxcclxuXHJcbiAgZ3VtdHJlZTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoKTtcclxuICAgIGxldCBpZHggPSAwO1xyXG5cclxuICAgIC8vIGZvbGxvdyB0aGUgZGF0YSBmb3JtYXQncyBwb3N0LW9yZGVyIERGUyBhcHByb2FjaFxyXG4gICAgbGV0IHRyYXZlcnNlID0gKHQsIG5vZGUpID0+IHtcclxuICAgICAgaWYgKCEhbm9kZS5jaGlsZHJlbilcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICB0cmF2ZXJzZSh0LCBub2RlLmNoaWxkcmVuW2ldKTtcclxuXHJcbiAgICAgIG5vZGUuaWQgPSBpZHgrKztcclxuICAgICAgZm9ybWF0LmFkZE5vZGUodCwgbm9kZS5pZCwgbm9kZS5sZW5ndGgsIG5vZGUucG9zLCB7XHJcbiAgICAgICAgbGFiZWw6IG5vZGUubGFiZWwsXHJcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxyXG4gICAgICAgIGxhYmVsczogW25vZGUudHlwZUxhYmVsXVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIGNoaWxkcmVuIG5lZWQgdG8gYmUgYWRkZWQgaW4gYSBzZWNvbmQgc3RlcCwgYmVjYXVlcyBJRCBpcyBub3Qga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICBpZiAoISFub2RlLmNoaWxkcmVuKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuICAgICAgICAgIGZvcm1hdC5hZGRQYXJlbnQodCwgbm9kZS5jaGlsZHJlbltpXS5pZCwgbm9kZS5pZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IHQgaW4gZGF0YS50aW1lc3RlcHMpIHtcclxuICAgICAgaWR4ID0gMDtcclxuICAgICAgLy8gYWRkIG5vZGVzIGFuZCB0cmVlIHN0cnVjdHVyZVxyXG4gICAgICB0cmF2ZXJzZSh0LCBkYXRhLnRpbWVzdGVwc1t0XS5yb290KTtcclxuXHJcbiAgICAgIC8vIGFkZCB0aW1lbGluZSAoc3RhcnQgd2l0aCBzZWNvbmQsIGJlY2F1c2UgZGF0YSBuZWVkcyB0byBiZSB3cml0dGVuIGJlZm9yZSBiZWluZyBtb2RpZmllZClcclxuICAgICAgaWYgKHQgPiAwKSB7XHJcbiAgICAgICAgaWYgKCEhZGF0YS5jaGFuZ2VzW3QgLSAxXS5tYXRjaGVzKVxyXG4gICAgICAgICAgZm9yIChsZXQgbWF0Y2ggb2YgZGF0YS5jaGFuZ2VzW3QgLSAxXS5tYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdC5hZGROZXh0KHQgLSAxLCBtYXRjaC5zcmMsIG1hdGNoLmRlc3QpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaW5kIGFkZGVkLCBkZWxldGVkIG5vZGVzXHJcbiAgICAgICAgLy8gaWYgKCEhZGF0YS5jaGFuZ2VzW3QtMV0uYWN0aW9ucylcclxuICAgICAgICAvLyBcdGZvciAobGV0IGFjdGlvbiBvZiBkYXRhLmNoYW5nZXNbdC0xXS5hY3Rpb25zKSB7XHJcbiAgICAgICAgLy8gXHRcdGlmIChhY3Rpb24uYWN0aW9uID09IFwiZGVsZXRlXCIpXHJcbiAgICAgICAgLy8gXHRcdFx0Y3VycmVudFRpbWVzdGVwLmRlbGV0ZWRbYWN0aW9uLnRyZWVdID0gcHJldmlvdXNUaW1lc3RlcC5yZWZlcmVuY2VzW2FjdGlvbi50cmVlXTtcclxuXHJcbiAgICAgICAgLy8gXHRcdC8qaWYgKGFjdGlvbi5hY3Rpb24gPT0gXCJpbnNlcnRcIikge1xyXG4gICAgICAgIC8vIFx0XHRcdGN1cnJlbnRUaW1lc3RlcC5yZWZlcmVuY2VzW2FjdGlvbi50cmVlXS5pbnNlcnRBdCA9IGFjdGlvbi5hdDtcclxuICAgICAgICAvLyBcdFx0fSovXHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9LFxyXG5cclxuICB0aXRhbjogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoKTtcclxuICAgIGxldCB0ID0gLTE7XHJcbiAgICBsZXQgbGFzdERhdGU7XHJcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhKSB7XHJcbiAgICAgIC8vIHdoZW4gdGltZXN0YW1wIGNoYW5nZXMsIGNyZWF0ZSBhIG5ldyB0aW1lc3RlcFxyXG4gICAgICBpZiAoZW50cnlbJ29ic2VydmF0aW9uX3RpbWUnXSAhPSBsYXN0RGF0ZSkge1xyXG4gICAgICAgIGxhc3REYXRlID0gZW50cnlbJ29ic2VydmF0aW9uX3RpbWUnXTtcclxuICAgICAgICB0Kys7XHJcbiAgICAgIH1cclxuICAgICAgZm9ybWF0LmFkZE5vZGUodCwgZW50cnkuaWQsICtlbnRyeVsnY2VsbF92b2x1bWUgKGttMyknXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdCA9IC0xO1xyXG4gICAgZm9yIChsZXQgZW50cnkgb2YgZGF0YSkge1xyXG4gICAgICBpZiAoZW50cnlbJ29ic2VydmF0aW9uX3RpbWUnXSAhPSBsYXN0RGF0ZSkge1xyXG4gICAgICAgIGxhc3REYXRlID0gZW50cnlbJ29ic2VydmF0aW9uX3RpbWUnXTtcclxuICAgICAgICB0Kys7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGNoaWxkcmVuID0gZW50cnlbJ0lEcyBvZiBjaGlsZHJlbiAnXTtcclxuICAgICAgaWYgKCEhY2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuLnNwbGl0KCcsICcpO1xyXG4gICAgICAgICAgaWYgKG5leHRbMF0gIT0gJycpXHJcbiAgICAgICAgICAgIG5leHQuZm9yRWFjaChuZXh0SWQgPT4gZm9ybWF0LmFkZE5leHQodCwgZW50cnkuaWQsIG5leHRJZCkpO1xyXG4gICAgICAgIH0gLy8gc2luZ2xlIElEIGFzIG51bWJlclxyXG4gICAgICAgIGVsc2UgZm9ybWF0LmFkZE5leHQodCwgZW50cnkuaWQsIGNoaWxkcmVuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9LFxyXG5cclxuICBhbGxlbjogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoLyp7Zm9yY2VGYWtlUm9vdDogdHJ1ZX0qLyk7XHJcbiAgICBsZXQgdGltZXN0ZXBzID0ge1xyXG4gICAgICAnMic6IDAsXHJcbiAgICAgICczJzogMSxcclxuICAgICAgJzUnOiAyLFxyXG4gICAgICAnNic6IDMsXHJcbiAgICAgICc3JzogNCxcclxuICAgICAgJzgnOiA1XHJcbiAgICB9O1xyXG4gICAgbGV0IHRpbWUgPSB0ID0+IHRpbWVzdGVwc1t0XTtcclxuXHJcbiAgICBmb3IgKGxldCBzdHJ1Y3R1cmVJZCBpbiBkYXRhKSB7XHJcbiAgICAgIGxldCBzdHJ1Y3R1cmUgPSBkYXRhW3N0cnVjdHVyZUlkXTtcclxuICAgICAgZm9yIChsZXQgc3RlcCBpbiBzdHJ1Y3R1cmUudGltZXN0ZXBzKSB7XHJcbiAgICAgICAgbGV0IHsgaWQsIHRpbWVzdGVwcywgbmFtZSwgYWNyb255bSwgY29sb3IsIHBhcmVudCB9ID0gc3RydWN0dXJlO1xyXG4gICAgICAgIGZvcm1hdC5hZGROb2RlKHRpbWUoc3RlcCksIGlkLCB0aW1lc3RlcHNbc3RlcF0sIHVuZGVmaW5lZCwge1xyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGFjcm9ueW0sXHJcbiAgICAgICAgICBjb2xvclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgc3RydWN0dXJlSWQgaW4gZGF0YSkge1xyXG4gICAgICBsZXQgc3RydWN0dXJlID0gZGF0YVtzdHJ1Y3R1cmVJZF07XHJcbiAgICAgIGZvciAobGV0IHN0ZXAgaW4gc3RydWN0dXJlLnRpbWVzdGVwcykge1xyXG4gICAgICAgIGxldCB7IGlkLCB0aW1lc3RlcHMsIG5hbWUsIGFjcm9ueW0sIGNvbG9yLCBwYXJlbnQgfSA9IHN0cnVjdHVyZTtcclxuICAgICAgICBmb3JtYXQuYWRkUGFyZW50KHRpbWUoc3RlcCksIGlkLCBwYXJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0LmNvbm5lY3RFcXVhbElkcygpO1xyXG4gICAgZm9ybWF0LmZpbmFsaXplKCk7XHJcbiAgICByZXR1cm4gZm9ybWF0O1xyXG4gIH0sXHJcblxyXG4gIHN0b3J5bGluZTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGxldCBmb3JtYXQgPSBuZXcgU3BsaXRTdHJlYW1JbnB1dERhdGEoKTtcclxuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBbXTtcclxuICAgIGNvbnN0IGxvY2F0aW9ucyA9IFtdO1xyXG4gICAgZm9yIChsZXQgY2hhciBvZiBkYXRhLmNoYXJhY3RlcnMpXHJcbiAgICAgIGNoYXJhY3RlcnNbY2hhci5pZF0gPSBjaGFyLm5hbWUucmVwbGFjZSgvXFxzKy9nLCAnJyk7XHJcbiAgICBmb3IgKGxldCBsb2Mgb2YgZGF0YS5sb2NhdGlvbnMpXHJcbiAgICAgIGxvY2F0aW9uc1tsb2MuaWRdID0gbG9jLm5hbWUucmVwbGFjZSgvXFxzKy9nLCAnJyk7XHJcblxyXG4gICAgZm9yIChsZXQgc2Vzc2lvbiBvZiBkYXRhLnNlc3Npb25zKSB7XHJcbiAgICAgIGZvciAobGV0IHQgPSBzZXNzaW9uLnN0YXJ0OyB0IDwgc2Vzc2lvbi5lbmQ7IHQrKykge1xyXG4gICAgICAgIGZvcm1hdC5hZGROb2RlKFxyXG4gICAgICAgICAgdCxcclxuICAgICAgICAgIGxvY2F0aW9uc1tzZXNzaW9uLmxvY2F0aW9uXSxcclxuICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgIGxvY2F0aW9uc1tzZXNzaW9uLmxvY2F0aW9uXVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZm9yIChsZXQgbWVtYmVyIG9mIHNlc3Npb24ubWVtYmVycykge1xyXG4gICAgICAgICAgZm9ybWF0LmFkZE5vZGUoXHJcbiAgICAgICAgICAgIHQsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlcnNbbWVtYmVyXSxcclxuICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlcnNbbWVtYmVyXVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGZvcm1hdC5hZGRQYXJlbnQodCwgY2hhcmFjdGVyc1ttZW1iZXJdLCBsb2NhdGlvbnNbc2Vzc2lvbi5sb2NhdGlvbl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdC5jb25uZWN0RXF1YWxJZHMoKTtcclxuICAgIGZvcm1hdC5maW5hbGl6ZSgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9LFxyXG5cclxuICB0cmVlbWFwOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgbGV0IGZvcm1hdCA9IG5ldyBTcGxpdFN0cmVhbUlucHV0RGF0YSgpO1xyXG4gICAgZm9yIChsZXQgZW50cnkgb2YgZGF0YSkge1xyXG4gICAgICBsZXQgaWQgPSBlbnRyeVswXTtcclxuICAgICAgbGV0IHBhcmVudElkID0gZW50cnlbMV07XHJcbiAgICAgIGZvciAobGV0IHQgPSAyOyB0IDwgZW50cnkubGVuZ3RoOyB0KyspIHtcclxuICAgICAgICBpZiAoZW50cnlbdF0gPiAwKSB7XHJcbiAgICAgICAgICBmb3JtYXQuYWRkTm9kZSh0LCBpZCwgZW50cnlbdF0pO1xyXG4gICAgICAgICAgZm9ybWF0LmFkZE5vZGUodCwgcGFyZW50SWQpO1xyXG4gICAgICAgICAgZm9ybWF0LmFkZFBhcmVudCh0LCBpZCwgcGFyZW50SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9ybWF0LmNvbm5lY3RFcXVhbElkcygpO1xyXG4gICAgZm9ybWF0LmZpbmFsaXplKCk7XHJcbiAgICByZXR1cm4gZm9ybWF0O1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybURhdGE7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/TransformData.js\n"
          );

          /***/
        },

      /***/ './src/functions.js':
        /*!**************************!*\
  !*** ./src/functions.js ***!
  \**************************/
        /*! exports provided: loadJSON, getRandomColor, saveSvg, savePng, saveJson, addLoadingSpinner, removeLoadingSpinner */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJSON\", function() { return loadJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRandomColor\", function() { return getRandomColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveSvg\", function() { return saveSvg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"savePng\", function() { return savePng; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveJson\", function() { return saveJson; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLoadingSpinner\", function() { return addLoadingSpinner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeLoadingSpinner\", function() { return removeLoadingSpinner; });\n/* harmony import */ var save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! save-svg-as-png */ \"./node_modules/save-svg-as-png/lib/saveSvgAsPng.js\");\n/* harmony import */ var save_svg_as_png__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction loadJSON(file, callback) {\n  var xobj = new XMLHttpRequest();\n  xobj.overrideMimeType('application/json');\n  xobj.open('GET', file, true); // Replace 'my_data' with the path to your file\n  xobj.onreadystatechange = function() {\n    if (xobj.readyState == 4 && xobj.status == '200') {\n      // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode\n      callback(xobj.responseText);\n    }\n  };\n  xobj.send(null);\n}\n\nfunction getRandomColor() {\n  var letters = '0123456789ABCDEF';\n  var color = '#';\n  for (var i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n}\n\n/* Modified from https://stackoverflow.com/questions/23218174/how-do-i-save-export-an-svg-file-after-creating-an-svg-with-d3-js-ie-safari-an */\nfunction saveSvg(svgEl, name) {\n  svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  var svgData = svgEl.outerHTML;\n  var preface = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n';\n  var svgBlob = new Blob([preface, svgData], {\n    type: 'image/svg+xml;charset=utf-8'\n  });\n  var svgUrl = URL.createObjectURL(svgBlob);\n  var downloadLink = document.createElement('a');\n  downloadLink.href = svgUrl;\n  downloadLink.download = name + '.svg';\n  document.body.appendChild(downloadLink);\n  downloadLink.click();\n  document.body.removeChild(downloadLink);\n}\n\nasync function savePng(svgEl, name) {\n  // store image in 16K+ res\n  // this can take a lot of time\n  addLoadingSpinner(document.querySelector('#wrapper'));\n  let scaleFactor = Math.ceil(15360 / svgEl.clientWidth);\n  await save_svg_as_png__WEBPACK_IMPORTED_MODULE_0__[\"saveSvgAsPng\"](svgEl, name + '.png', {\n    backgroundColor: 'white',\n    encoderOptions: 1,\n    scale: scaleFactor\n  });\n  removeLoadingSpinner(document.querySelector('#wrapper'));\n}\n\n/* Modified from https://stackoverflow.com/questions/19721439/download-json-object-as-a-file-from-browser */\nfunction saveJson(exportObj, exportName) {\n  var dataStr =\n    'data:text/json;charset=utf-8,' +\n    encodeURIComponent(JSON.stringify(exportObj));\n  var downloadAnchorNode = document.createElement('a');\n  downloadAnchorNode.setAttribute('href', dataStr);\n  downloadAnchorNode.setAttribute('download', exportName + '.json');\n  document.body.appendChild(downloadAnchorNode); // required for firefox\n  downloadAnchorNode.click();\n  downloadAnchorNode.remove();\n}\n\nfunction addLoadingSpinner(div) {\n  if (!div) {\n    console.log('addLoadingSpinner: div does not exist');\n    return;\n  }\n\n  if (!div.classList.contains('loading')) {\n    div.classList.add('loading');\n\n    let loader = document.createElement('div');\n    loader.classList = 'loader';\n    loader.style.top = div.scrollTop + 'px'; // position it correctly on scrollable divs\n    loader.onscroll = function(e) {\n      e.preventDefault();\n    };\n    div.appendChild(loader);\n\n    let spinner = document.createElement('div');\n    spinner.classList = 'spinner';\n    let size =\n      0.3 *\n      (loader.clientHeight > loader.clientWidth\n        ? loader.clientWidth\n        : loader.clientHeight);\n    spinner.style.width = size + 'px';\n    spinner.style.height = size + 'px';\n    spinner.style.borderWidth = 0.1 * size + 'px';\n    loader.appendChild(spinner);\n  }\n}\n\nfunction removeLoadingSpinner(div) {\n  if (!div) return;\n\n  let loader = div.querySelector('.loader');\n  if (!!loader) {\n    div.removeChild(loader);\n    div.classList.remove('loading');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvZnVuY3Rpb25zLmpzPzlmMjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7O0FBRWhDO0FBQ1A7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9mdW5jdGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzdmcgZnJvbSAnc2F2ZS1zdmctYXMtcG5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRKU09OKGZpbGUsIGNhbGxiYWNrKSB7XG4gIHZhciB4b2JqID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHhvYmoub3ZlcnJpZGVNaW1lVHlwZSgnYXBwbGljYXRpb24vanNvbicpO1xuICB4b2JqLm9wZW4oJ0dFVCcsIGZpbGUsIHRydWUpOyAvLyBSZXBsYWNlICdteV9kYXRhJyB3aXRoIHRoZSBwYXRoIHRvIHlvdXIgZmlsZVxuICB4b2JqLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh4b2JqLnJlYWR5U3RhdGUgPT0gNCAmJiB4b2JqLnN0YXR1cyA9PSAnMjAwJykge1xuICAgICAgLy8gUmVxdWlyZWQgdXNlIG9mIGFuIGFub255bW91cyBjYWxsYmFjayBhcyAub3BlbiB3aWxsIE5PVCByZXR1cm4gYSB2YWx1ZSBidXQgc2ltcGx5IHJldHVybnMgdW5kZWZpbmVkIGluIGFzeW5jaHJvbm91cyBtb2RlXG4gICAgICBjYWxsYmFjayh4b2JqLnJlc3BvbnNlVGV4dCk7XG4gICAgfVxuICB9O1xuICB4b2JqLnNlbmQobnVsbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21Db2xvcigpIHtcbiAgdmFyIGxldHRlcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRic7XG4gIHZhciBjb2xvciA9ICcjJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICBjb2xvciArPSBsZXR0ZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KV07XG4gIH1cbiAgcmV0dXJuIGNvbG9yO1xufVxuXG4vKiBNb2RpZmllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIzMjE4MTc0L2hvdy1kby1pLXNhdmUtZXhwb3J0LWFuLXN2Zy1maWxlLWFmdGVyLWNyZWF0aW5nLWFuLXN2Zy13aXRoLWQzLWpzLWllLXNhZmFyaS1hbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTdmcoc3ZnRWwsIG5hbWUpIHtcbiAgc3ZnRWwuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuICB2YXIgc3ZnRGF0YSA9IHN2Z0VsLm91dGVySFRNTDtcbiAgdmFyIHByZWZhY2UgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIHN0YW5kYWxvbmU9XCJub1wiPz5cXHJcXG4nO1xuICB2YXIgc3ZnQmxvYiA9IG5ldyBCbG9iKFtwcmVmYWNlLCBzdmdEYXRhXSwge1xuICAgIHR5cGU6ICdpbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgnXG4gIH0pO1xuICB2YXIgc3ZnVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdmdCbG9iKTtcbiAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgZG93bmxvYWRMaW5rLmhyZWYgPSBzdmdVcmw7XG4gIGRvd25sb2FkTGluay5kb3dubG9hZCA9IG5hbWUgKyAnLnN2Zyc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgZG93bmxvYWRMaW5rLmNsaWNrKCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRMaW5rKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVQbmcoc3ZnRWwsIG5hbWUpIHtcbiAgLy8gc3RvcmUgaW1hZ2UgaW4gMTZLKyByZXNcbiAgLy8gdGhpcyBjYW4gdGFrZSBhIGxvdCBvZiB0aW1lXG4gIGFkZExvYWRpbmdTcGlubmVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN3cmFwcGVyJykpO1xuICBsZXQgc2NhbGVGYWN0b3IgPSBNYXRoLmNlaWwoMTUzNjAgLyBzdmdFbC5jbGllbnRXaWR0aCk7XG4gIGF3YWl0IHN2Zy5zYXZlU3ZnQXNQbmcoc3ZnRWwsIG5hbWUgKyAnLnBuZycsIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgZW5jb2Rlck9wdGlvbnM6IDEsXG4gICAgc2NhbGU6IHNjYWxlRmFjdG9yXG4gIH0pO1xuICByZW1vdmVMb2FkaW5nU3Bpbm5lcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjd3JhcHBlcicpKTtcbn1cblxuLyogTW9kaWZpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMTQzOS9kb3dubG9hZC1qc29uLW9iamVjdC1hcy1hLWZpbGUtZnJvbS1icm93c2VyICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUpzb24oZXhwb3J0T2JqLCBleHBvcnROYW1lKSB7XG4gIHZhciBkYXRhU3RyID1cbiAgICAnZGF0YTp0ZXh0L2pzb247Y2hhcnNldD11dGYtOCwnICtcbiAgICBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZXhwb3J0T2JqKSk7XG4gIHZhciBkb3dubG9hZEFuY2hvck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGRvd25sb2FkQW5jaG9yTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBkYXRhU3RyKTtcbiAgZG93bmxvYWRBbmNob3JOb2RlLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBleHBvcnROYW1lICsgJy5qc29uJyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRBbmNob3JOb2RlKTsgLy8gcmVxdWlyZWQgZm9yIGZpcmVmb3hcbiAgZG93bmxvYWRBbmNob3JOb2RlLmNsaWNrKCk7XG4gIGRvd25sb2FkQW5jaG9yTm9kZS5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExvYWRpbmdTcGlubmVyKGRpdikge1xuICBpZiAoIWRpdikge1xuICAgIGNvbnNvbGUubG9nKCdhZGRMb2FkaW5nU3Bpbm5lcjogZGl2IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFkaXYuY2xhc3NMaXN0LmNvbnRhaW5zKCdsb2FkaW5nJykpIHtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZCgnbG9hZGluZycpO1xuXG4gICAgbGV0IGxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxvYWRlci5jbGFzc0xpc3QgPSAnbG9hZGVyJztcbiAgICBsb2FkZXIuc3R5bGUudG9wID0gZGl2LnNjcm9sbFRvcCArICdweCc7IC8vIHBvc2l0aW9uIGl0IGNvcnJlY3RseSBvbiBzY3JvbGxhYmxlIGRpdnNcbiAgICBsb2FkZXIub25zY3JvbGwgPSBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQobG9hZGVyKTtcblxuICAgIGxldCBzcGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3Bpbm5lci5jbGFzc0xpc3QgPSAnc3Bpbm5lcic7XG4gICAgbGV0IHNpemUgPVxuICAgICAgMC4zICpcbiAgICAgIChsb2FkZXIuY2xpZW50SGVpZ2h0ID4gbG9hZGVyLmNsaWVudFdpZHRoXG4gICAgICAgID8gbG9hZGVyLmNsaWVudFdpZHRoXG4gICAgICAgIDogbG9hZGVyLmNsaWVudEhlaWdodCk7XG4gICAgc3Bpbm5lci5zdHlsZS53aWR0aCA9IHNpemUgKyAncHgnO1xuICAgIHNwaW5uZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZSArICdweCc7XG4gICAgc3Bpbm5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IDAuMSAqIHNpemUgKyAncHgnO1xuICAgIGxvYWRlci5hcHBlbmRDaGlsZChzcGlubmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTG9hZGluZ1NwaW5uZXIoZGl2KSB7XG4gIGlmICghZGl2KSByZXR1cm47XG5cbiAgbGV0IGxvYWRlciA9IGRpdi5xdWVyeVNlbGVjdG9yKCcubG9hZGVyJyk7XG4gIGlmICghIWxvYWRlcikge1xuICAgIGRpdi5yZW1vdmVDaGlsZChsb2FkZXIpO1xuICAgIGRpdi5jbGFzc0xpc3QucmVtb3ZlKCdsb2FkaW5nJyk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/functions.js\n"
          );

          /***/
        },

      /***/ './src/lib.js':
        /*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
        /*! exports provided: SplitStream, SplitStreamInputData, SplitStreamFilter, TransformData */
        /***/ function(module, __webpack_exports__, __webpack_require__) {
          'use strict';
          eval(
            '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SplitStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SplitStream */ "./src/SplitStream.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStream", function() { return _SplitStream__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _SplitStreamInputData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SplitStreamInputData */ "./src/SplitStreamInputData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStreamInputData", function() { return _SplitStreamInputData__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _SplitStreamFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SplitStreamFilter */ "./src/SplitStreamFilter.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SplitStreamFilter", function() { return _SplitStreamFilter__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _TransformData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TransformData */ "./src/TransformData.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformData", function() { return _TransformData__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvLi9zcmMvbGliLmpzPzM0ZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBd0M7QUFDa0I7QUFDTjtBQUNSOztBQUVtQyIsImZpbGUiOiIuL3NyYy9saWIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3BsaXRTdHJlYW0gZnJvbSAnLi9TcGxpdFN0cmVhbSc7XHJcbmltcG9ydCBTcGxpdFN0cmVhbUlucHV0RGF0YSBmcm9tICcuL1NwbGl0U3RyZWFtSW5wdXREYXRhJztcclxuaW1wb3J0IFNwbGl0U3RyZWFtRmlsdGVyIGZyb20gJy4vU3BsaXRTdHJlYW1GaWx0ZXInO1xyXG5pbXBvcnQgVHJhbnNmb3JtRGF0YSBmcm9tICcuL1RyYW5zZm9ybURhdGEnO1xyXG5cclxuZXhwb3J0IHsgU3BsaXRTdHJlYW0sIFNwbGl0U3RyZWFtSW5wdXREYXRhLCBTcGxpdFN0cmVhbUZpbHRlciwgVHJhbnNmb3JtRGF0YSB9O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib.js\n'
          );

          /***/
        },

      /***/ d3:
        /*!*********************!*\
  !*** external "d3" ***!
  \*********************/
        /*! no static exports found */
        /***/ function(module, exports) {
          eval(
            'module.exports = __WEBPACK_EXTERNAL_MODULE_d3__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TcGxpdFN0cmVhbXMvZXh0ZXJuYWwgXCJkM1wiPzQzNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiZDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZDNfXzsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///d3\n'
          );

          /***/
        }

      /******/
    }
  );
});
